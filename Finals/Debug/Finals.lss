
5_Position_Control_Interrupts.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800200  00003de6  00003e7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003de6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000006c  00800204  00800204  00003e7e  2**0
                  ALLOC
  3 .stab         000033fc  00000000  00000000  00003e80  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009aa  00000000  00000000  0000727c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000a0  00000000  00000000  00007c28  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004ef2  00000000  00000000  00007cc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000003f4  00000000  00000000  0000cbba  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001446  00000000  00000000  0000cfae  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000658  00000000  00000000  0000e3f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006a7  00000000  00000000  0000ea4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004fa0  00000000  00000000  0000f0f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  00014093  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 ba 03 	jmp	0x774	; 0x774 <__vector_5>
      18:	0c 94 95 03 	jmp	0x72a	; 0x72a <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <angle_rotate+0x38>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e6 ee       	ldi	r30, 0xE6	; 230
     17e:	fd e3       	ldi	r31, 0x3D	; 61
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a4 30       	cpi	r26, 0x04	; 4
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	12 e0       	ldi	r17, 0x02	; 2
     192:	a4 e0       	ldi	r26, 0x04	; 4
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a0 37       	cpi	r26, 0x70	; 112
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 7d 1b 	call	0x36fa	; 0x36fa <main>
     1a4:	0c 94 f1 1e 	jmp	0x3de2	; 0x3de2 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1ac:	86 e6       	ldi	r24, 0x66	; 102
     1ae:	9e e0       	ldi	r25, 0x0E	; 14
     1b0:	01 97       	sbiw	r24, 0x01	; 1
     1b2:	f1 f7       	brne	.-4      	; 0x1b0 <lcd_set_4bit+0x4>
     1b4:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1b6:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1b8:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1ba:	80 e3       	ldi	r24, 0x30	; 48
     1bc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1be:	42 9a       	sbi	0x08, 2	; 8
     1c0:	ef ef       	ldi	r30, 0xFF	; 255
     1c2:	f7 e4       	ldi	r31, 0x47	; 71
     1c4:	31 97       	sbiw	r30, 0x01	; 1
     1c6:	f1 f7       	brne	.-4      	; 0x1c4 <lcd_set_4bit+0x18>
     1c8:	00 c0       	rjmp	.+0      	; 0x1ca <lcd_set_4bit+0x1e>
     1ca:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1cc:	42 98       	cbi	0x08, 2	; 8
     1ce:	e6 e6       	ldi	r30, 0x66	; 102
     1d0:	fe e0       	ldi	r31, 0x0E	; 14
     1d2:	31 97       	sbiw	r30, 0x01	; 1
     1d4:	f1 f7       	brne	.-4      	; 0x1d2 <lcd_set_4bit+0x26>
     1d6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1d8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1da:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1de:	42 9a       	sbi	0x08, 2	; 8
     1e0:	ef ef       	ldi	r30, 0xFF	; 255
     1e2:	f7 e4       	ldi	r31, 0x47	; 71
     1e4:	31 97       	sbiw	r30, 0x01	; 1
     1e6:	f1 f7       	brne	.-4      	; 0x1e4 <lcd_set_4bit+0x38>
     1e8:	00 c0       	rjmp	.+0      	; 0x1ea <lcd_set_4bit+0x3e>
     1ea:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1ec:	42 98       	cbi	0x08, 2	; 8
     1ee:	e6 e6       	ldi	r30, 0x66	; 102
     1f0:	fe e0       	ldi	r31, 0x0E	; 14
     1f2:	31 97       	sbiw	r30, 0x01	; 1
     1f4:	f1 f7       	brne	.-4      	; 0x1f2 <lcd_set_4bit+0x46>
     1f6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1f8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1fa:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1fc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1fe:	42 9a       	sbi	0x08, 2	; 8
     200:	8f ef       	ldi	r24, 0xFF	; 255
     202:	97 e4       	ldi	r25, 0x47	; 71
     204:	01 97       	sbiw	r24, 0x01	; 1
     206:	f1 f7       	brne	.-4      	; 0x204 <lcd_set_4bit+0x58>
     208:	00 c0       	rjmp	.+0      	; 0x20a <lcd_set_4bit+0x5e>
     20a:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     20c:	42 98       	cbi	0x08, 2	; 8
     20e:	e6 e6       	ldi	r30, 0x66	; 102
     210:	fe e0       	ldi	r31, 0x0E	; 14
     212:	31 97       	sbiw	r30, 0x01	; 1
     214:	f1 f7       	brne	.-4      	; 0x212 <lcd_set_4bit+0x66>
     216:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     218:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     21a:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     21c:	80 e2       	ldi	r24, 0x20	; 32
     21e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     220:	42 9a       	sbi	0x08, 2	; 8
     222:	8f ef       	ldi	r24, 0xFF	; 255
     224:	97 e4       	ldi	r25, 0x47	; 71
     226:	01 97       	sbiw	r24, 0x01	; 1
     228:	f1 f7       	brne	.-4      	; 0x226 <lcd_set_4bit+0x7a>
     22a:	00 c0       	rjmp	.+0      	; 0x22c <lcd_set_4bit+0x80>
     22c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     22e:	42 98       	cbi	0x08, 2	; 8

	
}
     230:	08 95       	ret

00000232 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     232:	98 b1       	in	r25, 0x08	; 8
     234:	9f 70       	andi	r25, 0x0F	; 15
     236:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     238:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     23a:	28 2f       	mov	r18, r24
     23c:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     23e:	92 2b       	or	r25, r18
     240:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     242:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     244:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     246:	42 9a       	sbi	0x08, 2	; 8
     248:	ef ef       	ldi	r30, 0xFF	; 255
     24a:	f7 e4       	ldi	r31, 0x47	; 71
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	f1 f7       	brne	.-4      	; 0x24c <lcd_wr_command+0x1a>
     250:	00 c0       	rjmp	.+0      	; 0x252 <lcd_wr_command+0x20>
     252:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     254:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     256:	98 b1       	in	r25, 0x08	; 8
     258:	9f 70       	andi	r25, 0x0F	; 15
     25a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     25c:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     25e:	82 95       	swap	r24
     260:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     262:	89 2b       	or	r24, r25
     264:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     266:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     268:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     26a:	42 9a       	sbi	0x08, 2	; 8
     26c:	8f ef       	ldi	r24, 0xFF	; 255
     26e:	97 e4       	ldi	r25, 0x47	; 71
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	f1 f7       	brne	.-4      	; 0x270 <lcd_wr_command+0x3e>
     274:	00 c0       	rjmp	.+0      	; 0x276 <lcd_wr_command+0x44>
     276:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     278:	42 98       	cbi	0x08, 2	; 8
}
     27a:	08 95       	ret

0000027c <lcd_init>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
     27c:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_set_4bit>
     280:	86 e6       	ldi	r24, 0x66	; 102
     282:	9e e0       	ldi	r25, 0x0E	; 14
     284:	01 97       	sbiw	r24, 0x01	; 1
     286:	f1 f7       	brne	.-4      	; 0x284 <lcd_init+0x8>
     288:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     28a:	88 e2       	ldi	r24, 0x28	; 40
     28c:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x01);
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x06);
     296:	86 e0       	ldi	r24, 0x06	; 6
     298:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x0E);
     29c:	8e e0       	ldi	r24, 0x0E	; 14
     29e:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x80);
     2a2:	80 e8       	ldi	r24, 0x80	; 128
     2a4:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
		
}
     2a8:	08 95       	ret

000002aa <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     2aa:	98 b1       	in	r25, 0x08	; 8
     2ac:	9f 70       	andi	r25, 0x0F	; 15
     2ae:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     2b0:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     2b2:	28 2f       	mov	r18, r24
     2b4:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     2b6:	92 2b       	or	r25, r18
     2b8:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     2ba:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2bc:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2be:	42 9a       	sbi	0x08, 2	; 8
     2c0:	ef ef       	ldi	r30, 0xFF	; 255
     2c2:	f7 e4       	ldi	r31, 0x47	; 71
     2c4:	31 97       	sbiw	r30, 0x01	; 1
     2c6:	f1 f7       	brne	.-4      	; 0x2c4 <lcd_wr_char+0x1a>
     2c8:	00 c0       	rjmp	.+0      	; 0x2ca <lcd_wr_char+0x20>
     2ca:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2cc:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     2ce:	98 b1       	in	r25, 0x08	; 8
     2d0:	9f 70       	andi	r25, 0x0F	; 15
     2d2:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     2d4:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     2d6:	82 95       	swap	r24
     2d8:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     2da:	89 2b       	or	r24, r25
     2dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     2de:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2e0:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2e2:	42 9a       	sbi	0x08, 2	; 8
     2e4:	8f ef       	ldi	r24, 0xFF	; 255
     2e6:	97 e4       	ldi	r25, 0x47	; 71
     2e8:	01 97       	sbiw	r24, 0x01	; 1
     2ea:	f1 f7       	brne	.-4      	; 0x2e8 <lcd_wr_char+0x3e>
     2ec:	00 c0       	rjmp	.+0      	; 0x2ee <lcd_wr_char+0x44>
     2ee:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2f0:	42 98       	cbi	0x08, 2	; 8
}
     2f2:	08 95       	ret

000002f4 <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     2f4:	80 e8       	ldi	r24, 0x80	; 128
     2f6:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
}
     2fa:	08 95       	ret

000002fc <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     2fc:	cf 93       	push	r28
     2fe:	df 93       	push	r29
     300:	ec 01       	movw	r28, r24
	while(*str != '\0')
     302:	88 81       	ld	r24, Y
     304:	88 23       	and	r24, r24
     306:	31 f0       	breq	.+12     	; 0x314 <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     308:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     30a:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     30e:	89 91       	ld	r24, Y+
     310:	88 23       	and	r24, r24
     312:	d9 f7       	brne	.-10     	; 0x30a <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     314:	df 91       	pop	r29
     316:	cf 91       	pop	r28
     318:	08 95       	ret

0000031a <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     31a:	82 30       	cpi	r24, 0x02	; 2
     31c:	79 f0       	breq	.+30     	; 0x33c <lcd_cursor+0x22>
     31e:	83 30       	cpi	r24, 0x03	; 3
     320:	18 f4       	brcc	.+6      	; 0x328 <lcd_cursor+0xe>
     322:	81 30       	cpi	r24, 0x01	; 1
     324:	c9 f4       	brne	.+50     	; 0x358 <lcd_cursor+0x3e>
     326:	05 c0       	rjmp	.+10     	; 0x332 <lcd_cursor+0x18>
     328:	83 30       	cpi	r24, 0x03	; 3
     32a:	69 f0       	breq	.+26     	; 0x346 <lcd_cursor+0x2c>
     32c:	84 30       	cpi	r24, 0x04	; 4
     32e:	a1 f4       	brne	.+40     	; 0x358 <lcd_cursor+0x3e>
     330:	0f c0       	rjmp	.+30     	; 0x350 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     332:	86 2f       	mov	r24, r22
     334:	81 58       	subi	r24, 0x81	; 129
     336:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     33a:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     33c:	86 2f       	mov	r24, r22
     33e:	81 54       	subi	r24, 0x41	; 65
     340:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     344:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     346:	86 2f       	mov	r24, r22
     348:	8d 56       	subi	r24, 0x6D	; 109
     34a:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     34e:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     350:	86 2f       	mov	r24, r22
     352:	8d 52       	subi	r24, 0x2D	; 45
     354:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     358:	08 95       	ret

0000035a <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     35a:	0f 93       	push	r16
     35c:	1f 93       	push	r17
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	8a 01       	movw	r16, r20
     364:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     366:	88 23       	and	r24, r24
     368:	11 f0       	breq	.+4      	; 0x36e <lcd_print+0x14>
     36a:	66 23       	and	r22, r22
     36c:	19 f4       	brne	.+6      	; 0x374 <lcd_print+0x1a>
	{
		lcd_home();
     36e:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <lcd_home>
     372:	02 c0       	rjmp	.+4      	; 0x378 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     374:	0e 94 8d 01 	call	0x31a	; 0x31a <lcd_cursor>
	}
	if(digits==5 || flag==1)
     378:	c5 30       	cpi	r28, 0x05	; 5
     37a:	d1 05       	cpc	r29, r1
     37c:	71 f4       	brne	.+28     	; 0x39a <lcd_print+0x40>
	{
		million=value/10000+48;
     37e:	c8 01       	movw	r24, r16
     380:	60 e1       	ldi	r22, 0x10	; 16
     382:	77 e2       	ldi	r23, 0x27	; 39
     384:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     388:	cb 01       	movw	r24, r22
     38a:	c0 96       	adiw	r24, 0x30	; 48
     38c:	90 93 61 02 	sts	0x0261, r25
     390:	80 93 60 02 	sts	0x0260, r24
		lcd_wr_char(million);
     394:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
     398:	03 c0       	rjmp	.+6      	; 0x3a0 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     39a:	c4 30       	cpi	r28, 0x04	; 4
     39c:	d1 05       	cpc	r29, r1
     39e:	b9 f4       	brne	.+46     	; 0x3ce <lcd_print+0x74>
	{
		temp = value/1000;
     3a0:	c8 01       	movw	r24, r16
     3a2:	68 ee       	ldi	r22, 0xE8	; 232
     3a4:	73 e0       	ldi	r23, 0x03	; 3
     3a6:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     3aa:	cb 01       	movw	r24, r22
     3ac:	70 93 64 02 	sts	0x0264, r23
     3b0:	60 93 63 02 	sts	0x0263, r22
		thousand = temp%10 + 48;
     3b4:	6a e0       	ldi	r22, 0x0A	; 10
     3b6:	70 e0       	ldi	r23, 0x00	; 0
     3b8:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     3bc:	c0 96       	adiw	r24, 0x30	; 48
     3be:	90 93 6f 02 	sts	0x026F, r25
     3c2:	80 93 6e 02 	sts	0x026E, r24
		lcd_wr_char(thousand);
     3c6:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
		flag=1;
     3ca:	81 e0       	ldi	r24, 0x01	; 1
     3cc:	01 c0       	rjmp	.+2      	; 0x3d0 <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     3ce:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     3d0:	c3 30       	cpi	r28, 0x03	; 3
     3d2:	d1 05       	cpc	r29, r1
     3d4:	11 f0       	breq	.+4      	; 0x3da <lcd_print+0x80>
     3d6:	81 30       	cpi	r24, 0x01	; 1
     3d8:	b1 f4       	brne	.+44     	; 0x406 <lcd_print+0xac>
	{
		temp = value/100;
     3da:	c8 01       	movw	r24, r16
     3dc:	64 e6       	ldi	r22, 0x64	; 100
     3de:	70 e0       	ldi	r23, 0x00	; 0
     3e0:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     3e4:	cb 01       	movw	r24, r22
     3e6:	70 93 64 02 	sts	0x0264, r23
     3ea:	60 93 63 02 	sts	0x0263, r22
		hundred = temp%10 + 48;
     3ee:	6a e0       	ldi	r22, 0x0A	; 10
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     3f6:	c0 96       	adiw	r24, 0x30	; 48
     3f8:	90 93 6b 02 	sts	0x026B, r25
     3fc:	80 93 6a 02 	sts	0x026A, r24
		lcd_wr_char(hundred);
     400:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
		flag=1;
     404:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     406:	c2 30       	cpi	r28, 0x02	; 2
     408:	d1 05       	cpc	r29, r1
     40a:	11 f0       	breq	.+4      	; 0x410 <lcd_print+0xb6>
     40c:	81 30       	cpi	r24, 0x01	; 1
     40e:	b1 f4       	brne	.+44     	; 0x43c <lcd_print+0xe2>
	{
		temp = value/10;
     410:	2a e0       	ldi	r18, 0x0A	; 10
     412:	30 e0       	ldi	r19, 0x00	; 0
     414:	c8 01       	movw	r24, r16
     416:	b9 01       	movw	r22, r18
     418:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     41c:	cb 01       	movw	r24, r22
     41e:	70 93 64 02 	sts	0x0264, r23
     422:	60 93 63 02 	sts	0x0263, r22
		tens = temp%10 + 48;
     426:	b9 01       	movw	r22, r18
     428:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     42c:	c0 96       	adiw	r24, 0x30	; 48
     42e:	90 93 68 02 	sts	0x0268, r25
     432:	80 93 67 02 	sts	0x0267, r24
		lcd_wr_char(tens);
     436:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
		flag=1;
     43a:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     43c:	c1 30       	cpi	r28, 0x01	; 1
     43e:	d1 05       	cpc	r29, r1
     440:	11 f0       	breq	.+4      	; 0x446 <lcd_print+0xec>
     442:	81 30       	cpi	r24, 0x01	; 1
     444:	61 f4       	brne	.+24     	; 0x45e <lcd_print+0x104>
	{
		unit = value%10 + 48;
     446:	c8 01       	movw	r24, r16
     448:	6a e0       	ldi	r22, 0x0A	; 10
     44a:	70 e0       	ldi	r23, 0x00	; 0
     44c:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     450:	c0 96       	adiw	r24, 0x30	; 48
     452:	90 93 6d 02 	sts	0x026D, r25
     456:	80 93 6c 02 	sts	0x026C, r24
		lcd_wr_char(unit);
     45a:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
	}
	if(digits>5)
     45e:	c6 30       	cpi	r28, 0x06	; 6
     460:	d1 05       	cpc	r29, r1
     462:	1c f0       	brlt	.+6      	; 0x46a <lcd_print+0x110>
	{
		lcd_wr_char('E');
     464:	85 e4       	ldi	r24, 0x45	; 69
     466:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
	}
	
}
     46a:	df 91       	pop	r29
     46c:	cf 91       	pop	r28
     46e:	1f 91       	pop	r17
     470:	0f 91       	pop	r16
     472:	08 95       	ret

00000474 <CurPos>:
* Logic: Updates robot's current position as it traverses the arena during cargo alignment, giving proper mnagement.  
* Example Call: CurPos(1,0,0,0); //Increments Cur_Pos[1] by 1.
*
*/	
void CurPos(int fwd, int bk, int r, int l)
{
     474:	f9 01       	movw	r30, r18
		if(fwd!=0)
     476:	00 97       	sbiw	r24, 0x00	; 0
     478:	51 f0       	breq	.+20     	; 0x48e <CurPos+0x1a>
		{Cur_Pos[1]+=fwd;}
     47a:	20 91 02 02 	lds	r18, 0x0202
     47e:	30 91 03 02 	lds	r19, 0x0203
     482:	82 0f       	add	r24, r18
     484:	93 1f       	adc	r25, r19
     486:	90 93 03 02 	sts	0x0203, r25
     48a:	80 93 02 02 	sts	0x0202, r24
		if(bk!=0){Cur_Pos[1]-=bk;}
     48e:	61 15       	cp	r22, r1
     490:	71 05       	cpc	r23, r1
     492:	51 f0       	breq	.+20     	; 0x4a8 <CurPos+0x34>
     494:	80 91 02 02 	lds	r24, 0x0202
     498:	90 91 03 02 	lds	r25, 0x0203
     49c:	86 1b       	sub	r24, r22
     49e:	97 0b       	sbc	r25, r23
     4a0:	90 93 03 02 	sts	0x0203, r25
     4a4:	80 93 02 02 	sts	0x0202, r24
		if(r!=0){Cur_Pos[0]-=r;}
     4a8:	41 15       	cp	r20, r1
     4aa:	51 05       	cpc	r21, r1
     4ac:	51 f0       	breq	.+20     	; 0x4c2 <CurPos+0x4e>
     4ae:	80 91 00 02 	lds	r24, 0x0200
     4b2:	90 91 01 02 	lds	r25, 0x0201
     4b6:	84 1b       	sub	r24, r20
     4b8:	95 0b       	sbc	r25, r21
     4ba:	90 93 01 02 	sts	0x0201, r25
     4be:	80 93 00 02 	sts	0x0200, r24
		if(l!=0)
     4c2:	30 97       	sbiw	r30, 0x00	; 0
     4c4:	51 f0       	breq	.+20     	; 0x4da <CurPos+0x66>
		{Cur_Pos[0]+=l;}		
     4c6:	80 91 00 02 	lds	r24, 0x0200
     4ca:	90 91 01 02 	lds	r25, 0x0201
     4ce:	e8 0f       	add	r30, r24
     4d0:	f9 1f       	adc	r31, r25
     4d2:	f0 93 01 02 	sts	0x0201, r31
     4d6:	e0 93 00 02 	sts	0x0200, r30
     4da:	08 95       	ret

000004dc <servo1_pin_config>:
* Example Call: servo1_pin_config();
*
*/				
void servo1_pin_config (void)
{
	DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
     4dc:	25 9a       	sbi	0x04, 5	; 4
	PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
     4de:	2d 9a       	sbi	0x05, 5	; 5
}
     4e0:	08 95       	ret

000004e2 <servo2_pin_config>:
*
*/	
//Configure PORTB 6 pin for servo motor 2 operation
void servo2_pin_config (void)
{
	DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
     4e2:	26 9a       	sbi	0x04, 6	; 4
	PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
     4e4:	2e 9a       	sbi	0x05, 6	; 5
}
     4e6:	08 95       	ret

000004e8 <motion_pin_config>:
* Example:motion_pin_config();
*
*/	
void motion_pin_config (void)
{
	DDRA = DDRA | 0x0F;
     4e8:	81 b1       	in	r24, 0x01	; 1
     4ea:	8f 60       	ori	r24, 0x0F	; 15
     4ec:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     4ee:	82 b1       	in	r24, 0x02	; 2
     4f0:	80 7f       	andi	r24, 0xF0	; 240
     4f2:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     4f4:	ea e0       	ldi	r30, 0x0A	; 10
     4f6:	f1 e0       	ldi	r31, 0x01	; 1
     4f8:	80 81       	ld	r24, Z
     4fa:	88 61       	ori	r24, 0x18	; 24
     4fc:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     4fe:	eb e0       	ldi	r30, 0x0B	; 11
     500:	f1 e0       	ldi	r31, 0x01	; 1
     502:	80 81       	ld	r24, Z
     504:	88 61       	ori	r24, 0x18	; 24
     506:	80 83       	st	Z, r24
}
     508:	08 95       	ret

0000050a <adc_pin_config>:
* Example Call: adc_pin_config();
*
*/	
void adc_pin_config (void)
{
	DDRF = 0x00;
     50a:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00;
     50c:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00;
     50e:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00;
     512:	10 92 08 01 	sts	0x0108, r1
}
     516:	08 95       	ret

00000518 <velocity>:
* Example Call: velocity(215,215);
*
*/	
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     518:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
     51c:	60 93 2a 01 	sts	0x012A, r22
}
     520:	08 95       	ret

00000522 <timer5_init>:
* Example Call: timer5_init();
*
*/	
void timer5_init(void)
{
	TCCR5B = 0x00;	//Stop
     522:	e1 e2       	ldi	r30, 0x21	; 33
     524:	f1 e0       	ldi	r31, 0x01	; 1
     526:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
     528:	8f ef       	ldi	r24, 0xFF	; 255
     52a:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
     52e:	91 e0       	ldi	r25, 0x01	; 1
     530:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
     534:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
     538:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
     53c:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
     540:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
     544:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
     548:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
     54c:	89 ea       	ldi	r24, 0xA9	; 169
     54e:	80 93 20 01 	sts	0x0120, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
     552:	8b e0       	ldi	r24, 0x0B	; 11
     554:	80 83       	st	Z, r24
}
     556:	08 95       	ret

00000558 <timer1_init>:
* Example Call: timer1_init();
*
*/	
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     558:	e1 e8       	ldi	r30, 0x81	; 129
     55a:	f0 e0       	ldi	r31, 0x00	; 0
     55c:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
     55e:	8c ef       	ldi	r24, 0xFC	; 252
     560:	80 93 85 00 	sts	0x0085, r24
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	80 93 84 00 	sts	0x0084, r24
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
     56a:	93 e0       	ldi	r25, 0x03	; 3
     56c:	90 93 89 00 	sts	0x0089, r25
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
     570:	8f ef       	ldi	r24, 0xFF	; 255
     572:	80 93 88 00 	sts	0x0088, r24
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
     576:	90 93 8b 00 	sts	0x008B, r25
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
     57a:	80 93 8a 00 	sts	0x008A, r24
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
     57e:	90 93 8d 00 	sts	0x008D, r25
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
     582:	80 93 8c 00 	sts	0x008C, r24
 ICR1H  = 0x03;	
     586:	90 93 87 00 	sts	0x0087, r25
 ICR1L  = 0xFF;
     58a:	80 93 86 00 	sts	0x0086, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
     58e:	8b ea       	ldi	r24, 0xAB	; 171
     590:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
     594:	10 92 82 00 	sts	0x0082, r1
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
     598:	8c e0       	ldi	r24, 0x0C	; 12
     59a:	80 83       	st	Z, r24
}
     59c:	08 95       	ret

0000059e <buzzer_on>:
*
*/	
void buzzer_on(void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     59e:	86 b1       	in	r24, 0x06	; 6
 port_restore = port_restore | 0x08;
     5a0:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
     5a2:	88 b9       	out	0x08, r24	; 8
}
     5a4:	08 95       	ret

000005a6 <buzzer_off>:
*
*/	
void buzzer_off(void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     5a6:	86 b1       	in	r24, 0x06	; 6
 port_restore = port_restore & 0xF7;
     5a8:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
     5aa:	88 b9       	out	0x08, r24	; 8
}
     5ac:	08 95       	ret

000005ae <Sharp_GP2D12_estimation>:
* Logic: Reads non converted value as parameter and returns converted value so as for easy manipulation and apllication.
* Example Call: Sharp_GP2D12_estimation()
*
*/	
unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
     5ae:	0f 93       	push	r16
     5b0:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
     5b2:	68 2f       	mov	r22, r24
     5b4:	70 e0       	ldi	r23, 0x00	; 0
     5b6:	80 e0       	ldi	r24, 0x00	; 0
     5b8:	90 e0       	ldi	r25, 0x00	; 0
     5ba:	0e 94 87 1c 	call	0x390e	; 0x390e <__floatunsisf>
     5be:	2f ee       	ldi	r18, 0xEF	; 239
     5c0:	39 ec       	ldi	r19, 0xC9	; 201
     5c2:	43 e9       	ldi	r20, 0x93	; 147
     5c4:	5f e3       	ldi	r21, 0x3F	; 63
     5c6:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <pow>
     5ca:	b6 2f       	mov	r27, r22
     5cc:	a7 2f       	mov	r26, r23
     5ce:	38 2f       	mov	r19, r24
     5d0:	29 2f       	mov	r18, r25
     5d2:	60 e0       	ldi	r22, 0x00	; 0
     5d4:	70 e0       	ldi	r23, 0x00	; 0
     5d6:	80 e8       	ldi	r24, 0x80	; 128
     5d8:	9f e3       	ldi	r25, 0x3F	; 63
     5da:	42 2f       	mov	r20, r18
     5dc:	0b 2f       	mov	r16, r27
     5de:	1a 2f       	mov	r17, r26
     5e0:	23 2f       	mov	r18, r19
     5e2:	34 2f       	mov	r19, r20
     5e4:	a9 01       	movw	r20, r18
     5e6:	98 01       	movw	r18, r16
     5e8:	0e 94 ee 1b 	call	0x37dc	; 0x37dc <__divsf3>
     5ec:	2a e9       	ldi	r18, 0x9A	; 154
     5ee:	39 ef       	ldi	r19, 0xF9	; 249
     5f0:	4e e2       	ldi	r20, 0x2E	; 46
     5f2:	55 e4       	ldi	r21, 0x45	; 69
     5f4:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <__mulsf3>
     5f8:	20 e0       	ldi	r18, 0x00	; 0
     5fa:	30 e0       	ldi	r19, 0x00	; 0
     5fc:	40 e2       	ldi	r20, 0x20	; 32
     5fe:	51 e4       	ldi	r21, 0x41	; 65
     600:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <__mulsf3>
     604:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__fixsfsi>
     608:	88 27       	eor	r24, r24
     60a:	77 fd       	sbrc	r23, 7
     60c:	80 95       	com	r24
     60e:	98 2f       	mov	r25, r24
     610:	0e 94 89 1c 	call	0x3912	; 0x3912 <__floatsisf>
	distanceInt = (int)distance;
     614:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
     618:	86 2f       	mov	r24, r22
     61a:	97 2f       	mov	r25, r23
     61c:	23 e0       	ldi	r18, 0x03	; 3
     61e:	81 32       	cpi	r24, 0x21	; 33
     620:	92 07       	cpc	r25, r18
     622:	10 f0       	brcs	.+4      	; 0x628 <Sharp_GP2D12_estimation+0x7a>
     624:	80 e2       	ldi	r24, 0x20	; 32
     626:	93 e0       	ldi	r25, 0x03	; 3
}
     628:	1f 91       	pop	r17
     62a:	0f 91       	pop	r16
     62c:	08 95       	ret

0000062e <adc_init>:
* Example Call: adc_init();
*
*/	
void adc_init(void)
{
	ADCSRA = 0x00;
     62e:	ea e7       	ldi	r30, 0x7A	; 122
     630:	f0 e0       	ldi	r31, 0x00	; 0
     632:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     634:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     638:	80 e2       	ldi	r24, 0x20	; 32
     63a:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     63e:	80 e8       	ldi	r24, 0x80	; 128
     640:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     642:	86 e8       	ldi	r24, 0x86	; 134
     644:	80 83       	st	Z, r24
}
     646:	08 95       	ret

00000648 <ADC_Conversion>:
*/
//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	if(Ch>7)
     648:	88 30       	cpi	r24, 0x08	; 8
     64a:	18 f0       	brcs	.+6      	; 0x652 <ADC_Conversion+0xa>
	{
		ADCSRB = 0x08;
     64c:	98 e0       	ldi	r25, 0x08	; 8
     64e:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;
     652:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;
     654:	80 62       	ori	r24, 0x20	; 32
     656:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     65a:	ea e7       	ldi	r30, 0x7A	; 122
     65c:	f0 e0       	ldi	r31, 0x00	; 0
     65e:	80 81       	ld	r24, Z
     660:	80 64       	ori	r24, 0x40	; 64
     662:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
     664:	80 81       	ld	r24, Z
     666:	84 ff       	sbrs	r24, 4
     668:	fd cf       	rjmp	.-6      	; 0x664 <ADC_Conversion+0x1c>
	a=ADCH;
     66a:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     66e:	ea e7       	ldi	r30, 0x7A	; 122
     670:	f0 e0       	ldi	r31, 0x00	; 0
     672:	90 81       	ld	r25, Z
     674:	90 61       	ori	r25, 0x10	; 16
     676:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     678:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     67c:	08 95       	ret

0000067e <print_sensor>:
* Logic: This function prints the function needed to be displayed on the LCD.
* Example Call: print_sensor(1,1,7);
*
*/	
void print_sensor(char row, char coloumn,unsigned char channel)
{
     67e:	cf 93       	push	r28
     680:	df 93       	push	r29
     682:	d8 2f       	mov	r29, r24
     684:	c6 2f       	mov	r28, r22
     686:	84 2f       	mov	r24, r20
	ADC_Value = ADC_Conversion(channel);
     688:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
     68c:	48 2f       	mov	r20, r24
     68e:	80 93 66 02 	sts	0x0266, r24
	lcd_print(row, coloumn, ADC_Value, 3);
     692:	8d 2f       	mov	r24, r29
     694:	6c 2f       	mov	r22, r28
     696:	50 e0       	ldi	r21, 0x00	; 0
     698:	23 e0       	ldi	r18, 0x03	; 3
     69a:	30 e0       	ldi	r19, 0x00	; 0
     69c:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
}
     6a0:	df 91       	pop	r29
     6a2:	cf 91       	pop	r28
     6a4:	08 95       	ret

000006a6 <left_encoder_pin_config>:
*
*/	
//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{ 
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     6a6:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     6a8:	74 9a       	sbi	0x0e, 4	; 14
}
     6aa:	08 95       	ret

000006ac <right_encoder_pin_config>:
*
*/	
//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     6ac:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     6ae:	75 9a       	sbi	0x0e, 5	; 14
}
     6b0:	08 95       	ret

000006b2 <buzzer_pin_config>:
* Example Call: buzzer_pin_config();
*
*/	
void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as outpt
     6b2:	3b 9a       	sbi	0x07, 3	; 7
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     6b4:	43 98       	cbi	0x08, 3	; 8
}
     6b6:	08 95       	ret

000006b8 <lcd_port_config>:
* Example Call: lcd_port_config();
*
*/	
void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
     6b8:	87 b1       	in	r24, 0x07	; 7
     6ba:	87 6f       	ori	r24, 0xF7	; 247
     6bc:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
     6be:	88 b1       	in	r24, 0x08	; 8
     6c0:	80 78       	andi	r24, 0x80	; 128
     6c2:	88 b9       	out	0x08, r24	; 8
}
     6c4:	08 95       	ret

000006c6 <MOSFET_switch_config>:
* Example Call: MOSFET_switch_config();
*
*/	
void MOSFET_switch_config (void)
{
	DDRH = DDRH | 0x0C; //make PORTH 3 and PORTH 1 pins as output
     6c6:	e1 e0       	ldi	r30, 0x01	; 1
     6c8:	f1 e0       	ldi	r31, 0x01	; 1
     6ca:	80 81       	ld	r24, Z
     6cc:	8c 60       	ori	r24, 0x0C	; 12
     6ce:	80 83       	st	Z, r24
	PORTH = PORTH & 0xF3; //set PORTH 3 and PORTH 1 pins to 0
     6d0:	e2 e0       	ldi	r30, 0x02	; 2
     6d2:	f1 e0       	ldi	r31, 0x01	; 1
     6d4:	80 81       	ld	r24, Z
     6d6:	83 7f       	andi	r24, 0xF3	; 243
     6d8:	80 83       	st	Z, r24

	DDRG = DDRG | 0x04; //make PORTG 2 pin as output
     6da:	9a 9a       	sbi	0x13, 2	; 19
	PORTG = PORTG & 0xFB; //set PORTG 2 pin to 0
     6dc:	a2 98       	cbi	0x14, 2	; 20
}
     6de:	08 95       	ret

000006e0 <port_init>:
* Example Call: port_init();
*
*/	
//Function to initialize ports
void port_init()
{	buzzer_pin_config();// for buzzer
     6e0:	0e 94 59 03 	call	0x6b2	; 0x6b2 <buzzer_pin_config>
	lcd_port_config();// for lCD
     6e4:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <lcd_port_config>
	motion_pin_config(); //robot motion pins config
     6e8:	0e 94 74 02 	call	0x4e8	; 0x4e8 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
     6ec:	0e 94 53 03 	call	0x6a6	; 0x6a6 <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
     6f0:	0e 94 56 03 	call	0x6ac	; 0x6ac <right_encoder_pin_config>
	adc_pin_config();
     6f4:	0e 94 85 02 	call	0x50a	; 0x50a <adc_pin_config>
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
     6f8:	0e 94 6e 02 	call	0x4dc	; 0x4dc <servo1_pin_config>
	servo2_pin_config(); //Configure PORTB 6 pin for servo motor 2 operation
     6fc:	0e 94 71 02 	call	0x4e2	; 0x4e2 <servo2_pin_config>
	
	MOSFET_switch_config();
     700:	0e 94 63 03 	call	0x6c6	; 0x6c6 <MOSFET_switch_config>
}
     704:	08 95       	ret

00000706 <left_position_encoder_interrupt_init>:
* Example Call: left_position_encoder_interrupt_init();
*
*/	
void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
     706:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     708:	ea e6       	ldi	r30, 0x6A	; 106
     70a:	f0 e0       	ldi	r31, 0x00	; 0
     70c:	80 81       	ld	r24, Z
     70e:	82 60       	ori	r24, 0x02	; 2
     710:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     712:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     714:	78 94       	sei
}
     716:	08 95       	ret

00000718 <right_position_encoder_interrupt_init>:
* Example Call: right_position_encoder_interrupt_init();
*
*/	
void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
     718:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     71a:	ea e6       	ldi	r30, 0x6A	; 106
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	80 81       	ld	r24, Z
     720:	88 60       	ori	r24, 0x08	; 8
     722:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     724:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
     726:	78 94       	sei
}
     728:	08 95       	ret

0000072a <__vector_6>:
* Logic: Gets called whenever position encoder counts increment on right motor.
*
*/	
//ISR for right position encoder
ISR(INT5_vect)
{
     72a:	1f 92       	push	r1
     72c:	0f 92       	push	r0
     72e:	0f b6       	in	r0, 0x3f	; 63
     730:	0f 92       	push	r0
     732:	11 24       	eor	r1, r1
     734:	8f 93       	push	r24
     736:	9f 93       	push	r25
     738:	af 93       	push	r26
     73a:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     73c:	80 91 52 02 	lds	r24, 0x0252
     740:	90 91 53 02 	lds	r25, 0x0253
     744:	a0 91 54 02 	lds	r26, 0x0254
     748:	b0 91 55 02 	lds	r27, 0x0255
     74c:	01 96       	adiw	r24, 0x01	; 1
     74e:	a1 1d       	adc	r26, r1
     750:	b1 1d       	adc	r27, r1
     752:	80 93 52 02 	sts	0x0252, r24
     756:	90 93 53 02 	sts	0x0253, r25
     75a:	a0 93 54 02 	sts	0x0254, r26
     75e:	b0 93 55 02 	sts	0x0255, r27
}
     762:	bf 91       	pop	r27
     764:	af 91       	pop	r26
     766:	9f 91       	pop	r25
     768:	8f 91       	pop	r24
     76a:	0f 90       	pop	r0
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	0f 90       	pop	r0
     770:	1f 90       	pop	r1
     772:	18 95       	reti

00000774 <__vector_5>:
* Example Call: <Example of how to call this function>
*
*/	
//ISR for left position encoder
ISR(INT4_vect)
{
     774:	1f 92       	push	r1
     776:	0f 92       	push	r0
     778:	0f b6       	in	r0, 0x3f	; 63
     77a:	0f 92       	push	r0
     77c:	11 24       	eor	r1, r1
     77e:	8f 93       	push	r24
     780:	9f 93       	push	r25
     782:	af 93       	push	r26
     784:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     786:	80 91 56 02 	lds	r24, 0x0256
     78a:	90 91 57 02 	lds	r25, 0x0257
     78e:	a0 91 58 02 	lds	r26, 0x0258
     792:	b0 91 59 02 	lds	r27, 0x0259
     796:	01 96       	adiw	r24, 0x01	; 1
     798:	a1 1d       	adc	r26, r1
     79a:	b1 1d       	adc	r27, r1
     79c:	80 93 56 02 	sts	0x0256, r24
     7a0:	90 93 57 02 	sts	0x0257, r25
     7a4:	a0 93 58 02 	sts	0x0258, r26
     7a8:	b0 93 59 02 	sts	0x0259, r27
}
     7ac:	bf 91       	pop	r27
     7ae:	af 91       	pop	r26
     7b0:	9f 91       	pop	r25
     7b2:	8f 91       	pop	r24
     7b4:	0f 90       	pop	r0
     7b6:	0f be       	out	0x3f, r0	; 63
     7b8:	0f 90       	pop	r0
     7ba:	1f 90       	pop	r1
     7bc:	18 95       	reti

000007be <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
	PortARestore = PORTA; 		// reading the PORTA original status
     7be:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     7c0:	90 7f       	andi	r25, 0xF0	; 240

void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
     7c2:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 		// reading the PORTA original status
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
	PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     7c4:	98 2b       	or	r25, r24
	PORTA = PortARestore; 		// executing the command
     7c6:	92 b9       	out	0x02, r25	; 2
}
     7c8:	08 95       	ret

000007ca <init_devices>:
* Example Call: init_devices();
*/	

void init_devices()
{
	cli(); //Clears the global interrupt
     7ca:	f8 94       	cli
	port_init();  //Initializes all the ports
     7cc:	0e 94 70 03 	call	0x6e0	; 0x6e0 <port_init>
	timer5_init();
     7d0:	0e 94 91 02 	call	0x522	; 0x522 <timer5_init>
	timer1_init();
     7d4:	0e 94 ac 02 	call	0x558	; 0x558 <timer1_init>
	adc_init();
     7d8:	0e 94 17 03 	call	0x62e	; 0x62e <adc_init>
	left_position_encoder_interrupt_init();
     7dc:	0e 94 83 03 	call	0x706	; 0x706 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     7e0:	0e 94 8c 03 	call	0x718	; 0x718 <right_position_encoder_interrupt_init>
	sei();   // Enables the global interrupt
     7e4:	78 94       	sei
}
     7e6:	08 95       	ret

000007e8 <turn_on_sharp234_wl>:
* Example Call: turn_on_sharp234_wl();
*
*/	
void turn_on_sharp234_wl (void)
{
	PORTG = PORTG & 0xFB;
     7e8:	a2 98       	cbi	0x14, 2	; 20
}
     7ea:	08 95       	ret

000007ec <turn_off_sharp234_wl>:
* Example Call: turn_off_sharp234_wl
*
*/	
void turn_off_sharp234_wl (void) //turn off Sharp IR range sensors 2, 3, 4 and white line sensor's red LED
{
	PORTG = PORTG | 0x04;
     7ec:	a2 9a       	sbi	0x14, 2	; 20
}
     7ee:	08 95       	ret

000007f0 <turn_on_sharp15>:
* Example Call: turn_on_sharp15();
*
*/	
void turn_on_sharp15 (void) 
{
	PORTH = PORTH & 0xFB;
     7f0:	e2 e0       	ldi	r30, 0x02	; 2
     7f2:	f1 e0       	ldi	r31, 0x01	; 1
     7f4:	80 81       	ld	r24, Z
     7f6:	8b 7f       	andi	r24, 0xFB	; 251
     7f8:	80 83       	st	Z, r24
}
     7fa:	08 95       	ret

000007fc <turn_off_sharp15>:
* Example Call: turn_off_sharp15();
*
*/	
void turn_off_sharp15 (void) //turn off Sharp IR range sensors 1,5
{
	PORTH = PORTH | 0x04;
     7fc:	e2 e0       	ldi	r30, 0x02	; 2
     7fe:	f1 e0       	ldi	r31, 0x01	; 1
     800:	80 81       	ld	r24, Z
     802:	84 60       	ori	r24, 0x04	; 4
     804:	80 83       	st	Z, r24
}
     806:	08 95       	ret

00000808 <turn_on_ir_proxi_sensors>:
* Example Call: turn_on_ir_proxi_sensors();
*
*/	
void turn_on_ir_proxi_sensors (void) //turn on IR Proximity sensors
{
	PORTH = PORTH & 0xF7;
     808:	e2 e0       	ldi	r30, 0x02	; 2
     80a:	f1 e0       	ldi	r31, 0x01	; 1
     80c:	80 81       	ld	r24, Z
     80e:	87 7f       	andi	r24, 0xF7	; 247
     810:	80 83       	st	Z, r24
}
     812:	08 95       	ret

00000814 <turn_off_ir_proxi_sensors>:
* Example Call: turn_off_ir_proxi_sensors();
*
*/	
void turn_off_ir_proxi_sensors (void) //turn off IR Proximity sensors
{
	PORTH = PORTH | 0x08;
     814:	e2 e0       	ldi	r30, 0x02	; 2
     816:	f1 e0       	ldi	r31, 0x01	; 1
     818:	80 81       	ld	r24, Z
     81a:	88 60       	ori	r24, 0x08	; 8
     81c:	80 83       	st	Z, r24
}
     81e:	08 95       	ret

00000820 <turn_on_all_proxy_sensors>:
*
*/	
void turn_on_all_proxy_sensors (void) // turn on Sharp 2, 3, 4, red LED of the white line sensors
// Sharp 1, 5 and IR proximity sensor
{
	PORTH = PORTH & 0xF3; //set PORTH 3 and PORTH 1 pins to 0
     820:	e2 e0       	ldi	r30, 0x02	; 2
     822:	f1 e0       	ldi	r31, 0x01	; 1
     824:	80 81       	ld	r24, Z
     826:	83 7f       	andi	r24, 0xF3	; 243
     828:	80 83       	st	Z, r24
	PORTG = PORTG & 0xFB; //set PORTG 2 pin to 0
     82a:	a2 98       	cbi	0x14, 2	; 20
}
     82c:	08 95       	ret

0000082e <servo_1>:
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     82e:	10 92 89 00 	sts	0x0089, r1
*/	
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
     832:	68 2f       	mov	r22, r24
     834:	70 e0       	ldi	r23, 0x00	; 0
     836:	80 e0       	ldi	r24, 0x00	; 0
     838:	90 e0       	ldi	r25, 0x00	; 0
     83a:	0e 94 87 1c 	call	0x390e	; 0x390e <__floatunsisf>
     83e:	2b e7       	ldi	r18, 0x7B	; 123
     840:	34 e1       	ldi	r19, 0x14	; 20
     842:	4e ee       	ldi	r20, 0xEE	; 238
     844:	5f e3       	ldi	r21, 0x3F	; 63
     846:	0e 94 ee 1b 	call	0x37dc	; 0x37dc <__divsf3>
     84a:	20 e0       	ldi	r18, 0x00	; 0
     84c:	30 e0       	ldi	r19, 0x00	; 0
     84e:	4c e0       	ldi	r20, 0x0C	; 12
     850:	52 e4       	ldi	r21, 0x42	; 66
     852:	0e 94 8a 1b 	call	0x3714	; 0x3714 <__addsf3>
	OCR1AH = 0x00;
	OCR1AL = (unsigned char) PositionPanServo;
     856:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <__fixunssfsi>
     85a:	60 93 88 00 	sts	0x0088, r22
}
     85e:	08 95       	ret

00000860 <servo_2>:
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     860:	10 92 8b 00 	sts	0x008B, r1
*/	
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
     864:	68 2f       	mov	r22, r24
     866:	70 e0       	ldi	r23, 0x00	; 0
     868:	80 e0       	ldi	r24, 0x00	; 0
     86a:	90 e0       	ldi	r25, 0x00	; 0
     86c:	0e 94 87 1c 	call	0x390e	; 0x390e <__floatunsisf>
     870:	2b e7       	ldi	r18, 0x7B	; 123
     872:	34 e1       	ldi	r19, 0x14	; 20
     874:	4e ee       	ldi	r20, 0xEE	; 238
     876:	5f e3       	ldi	r21, 0x3F	; 63
     878:	0e 94 ee 1b 	call	0x37dc	; 0x37dc <__divsf3>
     87c:	20 e0       	ldi	r18, 0x00	; 0
     87e:	30 e0       	ldi	r19, 0x00	; 0
     880:	4c e0       	ldi	r20, 0x0C	; 12
     882:	52 e4       	ldi	r21, 0x42	; 66
     884:	0e 94 8a 1b 	call	0x3714	; 0x3714 <__addsf3>
	OCR1BH = 0x00;
	OCR1BL = (unsigned char) PositionTiltServo;
     888:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <__fixunssfsi>
     88c:	60 93 8a 00 	sts	0x008A, r22
}
     890:	08 95       	ret

00000892 <servo_1_free>:
* Example Call: servo_1_free();
*
*/	
void servo_1_free (void) //makes servo 1 free rotating
{
	OCR1AH = 0x03;
     892:	83 e0       	ldi	r24, 0x03	; 3
     894:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = 0xFF; //Servo 1 off
     898:	8f ef       	ldi	r24, 0xFF	; 255
     89a:	80 93 88 00 	sts	0x0088, r24
}
     89e:	08 95       	ret

000008a0 <servo_2_free>:
* Example Call: servo_2_free();
*
*/	
void servo_2_free (void) //makes servo 2 free rotating
{
	OCR1BH = 0x03;
     8a0:	83 e0       	ldi	r24, 0x03	; 3
     8a2:	80 93 8b 00 	sts	0x008B, r24
	OCR1BL = 0xFF; //Servo 2 off
     8a6:	8f ef       	ldi	r24, 0xFF	; 255
     8a8:	80 93 8a 00 	sts	0x008A, r24
}
     8ac:	08 95       	ret

000008ae <forward>:
* Example Call: forward();
*
*/	
void forward (void) //both wheels forward
{
	motion_set(0x06);
     8ae:	86 e0       	ldi	r24, 0x06	; 6
     8b0:	0e 94 df 03 	call	0x7be	; 0x7be <motion_set>
}
     8b4:	08 95       	ret

000008b6 <back>:
* Example Call: back();
*
*/	
void back (void) //both wheels backward
{
	motion_set(0x09);
     8b6:	89 e0       	ldi	r24, 0x09	; 9
     8b8:	0e 94 df 03 	call	0x7be	; 0x7be <motion_set>
}
     8bc:	08 95       	ret

000008be <left>:
* Example Call: left();
*
*/	
void left(void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
     8be:	85 e0       	ldi	r24, 0x05	; 5
     8c0:	0e 94 df 03 	call	0x7be	; 0x7be <motion_set>
}
     8c4:	08 95       	ret

000008c6 <right>:
			Right	 	1		0		1 		0
* Example Call: right();
*/	
void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
     8c6:	8a e0       	ldi	r24, 0x0A	; 10
     8c8:	0e 94 df 03 	call	0x7be	; 0x7be <motion_set>
}
     8cc:	08 95       	ret

000008ce <stop>:
* Example Call: stop();
*
*/	
void stop (void)
{
	motion_set(0x00);
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	0e 94 df 03 	call	0x7be	; 0x7be <motion_set>
}
     8d4:	08 95       	ret

000008d6 <linear_distance_mm>:

void linear_distance_mm(unsigned int DistanceInMM)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;
	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
     8d6:	bc 01       	movw	r22, r24
     8d8:	80 e0       	ldi	r24, 0x00	; 0
     8da:	90 e0       	ldi	r25, 0x00	; 0
     8dc:	0e 94 87 1c 	call	0x390e	; 0x390e <__floatunsisf>
     8e0:	25 ee       	ldi	r18, 0xE5	; 229
     8e2:	30 ed       	ldi	r19, 0xD0	; 208
     8e4:	4a ea       	ldi	r20, 0xAA	; 170
     8e6:	50 e4       	ldi	r21, 0x40	; 64
     8e8:	0e 94 ee 1b 	call	0x37dc	; 0x37dc <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     8ec:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <__fixunssfsi>
     8f0:	46 2f       	mov	r20, r22
     8f2:	57 2f       	mov	r21, r23
     8f4:	68 2f       	mov	r22, r24
     8f6:	79 2f       	mov	r23, r25
	
	ShaftCountRight = 0;
     8f8:	10 92 52 02 	sts	0x0252, r1
     8fc:	10 92 53 02 	sts	0x0253, r1
     900:	10 92 54 02 	sts	0x0254, r1
     904:	10 92 55 02 	sts	0x0255, r1
	while(1)
	{
		if(ShaftCountRight > ReqdShaftCountInt)
     908:	80 91 52 02 	lds	r24, 0x0252
     90c:	90 91 53 02 	lds	r25, 0x0253
     910:	a0 91 54 02 	lds	r26, 0x0254
     914:	b0 91 55 02 	lds	r27, 0x0255
     918:	48 17       	cp	r20, r24
     91a:	59 07       	cpc	r21, r25
     91c:	6a 07       	cpc	r22, r26
     91e:	7b 07       	cpc	r23, r27
     920:	98 f7       	brcc	.-26     	; 0x908 <linear_distance_mm+0x32>
		{
			break;
		}
	}
	stop(); //Stop robot
     922:	0e 94 67 04 	call	0x8ce	; 0x8ce <stop>
}
     926:	08 95       	ret

00000928 <angle_rotate>:
*				angle_rotate(90);
*				//Turns left by 90 degrees
*
*/	
void angle_rotate(unsigned int Degrees)
{
     928:	0f 93       	push	r16
     92a:	1f 93       	push	r17
     92c:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     92e:	bc 01       	movw	r22, r24
     930:	80 e0       	ldi	r24, 0x00	; 0
     932:	90 e0       	ldi	r25, 0x00	; 0
     934:	0e 94 87 1c 	call	0x390e	; 0x390e <__floatunsisf>
     938:	28 e4       	ldi	r18, 0x48	; 72
     93a:	31 ee       	ldi	r19, 0xE1	; 225
     93c:	42 e8       	ldi	r20, 0x82	; 130
     93e:	50 e4       	ldi	r21, 0x40	; 64
     940:	0e 94 ee 1b 	call	0x37dc	; 0x37dc <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     944:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <__fixunssfsi>
     948:	dc 01       	movw	r26, r24
     94a:	cb 01       	movw	r24, r22
     94c:	a0 e0       	ldi	r26, 0x00	; 0
     94e:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     950:	10 92 52 02 	sts	0x0252, r1
     954:	10 92 53 02 	sts	0x0253, r1
     958:	10 92 54 02 	sts	0x0254, r1
     95c:	10 92 55 02 	sts	0x0255, r1
	ShaftCountLeft = 0;
     960:	10 92 56 02 	sts	0x0256, r1
     964:	10 92 57 02 	sts	0x0257, r1
     968:	10 92 58 02 	sts	0x0258, r1
     96c:	10 92 59 02 	sts	0x0259, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     970:	f1 e0       	ldi	r31, 0x01	; 1
     972:	c0 e0       	ldi	r28, 0x00	; 0
     974:	40 91 52 02 	lds	r20, 0x0252
     978:	50 91 53 02 	lds	r21, 0x0253
     97c:	60 91 54 02 	lds	r22, 0x0254
     980:	70 91 55 02 	lds	r23, 0x0255
     984:	00 91 56 02 	lds	r16, 0x0256
     988:	10 91 57 02 	lds	r17, 0x0257
     98c:	20 91 58 02 	lds	r18, 0x0258
     990:	30 91 59 02 	lds	r19, 0x0259
     994:	ef 2f       	mov	r30, r31
     996:	48 17       	cp	r20, r24
     998:	59 07       	cpc	r21, r25
     99a:	6a 07       	cpc	r22, r26
     99c:	7b 07       	cpc	r23, r27
     99e:	08 f4       	brcc	.+2      	; 0x9a2 <angle_rotate+0x7a>
     9a0:	ec 2f       	mov	r30, r28
     9a2:	ee 23       	and	r30, r30
     9a4:	49 f4       	brne	.+18     	; 0x9b8 <angle_rotate+0x90>
     9a6:	4f 2f       	mov	r20, r31
     9a8:	08 17       	cp	r16, r24
     9aa:	19 07       	cpc	r17, r25
     9ac:	2a 07       	cpc	r18, r26
     9ae:	3b 07       	cpc	r19, r27
     9b0:	08 f4       	brcc	.+2      	; 0x9b4 <angle_rotate+0x8c>
     9b2:	4c 2f       	mov	r20, r28
     9b4:	44 23       	and	r20, r20
     9b6:	f1 f2       	breq	.-68     	; 0x974 <angle_rotate+0x4c>
		break;
	}
	stop(); //Stop robot
     9b8:	0e 94 67 04 	call	0x8ce	; 0x8ce <stop>
}
     9bc:	cf 91       	pop	r28
     9be:	1f 91       	pop	r17
     9c0:	0f 91       	pop	r16
     9c2:	08 95       	ret

000009c4 <forward_mm>:
* Logic: Goes forward by the distance specified using position encoders.
* Example Call: forward_mm(200) // Goes forward by 200 millimeters.
*
*/	
void forward_mm(unsigned int DistanceInMM)
{
     9c4:	cf 93       	push	r28
     9c6:	df 93       	push	r29
     9c8:	ec 01       	movw	r28, r24
	forward();
     9ca:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
	velocity(205,200);
     9ce:	8d ec       	ldi	r24, 0xCD	; 205
     9d0:	68 ec       	ldi	r22, 0xC8	; 200
     9d2:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
	linear_distance_mm(DistanceInMM);
     9d6:	ce 01       	movw	r24, r28
     9d8:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <linear_distance_mm>
	CurPos(DistanceInMM/200,0,0,0);
     9dc:	ce 01       	movw	r24, r28
     9de:	68 ec       	ldi	r22, 0xC8	; 200
     9e0:	70 e0       	ldi	r23, 0x00	; 0
     9e2:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     9e6:	cb 01       	movw	r24, r22
     9e8:	60 e0       	ldi	r22, 0x00	; 0
     9ea:	70 e0       	ldi	r23, 0x00	; 0
     9ec:	40 e0       	ldi	r20, 0x00	; 0
     9ee:	50 e0       	ldi	r21, 0x00	; 0
     9f0:	20 e0       	ldi	r18, 0x00	; 0
     9f2:	30 e0       	ldi	r19, 0x00	; 0
     9f4:	0e 94 3a 02 	call	0x474	; 0x474 <CurPos>
}
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	08 95       	ret

000009fe <back_mm>:
* Logic: Goes forward by the distance specified using position encoders.
* Example Call: back_mm(200) // Goes backward by 200 millimeters.
*
*/	
void back_mm(unsigned int DistanceInMM)
{
     9fe:	cf 93       	push	r28
     a00:	df 93       	push	r29
     a02:	ec 01       	movw	r28, r24
	back();
     a04:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <back>
	linear_distance_mm(DistanceInMM);
     a08:	ce 01       	movw	r24, r28
     a0a:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <linear_distance_mm>
	CurPos(0,DistanceInMM/200,0,0);
     a0e:	ce 01       	movw	r24, r28
     a10:	68 ec       	ldi	r22, 0xC8	; 200
     a12:	70 e0       	ldi	r23, 0x00	; 0
     a14:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <__udivmodhi4>
     a18:	80 e0       	ldi	r24, 0x00	; 0
     a1a:	90 e0       	ldi	r25, 0x00	; 0
     a1c:	40 e0       	ldi	r20, 0x00	; 0
     a1e:	50 e0       	ldi	r21, 0x00	; 0
     a20:	20 e0       	ldi	r18, 0x00	; 0
     a22:	30 e0       	ldi	r19, 0x00	; 0
     a24:	0e 94 3a 02 	call	0x474	; 0x474 <CurPos>
}
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	08 95       	ret

00000a2e <left_degrees>:
* Logic: Rotates left (Takes a hard-left turn) by the specified number of degrees using position encoders.
* Example Call: left_degrees(45); //Rotates left by 45 degrees
*
*/	
void left_degrees(unsigned int Degrees)
{
     a2e:	cf 93       	push	r28
     a30:	df 93       	push	r29
     a32:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
     a34:	0e 94 5f 04 	call	0x8be	; 0x8be <left>
	velocity(205,200);
     a38:	8d ec       	ldi	r24, 0xCD	; 205
     a3a:	68 ec       	ldi	r22, 0xC8	; 200
     a3c:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
	angle_rotate(Degrees);
     a40:	ce 01       	movw	r24, r28
     a42:	0e 94 94 04 	call	0x928	; 0x928 <angle_rotate>
}
     a46:	df 91       	pop	r29
     a48:	cf 91       	pop	r28
     a4a:	08 95       	ret

00000a4c <right_degrees>:
* Logic: Rotates right  (Takes a hard-right turn) by the specified number of degrees using position encoders.
* Example Call: right_degrees(45); //Rotates left by 45 degrees
*
*/	
void right_degrees(unsigned int Degrees)
{
     a4c:	cf 93       	push	r28
     a4e:	df 93       	push	r29
     a50:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right(); //Turn right
     a52:	0e 94 63 04 	call	0x8c6	; 0x8c6 <right>
	velocity(205,200);
     a56:	8d ec       	ldi	r24, 0xCD	; 205
     a58:	68 ec       	ldi	r22, 0xC8	; 200
     a5a:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
	angle_rotate(Degrees);
     a5e:	ce 01       	movw	r24, r28
     a60:	0e 94 94 04 	call	0x928	; 0x928 <angle_rotate>
}
     a64:	df 91       	pop	r29
     a66:	cf 91       	pop	r28
     a68:	08 95       	ret

00000a6a <Sensor>:
* Example Call: Sensor(10);
*
*/	

void Sensor(unsigned char a)
{
     a6a:	cf 93       	push	r28
     a6c:	c8 2f       	mov	r28, r24
	unsigned char value;
	Sensor_read = ADC_Conversion(a);
     a6e:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
     a72:	80 93 69 02 	sts	0x0269, r24
	value = Sharp_GP2D12_estimation(Sensor_read);				//Stores Distance calculated in a variable "value".
     a76:	80 91 69 02 	lds	r24, 0x0269
     a7a:	0e 94 d7 02 	call	0x5ae	; 0x5ae <Sharp_GP2D12_estimation>
	uint8_t tmp=Cur_Pos[1]+1;
     a7e:	20 91 02 02 	lds	r18, 0x0202
     a82:	30 91 03 02 	lds	r19, 0x0203
     a86:	2f 5f       	subi	r18, 0xFF	; 255
	uint8_t tmp2=tmp+1;
	if(a==12)
     a88:	cc 30       	cpi	r28, 0x0C	; 12
     a8a:	91 f5       	brne	.+100    	; 0xaf0 <Sensor+0x86>
		}
		else if(550<value&&value<=600)	//Block two diagonals to the right, placed incorrectly.
		{
			Blk_Pos[tmp2][0]=1;
		}
		else if(150<value&&value<190)	//Block one diagonal to the left , placed incorrectly.
     a8c:	98 2f       	mov	r25, r24
     a8e:	97 59       	subi	r25, 0x97	; 151
     a90:	97 32       	cpi	r25, 0x27	; 39
     a92:	98 f4       	brcc	.+38     	; 0xaba <Sensor+0x50>
		{
			Blk_Pos[tmp][1]=1;
     a94:	82 2f       	mov	r24, r18
     a96:	90 e0       	ldi	r25, 0x00	; 0
     a98:	88 0f       	add	r24, r24
     a9a:	99 1f       	adc	r25, r25
     a9c:	fc 01       	movw	r30, r24
     a9e:	ee 0f       	add	r30, r30
     aa0:	ff 1f       	adc	r31, r31
     aa2:	ee 0f       	add	r30, r30
     aa4:	ff 1f       	adc	r31, r31
     aa6:	8e 0f       	add	r24, r30
     aa8:	9f 1f       	adc	r25, r31
     aaa:	fc 01       	movw	r30, r24
     aac:	e8 5f       	subi	r30, 0xF8	; 248
     aae:	fd 4f       	sbci	r31, 0xFD	; 253
     ab0:	81 e0       	ldi	r24, 0x01	; 1
     ab2:	90 e0       	ldi	r25, 0x00	; 0
     ab4:	93 83       	std	Z+3, r25	; 0x03
     ab6:	82 83       	std	Z+2, r24	; 0x02
     ab8:	4d c0       	rjmp	.+154    	; 0xb54 <Sensor+0xea>
		}
		else if(200<value&&value<240)	//Block one diagonal to the right, placed correctly.
     aba:	89 5c       	subi	r24, 0xC9	; 201
     abc:	87 32       	cpi	r24, 0x27	; 39
     abe:	08 f0       	brcs	.+2      	; 0xac2 <Sensor+0x58>
     ac0:	49 c0       	rjmp	.+146    	; 0xb54 <Sensor+0xea>
		{
			count1++;
     ac2:	80 91 06 02 	lds	r24, 0x0206
     ac6:	90 91 07 02 	lds	r25, 0x0207
     aca:	01 96       	adiw	r24, 0x01	; 1
     acc:	90 93 07 02 	sts	0x0207, r25
     ad0:	80 93 06 02 	sts	0x0206, r24
			buzzer_on();_delay_ms(500);buzzer_off();
     ad4:	0e 94 cf 02 	call	0x59e	; 0x59e <buzzer_on>
     ad8:	8f ef       	ldi	r24, 0xFF	; 255
     ada:	9f e7       	ldi	r25, 0x7F	; 127
     adc:	a6 e1       	ldi	r26, 0x16	; 22
     ade:	81 50       	subi	r24, 0x01	; 1
     ae0:	90 40       	sbci	r25, 0x00	; 0
     ae2:	a0 40       	sbci	r26, 0x00	; 0
     ae4:	e1 f7       	brne	.-8      	; 0xade <Sensor+0x74>
     ae6:	00 c0       	rjmp	.+0      	; 0xae8 <Sensor+0x7e>
     ae8:	00 00       	nop
     aea:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
     aee:	32 c0       	rjmp	.+100    	; 0xb54 <Sensor+0xea>
		}
	}
	else if(a==10)
     af0:	ca 30       	cpi	r28, 0x0A	; 10
     af2:	81 f5       	brne	.+96     	; 0xb54 <Sensor+0xea>
		else if(550<value&&value<=600)	//Block two diagonals to the left, placed correctly.
		{
			count1++;
			buzzer_on();_delay_ms(500);buzzer_off();
		}
		else if(150<value&&value<190)	//Block one diagonal to the left, placed correctly.
     af4:	98 2f       	mov	r25, r24
     af6:	97 59       	subi	r25, 0x97	; 151
     af8:	97 32       	cpi	r25, 0x27	; 39
     afa:	b8 f4       	brcc	.+46     	; 0xb2a <Sensor+0xc0>
		{
			count1++;
     afc:	80 91 06 02 	lds	r24, 0x0206
     b00:	90 91 07 02 	lds	r25, 0x0207
     b04:	01 96       	adiw	r24, 0x01	; 1
     b06:	90 93 07 02 	sts	0x0207, r25
     b0a:	80 93 06 02 	sts	0x0206, r24
			buzzer_on();_delay_ms(500);buzzer_off();
     b0e:	0e 94 cf 02 	call	0x59e	; 0x59e <buzzer_on>
     b12:	8f ef       	ldi	r24, 0xFF	; 255
     b14:	9f e7       	ldi	r25, 0x7F	; 127
     b16:	a6 e1       	ldi	r26, 0x16	; 22
     b18:	81 50       	subi	r24, 0x01	; 1
     b1a:	90 40       	sbci	r25, 0x00	; 0
     b1c:	a0 40       	sbci	r26, 0x00	; 0
     b1e:	e1 f7       	brne	.-8      	; 0xb18 <Sensor+0xae>
     b20:	00 c0       	rjmp	.+0      	; 0xb22 <Sensor+0xb8>
     b22:	00 00       	nop
     b24:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
     b28:	15 c0       	rjmp	.+42     	; 0xb54 <Sensor+0xea>
		}
		
		else if(200<value&&value<240)	//Block one diagonal to the left, placed incorrectly.
     b2a:	89 5c       	subi	r24, 0xC9	; 201
     b2c:	87 32       	cpi	r24, 0x27	; 39
     b2e:	90 f4       	brcc	.+36     	; 0xb54 <Sensor+0xea>
		{
			Blk_Pos[tmp][3]=1;
     b30:	82 2f       	mov	r24, r18
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	88 0f       	add	r24, r24
     b36:	99 1f       	adc	r25, r25
     b38:	fc 01       	movw	r30, r24
     b3a:	ee 0f       	add	r30, r30
     b3c:	ff 1f       	adc	r31, r31
     b3e:	ee 0f       	add	r30, r30
     b40:	ff 1f       	adc	r31, r31
     b42:	8e 0f       	add	r24, r30
     b44:	9f 1f       	adc	r25, r31
     b46:	fc 01       	movw	r30, r24
     b48:	e8 5f       	subi	r30, 0xF8	; 248
     b4a:	fd 4f       	sbci	r31, 0xFD	; 253
     b4c:	81 e0       	ldi	r24, 0x01	; 1
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	97 83       	std	Z+7, r25	; 0x07
     b52:	86 83       	std	Z+6, r24	; 0x06
		}
		
		
	}
	
}
     b54:	cf 91       	pop	r28
     b56:	08 95       	ret

00000b58 <Sharp_Detection>:
* Example Call: Sharp_Detection();
*
*/
void Sharp_Detection(void)
{
	Sensor(10);     //Calls SHARP IR with ADC conversion value 10, ie, sharp sensor placed at 45 degree to the left
     b58:	8a e0       	ldi	r24, 0x0A	; 10
     b5a:	0e 94 35 05 	call	0xa6a	; 0xa6a <Sensor>
	Sensor(12);		//Calls SHARP IR with ADC conversion value 12, ie., SHARP IR placed 45 degrees to the right
     b5e:	8c e0       	ldi	r24, 0x0C	; 12
     b60:	0e 94 35 05 	call	0xa6a	; 0xa6a <Sensor>
}
     b64:	08 95       	ret

00000b66 <forward_wls>:
* Example Call: forward_wlsD2(2) //Goes forward by two nodes
*
*/	

void forward_wls( unsigned char node)
{	
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	d8 2f       	mov	r29, r24
	unsigned char flagw=0;
     b6c:	c0 e0       	ldi	r28, 0x00	; 0
	while(1)
	{	
		

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     b6e:	83 e0       	ldi	r24, 0x03	; 3
     b70:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
     b74:	80 93 50 02 	sts	0x0250, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     b78:	82 e0       	ldi	r24, 0x02	; 2
     b7a:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
     b7e:	80 93 4f 02 	sts	0x024F, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     b82:	81 e0       	ldi	r24, 0x01	; 1
     b84:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
     b88:	80 93 4e 02 	sts	0x024E, r24
		
		forward();
     b8c:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
		velocity(225,230);
     b90:	81 ee       	ldi	r24, 0xE1	; 225
     b92:	66 ee       	ldi	r22, 0xE6	; 230
     b94:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
	//Function to detect node
		 
		if( ( Center_white_line >0x0C && Left_white_line >0x0C) || (  Right_white_line>0x0C && Left_white_line>0x0C) || (  Center_white_line>0x0C && Right_white_line>0x0C))
     b98:	80 91 4f 02 	lds	r24, 0x024F
     b9c:	8d 30       	cpi	r24, 0x0D	; 13
     b9e:	20 f4       	brcc	.+8      	; 0xba8 <forward_wls+0x42>
     ba0:	90 91 4e 02 	lds	r25, 0x024E
     ba4:	9d 30       	cpi	r25, 0x0D	; 13
     ba6:	78 f1       	brcs	.+94     	; 0xc06 <forward_wls+0xa0>
     ba8:	90 91 50 02 	lds	r25, 0x0250
     bac:	9d 30       	cpi	r25, 0x0D	; 13
     bae:	30 f4       	brcc	.+12     	; 0xbbc <forward_wls+0x56>
     bb0:	8d 30       	cpi	r24, 0x0D	; 13
     bb2:	48 f1       	brcs	.+82     	; 0xc06 <forward_wls+0xa0>
     bb4:	80 91 4e 02 	lds	r24, 0x024E
     bb8:	8d 30       	cpi	r24, 0x0D	; 13
     bba:	28 f1       	brcs	.+74     	; 0xc06 <forward_wls+0xa0>
		{		 velocity(0,0);
     bbc:	80 e0       	ldi	r24, 0x00	; 0
     bbe:	60 e0       	ldi	r22, 0x00	; 0
     bc0:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
			forward();
     bc4:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
     bc8:	8f ef       	ldi	r24, 0xFF	; 255
     bca:	9f ef       	ldi	r25, 0xFF	; 255
     bcc:	ac e2       	ldi	r26, 0x2C	; 44
     bce:	81 50       	subi	r24, 0x01	; 1
     bd0:	90 40       	sbci	r25, 0x00	; 0
     bd2:	a0 40       	sbci	r26, 0x00	; 0
     bd4:	e1 f7       	brne	.-8      	; 0xbce <forward_wls+0x68>
     bd6:	00 c0       	rjmp	.+0      	; 0xbd8 <forward_wls+0x72>
     bd8:	00 00       	nop
			_delay_ms(1000);
			flagw=flagw+1;	//			increments number of nodes detected by the robot.
     bda:	cf 5f       	subi	r28, 0xFF	; 255
			velocity(225,230);
     bdc:	81 ee       	ldi	r24, 0xE1	; 225
     bde:	66 ee       	ldi	r22, 0xE6	; 230
     be0:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
			forward_mm(30);
     be4:	8e e1       	ldi	r24, 0x1E	; 30
     be6:	90 e0       	ldi	r25, 0x00	; 0
     be8:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <forward_mm>
			stop();
     bec:	0e 94 67 04 	call	0x8ce	; 0x8ce <stop>
     bf0:	8f ef       	ldi	r24, 0xFF	; 255
     bf2:	9f e7       	ldi	r25, 0x7F	; 127
     bf4:	a6 e1       	ldi	r26, 0x16	; 22
     bf6:	81 50       	subi	r24, 0x01	; 1
     bf8:	90 40       	sbci	r25, 0x00	; 0
     bfa:	a0 40       	sbci	r26, 0x00	; 0
     bfc:	e1 f7       	brne	.-8      	; 0xbf6 <forward_wls+0x90>
     bfe:	00 c0       	rjmp	.+0      	; 0xc00 <forward_wls+0x9a>
     c00:	00 00       	nop
			_delay_ms(500);
				if (node==flagw)
     c02:	dc 17       	cp	r29, r28
     c04:	79 f1       	breq	.+94     	; 0xc64 <forward_wls+0xfe>
					break;				//stops line following if no. of nodes specified by user and detecetd by the robot is same 
				}
					
				
		}		
		if((Center_white_line>=0x0C) )				// goes forward if center white line detects reading more than "0X0C"
     c06:	80 91 4f 02 	lds	r24, 0x024F
     c0a:	8c 30       	cpi	r24, 0x0C	; 12
     c0c:	40 f0       	brcs	.+16     	; 0xc1e <forward_wls+0xb8>
		{
			buzzer_off();
     c0e:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
			forward();
     c12:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(225,230);
     c16:	81 ee       	ldi	r24, 0xE1	; 225
     c18:	66 ee       	ldi	r22, 0xE6	; 230
     c1a:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
		}

		if((Left_white_line>=0x0C))				// turns when lefts white line detects value more than 0x0C
     c1e:	80 91 50 02 	lds	r24, 0x0250
     c22:	8c 30       	cpi	r24, 0x0C	; 12
     c24:	40 f0       	brcs	.+16     	; 0xc36 <forward_wls+0xd0>
		{
			buzzer_off();
     c26:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
			forward();
     c2a:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(80,190);
     c2e:	80 e5       	ldi	r24, 0x50	; 80
     c30:	6e eb       	ldi	r22, 0xBE	; 190
     c32:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
		}

		if((Right_white_line>=0x0C) )				// turns when right white line detects value more than 0x0C
     c36:	80 91 4e 02 	lds	r24, 0x024E
     c3a:	8c 30       	cpi	r24, 0x0C	; 12
     c3c:	40 f0       	brcs	.+16     	; 0xc4e <forward_wls+0xe8>
		{
			buzzer_off();
     c3e:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
			forward();
     c42:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(190,80);
     c46:	8e eb       	ldi	r24, 0xBE	; 190
     c48:	60 e5       	ldi	r22, 0x50	; 80
     c4a:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
		}
	CurPos(node,0,0,0);
     c4e:	8d 2f       	mov	r24, r29
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	60 e0       	ldi	r22, 0x00	; 0
     c54:	70 e0       	ldi	r23, 0x00	; 0
     c56:	40 e0       	ldi	r20, 0x00	; 0
     c58:	50 e0       	ldi	r21, 0x00	; 0
     c5a:	20 e0       	ldi	r18, 0x00	; 0
     c5c:	30 e0       	ldi	r19, 0x00	; 0
     c5e:	0e 94 3a 02 	call	0x474	; 0x474 <CurPos>
	}
     c62:	85 cf       	rjmp	.-246    	; 0xb6e <forward_wls+0x8>
}
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	08 95       	ret

00000c6a <SharpSide>:
* Example Call: SharpSide();
*
*/	void SharpSide(void)
{
	unsigned char value2;
	Sensor_read = ADC_Conversion(12);
     c6a:	8c e0       	ldi	r24, 0x0C	; 12
     c6c:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
     c70:	80 93 69 02 	sts	0x0269, r24
	value2 = Sharp_GP2D12_estimation(Sensor_read);
     c74:	80 91 69 02 	lds	r24, 0x0269
     c78:	0e 94 d7 02 	call	0x5ae	; 0x5ae <Sharp_GP2D12_estimation>
		{
			Blk_Pos[Cur_Pos[1]+2][Cur_Pos[0]+2]=1;
			
		}
	}
	else if(200<value2&&value2<240)
     c7c:	98 2f       	mov	r25, r24
     c7e:	99 5c       	subi	r25, 0xC9	; 201
     c80:	97 32       	cpi	r25, 0x27	; 39
     c82:	a0 f5       	brcc	.+104    	; 0xcec <SharpSide+0x82>
	{
			Blk_Pos[Cur_Pos[1]+1][Cur_Pos[0]+1]=2 ;
     c84:	80 91 02 02 	lds	r24, 0x0202
     c88:	90 91 03 02 	lds	r25, 0x0203
     c8c:	01 96       	adiw	r24, 0x01	; 1
     c8e:	20 91 00 02 	lds	r18, 0x0200
     c92:	30 91 01 02 	lds	r19, 0x0201
     c96:	2f 5f       	subi	r18, 0xFF	; 255
     c98:	3f 4f       	sbci	r19, 0xFF	; 255
     c9a:	fc 01       	movw	r30, r24
     c9c:	ee 0f       	add	r30, r30
     c9e:	ff 1f       	adc	r31, r31
     ca0:	ee 0f       	add	r30, r30
     ca2:	ff 1f       	adc	r31, r31
     ca4:	8e 0f       	add	r24, r30
     ca6:	9f 1f       	adc	r25, r31
     ca8:	82 0f       	add	r24, r18
     caa:	93 1f       	adc	r25, r19
     cac:	fc 01       	movw	r30, r24
     cae:	ee 0f       	add	r30, r30
     cb0:	ff 1f       	adc	r31, r31
     cb2:	e8 5f       	subi	r30, 0xF8	; 248
     cb4:	fd 4f       	sbci	r31, 0xFD	; 253
     cb6:	82 e0       	ldi	r24, 0x02	; 2
     cb8:	90 e0       	ldi	r25, 0x00	; 0
     cba:	91 83       	std	Z+1, r25	; 0x01
     cbc:	80 83       	st	Z, r24
			buzzer_on();_delay_ms(500);buzzer_off();
     cbe:	0e 94 cf 02 	call	0x59e	; 0x59e <buzzer_on>
     cc2:	8f ef       	ldi	r24, 0xFF	; 255
     cc4:	9f e7       	ldi	r25, 0x7F	; 127
     cc6:	a6 e1       	ldi	r26, 0x16	; 22
     cc8:	81 50       	subi	r24, 0x01	; 1
     cca:	90 40       	sbci	r25, 0x00	; 0
     ccc:	a0 40       	sbci	r26, 0x00	; 0
     cce:	e1 f7       	brne	.-8      	; 0xcc8 <SharpSide+0x5e>
     cd0:	00 c0       	rjmp	.+0      	; 0xcd2 <SharpSide+0x68>
     cd2:	00 00       	nop
     cd4:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
			count2++;
     cd8:	80 91 04 02 	lds	r24, 0x0204
     cdc:	90 91 05 02 	lds	r25, 0x0205
     ce0:	01 96       	adiw	r24, 0x01	; 1
     ce2:	90 93 05 02 	sts	0x0205, r25
     ce6:	80 93 04 02 	sts	0x0204, r24
     cea:	08 95       	ret
	}
	else if(150<value2&&value2<190)
     cec:	87 59       	subi	r24, 0x97	; 151
     cee:	87 32       	cpi	r24, 0x27	; 39
     cf0:	e8 f4       	brcc	.+58     	; 0xd2c <SharpSide+0xc2>
	{
			Blk_Pos[Cur_Pos[1]+1][Cur_Pos[0]+1]=1;
     cf2:	80 91 02 02 	lds	r24, 0x0202
     cf6:	90 91 03 02 	lds	r25, 0x0203
     cfa:	01 96       	adiw	r24, 0x01	; 1
     cfc:	20 91 00 02 	lds	r18, 0x0200
     d00:	30 91 01 02 	lds	r19, 0x0201
     d04:	2f 5f       	subi	r18, 0xFF	; 255
     d06:	3f 4f       	sbci	r19, 0xFF	; 255
     d08:	fc 01       	movw	r30, r24
     d0a:	ee 0f       	add	r30, r30
     d0c:	ff 1f       	adc	r31, r31
     d0e:	ee 0f       	add	r30, r30
     d10:	ff 1f       	adc	r31, r31
     d12:	8e 0f       	add	r24, r30
     d14:	9f 1f       	adc	r25, r31
     d16:	82 0f       	add	r24, r18
     d18:	93 1f       	adc	r25, r19
     d1a:	fc 01       	movw	r30, r24
     d1c:	ee 0f       	add	r30, r30
     d1e:	ff 1f       	adc	r31, r31
     d20:	e8 5f       	subi	r30, 0xF8	; 248
     d22:	fd 4f       	sbci	r31, 0xFD	; 253
     d24:	81 e0       	ldi	r24, 0x01	; 1
     d26:	90 e0       	ldi	r25, 0x00	; 0
     d28:	91 83       	std	Z+1, r25	; 0x01
     d2a:	80 83       	st	Z, r24
     d2c:	08 95       	ret

00000d2e <forward_wlsD2>:
* Logic: Version of forward_wls used in  D2, calls SharpSide at each node in order to detect and log blocks.
* Example Call: forward_wlsD2(2) //Goes forward by two nodes calling SharpSide at 3 nodes (starting, first , second)
*
*/	
void forward_wlsD2( unsigned char node)			// forward function for traversing on D2.
{	unsigned char flagw=0;
     d2e:	0f 93       	push	r16
     d30:	1f 93       	push	r17
     d32:	cf 93       	push	r28
     d34:	df 93       	push	r29
     d36:	d8 2f       	mov	r29, r24
     d38:	c0 e0       	ldi	r28, 0x00	; 0
			flagw=flagw+1;
			velocity(215,210);
			forward_mm(30);
			stop();
			_delay_ms(500);
				if (node==flagw+1)					//checks nodes
     d3a:	08 2f       	mov	r16, r24
     d3c:	10 e0       	ldi	r17, 0x00	; 0
{	unsigned char flagw=0;
	while(1)
	{	
		

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     d3e:	83 e0       	ldi	r24, 0x03	; 3
     d40:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
     d44:	80 93 50 02 	sts	0x0250, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     d48:	82 e0       	ldi	r24, 0x02	; 2
     d4a:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
     d4e:	80 93 4f 02 	sts	0x024F, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     d52:	81 e0       	ldi	r24, 0x01	; 1
     d54:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
     d58:	80 93 4e 02 	sts	0x024E, r24
		
		
	//Function to detect node 
		 
		if( ( Center_white_line >0x0C && Left_white_line >0x0C) || (  Right_white_line>0x0C && Left_white_line>0x0C) || (  Center_white_line>0x0C && Right_white_line>0x0C))
     d5c:	90 91 4f 02 	lds	r25, 0x024F
     d60:	9d 30       	cpi	r25, 0x0D	; 13
     d62:	18 f4       	brcc	.+6      	; 0xd6a <forward_wlsD2+0x3c>
     d64:	8d 30       	cpi	r24, 0x0D	; 13
     d66:	08 f4       	brcc	.+2      	; 0xd6a <forward_wlsD2+0x3c>
     d68:	51 c0       	rjmp	.+162    	; 0xe0c <forward_wlsD2+0xde>
     d6a:	20 91 50 02 	lds	r18, 0x0250
     d6e:	2d 30       	cpi	r18, 0x0D	; 13
     d70:	30 f4       	brcc	.+12     	; 0xd7e <forward_wlsD2+0x50>
     d72:	9d 30       	cpi	r25, 0x0D	; 13
     d74:	08 f4       	brcc	.+2      	; 0xd78 <forward_wlsD2+0x4a>
     d76:	4a c0       	rjmp	.+148    	; 0xe0c <forward_wlsD2+0xde>
     d78:	8d 30       	cpi	r24, 0x0D	; 13
     d7a:	08 f4       	brcc	.+2      	; 0xd7e <forward_wlsD2+0x50>
     d7c:	47 c0       	rjmp	.+142    	; 0xe0c <forward_wlsD2+0xde>
		{	
			velocity(0,0);
     d7e:	80 e0       	ldi	r24, 0x00	; 0
     d80:	60 e0       	ldi	r22, 0x00	; 0
     d82:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
			forward();
     d86:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
     d8a:	8f ef       	ldi	r24, 0xFF	; 255
     d8c:	9f ef       	ldi	r25, 0xFF	; 255
     d8e:	ac e2       	ldi	r26, 0x2C	; 44
     d90:	81 50       	subi	r24, 0x01	; 1
     d92:	90 40       	sbci	r25, 0x00	; 0
     d94:	a0 40       	sbci	r26, 0x00	; 0
     d96:	e1 f7       	brne	.-8      	; 0xd90 <forward_wlsD2+0x62>
     d98:	00 c0       	rjmp	.+0      	; 0xd9a <forward_wlsD2+0x6c>
     d9a:	00 00       	nop
			_delay_ms(1000);
			flagw=flagw+1;
     d9c:	cf 5f       	subi	r28, 0xFF	; 255
			velocity(215,210);
     d9e:	87 ed       	ldi	r24, 0xD7	; 215
     da0:	62 ed       	ldi	r22, 0xD2	; 210
     da2:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
			forward_mm(30);
     da6:	8e e1       	ldi	r24, 0x1E	; 30
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <forward_mm>
			stop();
     dae:	0e 94 67 04 	call	0x8ce	; 0x8ce <stop>
     db2:	8f ef       	ldi	r24, 0xFF	; 255
     db4:	9f e7       	ldi	r25, 0x7F	; 127
     db6:	a6 e1       	ldi	r26, 0x16	; 22
     db8:	81 50       	subi	r24, 0x01	; 1
     dba:	90 40       	sbci	r25, 0x00	; 0
     dbc:	a0 40       	sbci	r26, 0x00	; 0
     dbe:	e1 f7       	brne	.-8      	; 0xdb8 <forward_wlsD2+0x8a>
     dc0:	00 c0       	rjmp	.+0      	; 0xdc2 <forward_wlsD2+0x94>
     dc2:	00 00       	nop
			_delay_ms(500);
				if (node==flagw+1)					//checks nodes
     dc4:	8c 2f       	mov	r24, r28
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	9c 01       	movw	r18, r24
     dca:	2f 5f       	subi	r18, 0xFF	; 255
     dcc:	3f 4f       	sbci	r19, 0xFF	; 255
     dce:	02 17       	cp	r16, r18
     dd0:	13 07       	cpc	r17, r19
     dd2:	19 f4       	brne	.+6      	; 0xdda <forward_wlsD2+0xac>
				{
					SharpSide();
     dd4:	0e 94 35 06 	call	0xc6a	; 0xc6a <SharpSide>
     dd8:	19 c0       	rjmp	.+50     	; 0xe0c <forward_wlsD2+0xde>
				}
				else if (node==flagw+2)
     dda:	9c 01       	movw	r18, r24
     ddc:	2e 5f       	subi	r18, 0xFE	; 254
     dde:	3f 4f       	sbci	r19, 0xFF	; 255
     de0:	02 17       	cp	r16, r18
     de2:	13 07       	cpc	r17, r19
     de4:	19 f4       	brne	.+6      	; 0xdec <forward_wlsD2+0xbe>
				{
					SharpSide();
     de6:	0e 94 35 06 	call	0xc6a	; 0xc6a <SharpSide>
     dea:	10 c0       	rjmp	.+32     	; 0xe0c <forward_wlsD2+0xde>
				}
				else if (node==flagw+3)
     dec:	03 96       	adiw	r24, 0x03	; 3
     dee:	08 17       	cp	r16, r24
     df0:	19 07       	cpc	r17, r25
     df2:	19 f4       	brne	.+6      	; 0xdfa <forward_wlsD2+0xcc>
				{
					SharpSide();
     df4:	0e 94 35 06 	call	0xc6a	; 0xc6a <SharpSide>
     df8:	09 c0       	rjmp	.+18     	; 0xe0c <forward_wlsD2+0xde>
				}
				else if (node==flagw)
     dfa:	dc 17       	cp	r29, r28
     dfc:	39 f4       	brne	.+14     	; 0xe0c <forward_wlsD2+0xde>
				{
					SharpSide();
     dfe:	0e 94 35 06 	call	0xc6a	; 0xc6a <SharpSide>
			forward();
			velocity(190,80);
		}
//CurPos(node,0,0,0);
	}
}
     e02:	df 91       	pop	r29
     e04:	cf 91       	pop	r28
     e06:	1f 91       	pop	r17
     e08:	0f 91       	pop	r16
     e0a:	08 95       	ret
				{
					SharpSide();
					break;
				}
			}		
		if((Center_white_line>=0x0C) )				//if center white line detects value more tan 0x0C , goes forward.
     e0c:	80 91 4f 02 	lds	r24, 0x024F
     e10:	8c 30       	cpi	r24, 0x0C	; 12
     e12:	40 f0       	brcs	.+16     	; 0xe24 <forward_wlsD2+0xf6>
		{
			//flag1=1;
			buzzer_off();
     e14:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
			forward();
     e18:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(215,210);
     e1c:	87 ed       	ldi	r24, 0xD7	; 215
     e1e:	62 ed       	ldi	r22, 0xD2	; 210
     e20:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
		}

		if((Left_white_line>=0x0C))				// turns when lefts white line detects value more than 0x0C
     e24:	80 91 50 02 	lds	r24, 0x0250
     e28:	8c 30       	cpi	r24, 0x0C	; 12
     e2a:	40 f0       	brcs	.+16     	; 0xe3c <forward_wlsD2+0x10e>
		{
			//flag1=1;
			buzzer_off();
     e2c:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
			forward();
     e30:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(80,190);
     e34:	80 e5       	ldi	r24, 0x50	; 80
     e36:	6e eb       	ldi	r22, 0xBE	; 190
     e38:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
		}

		if((Right_white_line>=0x0C) )				// turns when right white line detects value more than 0x0C
     e3c:	80 91 4e 02 	lds	r24, 0x024E
     e40:	8c 30       	cpi	r24, 0x0C	; 12
     e42:	08 f4       	brcc	.+2      	; 0xe46 <forward_wlsD2+0x118>
     e44:	7c cf       	rjmp	.-264    	; 0xd3e <forward_wlsD2+0x10>
		{
			//flag1=1;
			buzzer_off();
     e46:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
			forward();
     e4a:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(190,80);
     e4e:	8e eb       	ldi	r24, 0xBE	; 190
     e50:	60 e5       	ldi	r22, 0x50	; 80
     e52:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
     e56:	73 cf       	rjmp	.-282    	; 0xd3e <forward_wlsD2+0x10>

00000e58 <right_wls>:
* Example Call: right_wls();
*
*/
void right_wls()			// function for taking the right turn when on a node.
{
	velocity(215,210);
     e58:	87 ed       	ldi	r24, 0xD7	; 215
     e5a:	62 ed       	ldi	r22, 0xD2	; 210
     e5c:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
	forward_mm(30);
     e60:	8e e1       	ldi	r24, 0x1E	; 30
     e62:	90 e0       	ldi	r25, 0x00	; 0
     e64:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <forward_mm>
	stop();
     e68:	0e 94 67 04 	call	0x8ce	; 0x8ce <stop>
     e6c:	8f ef       	ldi	r24, 0xFF	; 255
     e6e:	9f e7       	ldi	r25, 0x7F	; 127
     e70:	a6 e1       	ldi	r26, 0x16	; 22
     e72:	81 50       	subi	r24, 0x01	; 1
     e74:	90 40       	sbci	r25, 0x00	; 0
     e76:	a0 40       	sbci	r26, 0x00	; 0
     e78:	e1 f7       	brne	.-8      	; 0xe72 <right_wls+0x1a>
     e7a:	00 c0       	rjmp	.+0      	; 0xe7c <right_wls+0x24>
     e7c:	00 00       	nop
	_delay_ms(500);
	velocity(215,210);
     e7e:	87 ed       	ldi	r24, 0xD7	; 215
     e80:	62 ed       	ldi	r22, 0xD2	; 210
     e82:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
	right_degrees(90);
     e86:	8a e5       	ldi	r24, 0x5A	; 90
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
	stop();
     e8e:	0e 94 67 04 	call	0x8ce	; 0x8ce <stop>
     e92:	8f ef       	ldi	r24, 0xFF	; 255
     e94:	9f e7       	ldi	r25, 0x7F	; 127
     e96:	a6 e1       	ldi	r26, 0x16	; 22
     e98:	81 50       	subi	r24, 0x01	; 1
     e9a:	90 40       	sbci	r25, 0x00	; 0
     e9c:	a0 40       	sbci	r26, 0x00	; 0
     e9e:	e1 f7       	brne	.-8      	; 0xe98 <right_wls+0x40>
     ea0:	00 c0       	rjmp	.+0      	; 0xea2 <right_wls+0x4a>
     ea2:	00 00       	nop
	_delay_ms(500);
	
	
}
     ea4:	08 95       	ret

00000ea6 <left_wls>:
* Example Call: left_wls();
*
*/
void left_wls()				// function for taking a left turn while on a node 
{
	velocity(215,210);
     ea6:	87 ed       	ldi	r24, 0xD7	; 215
     ea8:	62 ed       	ldi	r22, 0xD2	; 210
     eaa:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
	forward_mm(30);
     eae:	8e e1       	ldi	r24, 0x1E	; 30
     eb0:	90 e0       	ldi	r25, 0x00	; 0
     eb2:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <forward_mm>
	stop();
     eb6:	0e 94 67 04 	call	0x8ce	; 0x8ce <stop>
     eba:	8f ef       	ldi	r24, 0xFF	; 255
     ebc:	9f e7       	ldi	r25, 0x7F	; 127
     ebe:	a6 e1       	ldi	r26, 0x16	; 22
     ec0:	81 50       	subi	r24, 0x01	; 1
     ec2:	90 40       	sbci	r25, 0x00	; 0
     ec4:	a0 40       	sbci	r26, 0x00	; 0
     ec6:	e1 f7       	brne	.-8      	; 0xec0 <left_wls+0x1a>
     ec8:	00 c0       	rjmp	.+0      	; 0xeca <left_wls+0x24>
     eca:	00 00       	nop
	_delay_ms(500);
	velocity(215,210);
     ecc:	87 ed       	ldi	r24, 0xD7	; 215
     ece:	62 ed       	ldi	r22, 0xD2	; 210
     ed0:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
	left_degrees(90);
     ed4:	8a e5       	ldi	r24, 0x5A	; 90
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
	stop();
     edc:	0e 94 67 04 	call	0x8ce	; 0x8ce <stop>
     ee0:	8f ef       	ldi	r24, 0xFF	; 255
     ee2:	9f e7       	ldi	r25, 0x7F	; 127
     ee4:	a6 e1       	ldi	r26, 0x16	; 22
     ee6:	81 50       	subi	r24, 0x01	; 1
     ee8:	90 40       	sbci	r25, 0x00	; 0
     eea:	a0 40       	sbci	r26, 0x00	; 0
     eec:	e1 f7       	brne	.-8      	; 0xee6 <left_wls+0x40>
     eee:	00 c0       	rjmp	.+0      	; 0xef0 <left_wls+0x4a>
     ef0:	00 00       	nop
	_delay_ms(500);
	
}
     ef2:	08 95       	ret

00000ef4 <SharpTwist>:
* Example Call: n=SharpTwist(); //Returns the column number
*
*/	
uint8_t SharpTwist(void)
{
	uint8_t tmp=Cur_Pos[1],ret=0;
     ef4:	40 91 02 02 	lds	r20, 0x0202
     ef8:	50 91 03 02 	lds	r21, 0x0203
	if(Blk_Pos[tmp][2]!=0) //If block is already known to exist in the current row and column G.
     efc:	84 2f       	mov	r24, r20
     efe:	24 2f       	mov	r18, r20
     f00:	30 e0       	ldi	r19, 0x00	; 0
     f02:	22 0f       	add	r18, r18
     f04:	33 1f       	adc	r19, r19
     f06:	f9 01       	movw	r30, r18
     f08:	ee 0f       	add	r30, r30
     f0a:	ff 1f       	adc	r31, r31
     f0c:	ee 0f       	add	r30, r30
     f0e:	ff 1f       	adc	r31, r31
     f10:	2e 0f       	add	r18, r30
     f12:	3f 1f       	adc	r19, r31
     f14:	f9 01       	movw	r30, r18
     f16:	e8 5f       	subi	r30, 0xF8	; 248
     f18:	fd 4f       	sbci	r31, 0xFD	; 253
     f1a:	24 81       	ldd	r18, Z+4	; 0x04
     f1c:	35 81       	ldd	r19, Z+5	; 0x05
     f1e:	21 15       	cp	r18, r1
     f20:	31 05       	cpc	r19, r1
     f22:	c9 f0       	breq	.+50     	; 0xf56 <SharpTwist+0x62>
		{
			if(Blk_Pos[tmp][2]==2)	
     f24:	24 2f       	mov	r18, r20
     f26:	30 e0       	ldi	r19, 0x00	; 0
     f28:	c9 01       	movw	r24, r18
     f2a:	88 0f       	add	r24, r24
     f2c:	99 1f       	adc	r25, r25
     f2e:	fc 01       	movw	r30, r24
     f30:	ee 0f       	add	r30, r30
     f32:	ff 1f       	adc	r31, r31
     f34:	ee 0f       	add	r30, r30
     f36:	ff 1f       	adc	r31, r31
     f38:	8e 0f       	add	r24, r30
     f3a:	9f 1f       	adc	r25, r31
     f3c:	fc 01       	movw	r30, r24
     f3e:	e8 5f       	subi	r30, 0xF8	; 248
     f40:	fd 4f       	sbci	r31, 0xFD	; 253
     f42:	84 81       	ldd	r24, Z+4	; 0x04
     f44:	95 81       	ldd	r25, Z+5	; 0x05
     f46:	82 30       	cpi	r24, 0x02	; 2
     f48:	91 05       	cpc	r25, r1
     f4a:	09 f4       	brne	.+2      	; 0xf4e <SharpTwist+0x5a>
     f4c:	37 c1       	rjmp	.+622    	; 0x11bc <SharpTwist+0x2c8>
			{
				return 0;
			}
			else
			{
				left_wls();
     f4e:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
				return 2;
     f52:	82 e0       	ldi	r24, 0x02	; 2
     f54:	08 95       	ret
			}
		}
	else if(Blk_Pos[tmp][3]!=0) //If blocks already known to exist in the current row and column H.
     f56:	24 2f       	mov	r18, r20
     f58:	30 e0       	ldi	r19, 0x00	; 0
     f5a:	22 0f       	add	r18, r18
     f5c:	33 1f       	adc	r19, r19
     f5e:	f9 01       	movw	r30, r18
     f60:	ee 0f       	add	r30, r30
     f62:	ff 1f       	adc	r31, r31
     f64:	ee 0f       	add	r30, r30
     f66:	ff 1f       	adc	r31, r31
     f68:	2e 0f       	add	r18, r30
     f6a:	3f 1f       	adc	r19, r31
     f6c:	f9 01       	movw	r30, r18
     f6e:	e8 5f       	subi	r30, 0xF8	; 248
     f70:	fd 4f       	sbci	r31, 0xFD	; 253
     f72:	26 81       	ldd	r18, Z+6	; 0x06
     f74:	37 81       	ldd	r19, Z+7	; 0x07
     f76:	21 15       	cp	r18, r1
     f78:	31 05       	cpc	r19, r1
     f7a:	c9 f0       	breq	.+50     	; 0xfae <SharpTwist+0xba>
		{
			if(Blk_Pos[tmp][3]==2)
     f7c:	24 2f       	mov	r18, r20
     f7e:	30 e0       	ldi	r19, 0x00	; 0
     f80:	c9 01       	movw	r24, r18
     f82:	88 0f       	add	r24, r24
     f84:	99 1f       	adc	r25, r25
     f86:	fc 01       	movw	r30, r24
     f88:	ee 0f       	add	r30, r30
     f8a:	ff 1f       	adc	r31, r31
     f8c:	ee 0f       	add	r30, r30
     f8e:	ff 1f       	adc	r31, r31
     f90:	8e 0f       	add	r24, r30
     f92:	9f 1f       	adc	r25, r31
     f94:	fc 01       	movw	r30, r24
     f96:	e8 5f       	subi	r30, 0xF8	; 248
     f98:	fd 4f       	sbci	r31, 0xFD	; 253
     f9a:	86 81       	ldd	r24, Z+6	; 0x06
     f9c:	97 81       	ldd	r25, Z+7	; 0x07
     f9e:	82 30       	cpi	r24, 0x02	; 2
     fa0:	91 05       	cpc	r25, r1
     fa2:	09 f4       	brne	.+2      	; 0xfa6 <SharpTwist+0xb2>
     fa4:	0d c1       	rjmp	.+538    	; 0x11c0 <SharpTwist+0x2cc>
			{
				return 0;
			}
			else
			{
				left_wls();
     fa6:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
				return 3;
     faa:	83 e0       	ldi	r24, 0x03	; 3
     fac:	08 95       	ret
			}
		}
	else if(Blk_Pos[tmp][4]!=0) //If block is known to already exists in the current row and column I.
     fae:	24 2f       	mov	r18, r20
     fb0:	30 e0       	ldi	r19, 0x00	; 0
     fb2:	a9 01       	movw	r20, r18
     fb4:	44 0f       	add	r20, r20
     fb6:	55 1f       	adc	r21, r21
     fb8:	fa 01       	movw	r30, r20
     fba:	ee 0f       	add	r30, r30
     fbc:	ff 1f       	adc	r31, r31
     fbe:	ee 0f       	add	r30, r30
     fc0:	ff 1f       	adc	r31, r31
     fc2:	4e 0f       	add	r20, r30
     fc4:	5f 1f       	adc	r21, r31
     fc6:	fa 01       	movw	r30, r20
     fc8:	e8 5f       	subi	r30, 0xF8	; 248
     fca:	fd 4f       	sbci	r31, 0xFD	; 253
     fcc:	20 85       	ldd	r18, Z+8	; 0x08
     fce:	31 85       	ldd	r19, Z+9	; 0x09
     fd0:	21 15       	cp	r18, r1
     fd2:	31 05       	cpc	r19, r1
     fd4:	c9 f0       	breq	.+50     	; 0x1008 <SharpTwist+0x114>
		{
			if(Blk_Pos[tmp][4]==2)
     fd6:	28 2f       	mov	r18, r24
     fd8:	30 e0       	ldi	r19, 0x00	; 0
     fda:	c9 01       	movw	r24, r18
     fdc:	88 0f       	add	r24, r24
     fde:	99 1f       	adc	r25, r25
     fe0:	fc 01       	movw	r30, r24
     fe2:	ee 0f       	add	r30, r30
     fe4:	ff 1f       	adc	r31, r31
     fe6:	ee 0f       	add	r30, r30
     fe8:	ff 1f       	adc	r31, r31
     fea:	8e 0f       	add	r24, r30
     fec:	9f 1f       	adc	r25, r31
     fee:	fc 01       	movw	r30, r24
     ff0:	e8 5f       	subi	r30, 0xF8	; 248
     ff2:	fd 4f       	sbci	r31, 0xFD	; 253
     ff4:	80 85       	ldd	r24, Z+8	; 0x08
     ff6:	91 85       	ldd	r25, Z+9	; 0x09
     ff8:	82 30       	cpi	r24, 0x02	; 2
     ffa:	91 05       	cpc	r25, r1
     ffc:	09 f4       	brne	.+2      	; 0x1000 <SharpTwist+0x10c>
     ffe:	e2 c0       	rjmp	.+452    	; 0x11c4 <SharpTwist+0x2d0>
			{
				return 0;
			}
			else
			{
			left_wls();
    1000:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
			return 4;
    1004:	84 e0       	ldi	r24, 0x04	; 4
    1006:	08 95       	ret
			}
		}	
	else //if block is not known to exist.
	{
		if(Cur_Pos[1]==0)
    1008:	80 91 02 02 	lds	r24, 0x0202
    100c:	90 91 03 02 	lds	r25, 0x0203
    1010:	00 97       	sbiw	r24, 0x00	; 0
    1012:	09 f0       	breq	.+2      	; 0x1016 <SharpTwist+0x122>
    1014:	74 c0       	rjmp	.+232    	; 0x10fe <SharpTwist+0x20a>
		{
			left_degrees(45);
    1016:	8d e2       	ldi	r24, 0x2D	; 45
    1018:	90 e0       	ldi	r25, 0x00	; 0
    101a:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
			unsigned char value;
			Sensor_read = ADC_Conversion(12);
    101e:	8c e0       	ldi	r24, 0x0C	; 12
    1020:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    1024:	80 93 69 02 	sts	0x0269, r24
			value = Sharp_GP2D12_estimation(Sensor_read);	
    1028:	80 91 69 02 	lds	r24, 0x0269
    102c:	0e 94 d7 02 	call	0x5ae	; 0x5ae <Sharp_GP2D12_estimation>
			
			if(150<value&&value<180)			//Block is placed incorrectly at intersection of current row and column G
    1030:	98 2f       	mov	r25, r24
    1032:	97 59       	subi	r25, 0x97	; 151
    1034:	9d 31       	cpi	r25, 0x1D	; 29
    1036:	e8 f4       	brcc	.+58     	; 0x1072 <SharpTwist+0x17e>
			{
				Blk_Pos[Cur_Pos[1]][2]=1;	
    1038:	80 91 02 02 	lds	r24, 0x0202
    103c:	90 91 03 02 	lds	r25, 0x0203
    1040:	fc 01       	movw	r30, r24
    1042:	ee 0f       	add	r30, r30
    1044:	ff 1f       	adc	r31, r31
    1046:	88 0f       	add	r24, r24
    1048:	99 1f       	adc	r25, r25
    104a:	88 0f       	add	r24, r24
    104c:	99 1f       	adc	r25, r25
    104e:	88 0f       	add	r24, r24
    1050:	99 1f       	adc	r25, r25
    1052:	e8 0f       	add	r30, r24
    1054:	f9 1f       	adc	r31, r25
    1056:	e8 5f       	subi	r30, 0xF8	; 248
    1058:	fd 4f       	sbci	r31, 0xFD	; 253
    105a:	81 e0       	ldi	r24, 0x01	; 1
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	95 83       	std	Z+5, r25	; 0x05
    1060:	84 83       	std	Z+4, r24	; 0x04
			{
				Blk_Pos[Cur_Pos[1]][4]=2;	//Set value of block position as 2
				count2++;					//Increment counter for D2
				ret=0;	
			}
			right_degrees(45);
    1062:	8d e2       	ldi	r24, 0x2D	; 45
    1064:	90 e0       	ldi	r25, 0x00	; 0
    1066:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
			if(ret!=0)
			{
				left_wls();
    106a:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
			value = Sharp_GP2D12_estimation(Sensor_read);	
			
			if(150<value&&value<180)			//Block is placed incorrectly at intersection of current row and column G
			{
				Blk_Pos[Cur_Pos[1]][2]=1;	
				ret=2;
    106e:	82 e0       	ldi	r24, 0x02	; 2
    1070:	08 95       	ret
			else if(700<value&&value<790)		//Block is placed incorrectly at intersection of current row and column I
			{
				Blk_Pos[Cur_Pos[1]][4]=1;
				ret=4;	
			}
			else if(120<value&&value<145)	//Block is placed correctly at intersection of current row and column G
    1072:	98 2f       	mov	r25, r24
    1074:	99 57       	subi	r25, 0x79	; 121
    1076:	98 31       	cpi	r25, 0x18	; 24
    1078:	f8 f4       	brcc	.+62     	; 0x10b8 <SharpTwist+0x1c4>
			{
				Blk_Pos[Cur_Pos[1]][2]=2;	//Set value of block position as 2
    107a:	80 91 02 02 	lds	r24, 0x0202
    107e:	90 91 03 02 	lds	r25, 0x0203
    1082:	fc 01       	movw	r30, r24
    1084:	ee 0f       	add	r30, r30
    1086:	ff 1f       	adc	r31, r31
    1088:	88 0f       	add	r24, r24
    108a:	99 1f       	adc	r25, r25
    108c:	88 0f       	add	r24, r24
    108e:	99 1f       	adc	r25, r25
    1090:	88 0f       	add	r24, r24
    1092:	99 1f       	adc	r25, r25
    1094:	e8 0f       	add	r30, r24
    1096:	f9 1f       	adc	r31, r25
    1098:	e8 5f       	subi	r30, 0xF8	; 248
    109a:	fd 4f       	sbci	r31, 0xFD	; 253
    109c:	82 e0       	ldi	r24, 0x02	; 2
    109e:	90 e0       	ldi	r25, 0x00	; 0
    10a0:	95 83       	std	Z+5, r25	; 0x05
    10a2:	84 83       	std	Z+4, r24	; 0x04
				count2++;					//Increment counter for D2	
    10a4:	80 91 04 02 	lds	r24, 0x0204
    10a8:	90 91 05 02 	lds	r25, 0x0205
    10ac:	01 96       	adiw	r24, 0x01	; 1
    10ae:	90 93 05 02 	sts	0x0205, r25
    10b2:	80 93 04 02 	sts	0x0204, r24
    10b6:	88 c0       	rjmp	.+272    	; 0x11c8 <SharpTwist+0x2d4>
				ret=0;
			}
			else if(220<value&&value<250)	//Block is placed correctly at intersection of current row and column H
    10b8:	8d 5d       	subi	r24, 0xDD	; 221
    10ba:	8d 31       	cpi	r24, 0x1D	; 29
    10bc:	08 f0       	brcs	.+2      	; 0x10c0 <SharpTwist+0x1cc>
    10be:	84 c0       	rjmp	.+264    	; 0x11c8 <SharpTwist+0x2d4>
			{
				Blk_Pos[Cur_Pos[1]][3]=2;	//Set value of block position as 2
    10c0:	80 91 02 02 	lds	r24, 0x0202
    10c4:	90 91 03 02 	lds	r25, 0x0203
    10c8:	fc 01       	movw	r30, r24
    10ca:	ee 0f       	add	r30, r30
    10cc:	ff 1f       	adc	r31, r31
    10ce:	88 0f       	add	r24, r24
    10d0:	99 1f       	adc	r25, r25
    10d2:	88 0f       	add	r24, r24
    10d4:	99 1f       	adc	r25, r25
    10d6:	88 0f       	add	r24, r24
    10d8:	99 1f       	adc	r25, r25
    10da:	e8 0f       	add	r30, r24
    10dc:	f9 1f       	adc	r31, r25
    10de:	e8 5f       	subi	r30, 0xF8	; 248
    10e0:	fd 4f       	sbci	r31, 0xFD	; 253
    10e2:	82 e0       	ldi	r24, 0x02	; 2
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	97 83       	std	Z+7, r25	; 0x07
    10e8:	86 83       	std	Z+6, r24	; 0x06
				count2++;					//Increment counter for D2
    10ea:	80 91 04 02 	lds	r24, 0x0204
    10ee:	90 91 05 02 	lds	r25, 0x0205
    10f2:	01 96       	adiw	r24, 0x01	; 1
    10f4:	90 93 05 02 	sts	0x0205, r25
    10f8:	80 93 04 02 	sts	0x0204, r24
    10fc:	65 c0       	rjmp	.+202    	; 0x11c8 <SharpTwist+0x2d4>
			}
		
		}
		else
		{
			left_degrees(45);
    10fe:	8d e2       	ldi	r24, 0x2D	; 45
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
			unsigned char value;
			Sensor_read = ADC_Conversion(10);
    1106:	8a e0       	ldi	r24, 0x0A	; 10
    1108:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    110c:	80 93 69 02 	sts	0x0269, r24
			value = Sharp_GP2D12_estimation(Sensor_read);	
    1110:	80 91 69 02 	lds	r24, 0x0269
    1114:	0e 94 d7 02 	call	0x5ae	; 0x5ae <Sharp_GP2D12_estimation>
			
			if(150<value&&value<180)
    1118:	98 2f       	mov	r25, r24
    111a:	97 59       	subi	r25, 0x97	; 151
    111c:	9d 31       	cpi	r25, 0x1D	; 29
    111e:	d8 f4       	brcc	.+54     	; 0x1156 <SharpTwist+0x262>
			{
				Blk_Pos[Cur_Pos[1]][2]=1;
    1120:	80 91 02 02 	lds	r24, 0x0202
    1124:	90 91 03 02 	lds	r25, 0x0203
    1128:	fc 01       	movw	r30, r24
    112a:	ee 0f       	add	r30, r30
    112c:	ff 1f       	adc	r31, r31
    112e:	88 0f       	add	r24, r24
    1130:	99 1f       	adc	r25, r25
    1132:	88 0f       	add	r24, r24
    1134:	99 1f       	adc	r25, r25
    1136:	88 0f       	add	r24, r24
    1138:	99 1f       	adc	r25, r25
    113a:	e8 0f       	add	r30, r24
    113c:	f9 1f       	adc	r31, r25
    113e:	e8 5f       	subi	r30, 0xF8	; 248
    1140:	fd 4f       	sbci	r31, 0xFD	; 253
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	90 e0       	ldi	r25, 0x00	; 0
    1146:	95 83       	std	Z+5, r25	; 0x05
    1148:	84 83       	std	Z+4, r24	; 0x04
			{
				right_degrees(45);
			}
			else
			{
				left_degrees(45);
    114a:	8d e2       	ldi	r24, 0x2D	; 45
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
			value = Sharp_GP2D12_estimation(Sensor_read);	
			
			if(150<value&&value<180)
			{
				Blk_Pos[Cur_Pos[1]][2]=1;
				ret=2;
    1152:	82 e0       	ldi	r24, 0x02	; 2
    1154:	08 95       	ret
			else if(700<value&&value<790)
			{
				Blk_Pos[Cur_Pos[1]][4]=1;
				ret=4;	
			}
			else if(120<value&&value<145)
    1156:	98 2f       	mov	r25, r24
    1158:	99 57       	subi	r25, 0x79	; 121
    115a:	98 31       	cpi	r25, 0x18	; 24
    115c:	b0 f4       	brcc	.+44     	; 0x118a <SharpTwist+0x296>
			{
				Blk_Pos[Cur_Pos[1]][2]=2;
    115e:	80 91 02 02 	lds	r24, 0x0202
    1162:	90 91 03 02 	lds	r25, 0x0203
    1166:	fc 01       	movw	r30, r24
    1168:	ee 0f       	add	r30, r30
    116a:	ff 1f       	adc	r31, r31
    116c:	88 0f       	add	r24, r24
    116e:	99 1f       	adc	r25, r25
    1170:	88 0f       	add	r24, r24
    1172:	99 1f       	adc	r25, r25
    1174:	88 0f       	add	r24, r24
    1176:	99 1f       	adc	r25, r25
    1178:	e8 0f       	add	r30, r24
    117a:	f9 1f       	adc	r31, r25
    117c:	e8 5f       	subi	r30, 0xF8	; 248
    117e:	fd 4f       	sbci	r31, 0xFD	; 253
    1180:	82 e0       	ldi	r24, 0x02	; 2
    1182:	90 e0       	ldi	r25, 0x00	; 0
    1184:	95 83       	std	Z+5, r25	; 0x05
    1186:	84 83       	std	Z+4, r24	; 0x04
    1188:	25 c0       	rjmp	.+74     	; 0x11d4 <SharpTwist+0x2e0>
				ret=0;
			}
			else if(220<value&&value<250)
    118a:	8d 5d       	subi	r24, 0xDD	; 221
    118c:	8d 31       	cpi	r24, 0x1D	; 29
    118e:	10 f5       	brcc	.+68     	; 0x11d4 <SharpTwist+0x2e0>
			{
				Blk_Pos[Cur_Pos[1]][3]=2;
    1190:	80 91 02 02 	lds	r24, 0x0202
    1194:	90 91 03 02 	lds	r25, 0x0203
    1198:	fc 01       	movw	r30, r24
    119a:	ee 0f       	add	r30, r30
    119c:	ff 1f       	adc	r31, r31
    119e:	88 0f       	add	r24, r24
    11a0:	99 1f       	adc	r25, r25
    11a2:	88 0f       	add	r24, r24
    11a4:	99 1f       	adc	r25, r25
    11a6:	88 0f       	add	r24, r24
    11a8:	99 1f       	adc	r25, r25
    11aa:	e8 0f       	add	r30, r24
    11ac:	f9 1f       	adc	r31, r25
    11ae:	e8 5f       	subi	r30, 0xF8	; 248
    11b0:	fd 4f       	sbci	r31, 0xFD	; 253
    11b2:	82 e0       	ldi	r24, 0x02	; 2
    11b4:	90 e0       	ldi	r25, 0x00	; 0
    11b6:	97 83       	std	Z+7, r25	; 0x07
    11b8:	86 83       	std	Z+6, r24	; 0x06
    11ba:	0c c0       	rjmp	.+24     	; 0x11d4 <SharpTwist+0x2e0>
	uint8_t tmp=Cur_Pos[1],ret=0;
	if(Blk_Pos[tmp][2]!=0) //If block is already known to exist in the current row and column G.
		{
			if(Blk_Pos[tmp][2]==2)	
			{
				return 0;
    11bc:	80 e0       	ldi	r24, 0x00	; 0
    11be:	08 95       	ret
		}
	else if(Blk_Pos[tmp][3]!=0) //If blocks already known to exist in the current row and column H.
		{
			if(Blk_Pos[tmp][3]==2)
			{
				return 0;
    11c0:	80 e0       	ldi	r24, 0x00	; 0
    11c2:	08 95       	ret
		}
	else if(Blk_Pos[tmp][4]!=0) //If block is known to already exists in the current row and column I.
		{
			if(Blk_Pos[tmp][4]==2)
			{
				return 0;
    11c4:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		
	}
	return ret;
}
    11c6:	08 95       	ret
			{
				Blk_Pos[Cur_Pos[1]][4]=2;	//Set value of block position as 2
				count2++;					//Increment counter for D2
				ret=0;	
			}
			right_degrees(45);
    11c8:	8d e2       	ldi	r24, 0x2D	; 45
    11ca:	90 e0       	ldi	r25, 0x00	; 0
    11cc:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
    11d0:	80 e0       	ldi	r24, 0x00	; 0
    11d2:	08 95       	ret
				Blk_Pos[Cur_Pos[1]][4]=2;
				ret=0;	
			}
			if(ret==0)
			{
				right_degrees(45);
    11d4:	8d e2       	ldi	r24, 0x2D	; 45
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
    11dc:	80 e0       	ldi	r24, 0x00	; 0
    11de:	08 95       	ret

000011e0 <twist>:
* in the function>
* Example Call: <Example of how to call this function>
*
*/	
int twist (int x)            
{
    11e0:	cf 93       	push	r28
    11e2:	df 93       	push	r29
    11e4:	ec 01       	movw	r28, r24
	if(x%2!=0)							//first section makes the servo rotate by 180 degrees
    11e6:	80 ff       	sbrs	r24, 0
    11e8:	1b c0       	rjmp	.+54     	; 0x1220 <twist+0x40>
	{
		servo_1(0);
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	0e 94 17 04 	call	0x82e	; 0x82e <servo_1>
    11f0:	8f ef       	ldi	r24, 0xFF	; 255
    11f2:	9f e7       	ldi	r25, 0x7F	; 127
    11f4:	a6 e1       	ldi	r26, 0x16	; 22
    11f6:	81 50       	subi	r24, 0x01	; 1
    11f8:	90 40       	sbci	r25, 0x00	; 0
    11fa:	a0 40       	sbci	r26, 0x00	; 0
    11fc:	e1 f7       	brne	.-8      	; 0x11f6 <twist+0x16>
    11fe:	00 c0       	rjmp	.+0      	; 0x1200 <twist+0x20>
    1200:	00 00       	nop
		_delay_ms(500);
		servo_1(180);
    1202:	84 eb       	ldi	r24, 0xB4	; 180
    1204:	0e 94 17 04 	call	0x82e	; 0x82e <servo_1>
    1208:	8f ef       	ldi	r24, 0xFF	; 255
    120a:	9f ef       	ldi	r25, 0xFF	; 255
    120c:	ac e2       	ldi	r26, 0x2C	; 44
    120e:	81 50       	subi	r24, 0x01	; 1
    1210:	90 40       	sbci	r25, 0x00	; 0
    1212:	a0 40       	sbci	r26, 0x00	; 0
    1214:	e1 f7       	brne	.-8      	; 0x120e <twist+0x2e>
    1216:	00 c0       	rjmp	.+0      	; 0x1218 <twist+0x38>
    1218:	00 00       	nop
		_delay_ms(1000);
		servo_1_free();
    121a:	0e 94 49 04 	call	0x892	; 0x892 <servo_1_free>
    121e:	1a c0       	rjmp	.+52     	; 0x1254 <twist+0x74>
	}
	else								//second section makes the servo rotate back by 180 degrees
	{
		servo_1(180);
    1220:	84 eb       	ldi	r24, 0xB4	; 180
    1222:	0e 94 17 04 	call	0x82e	; 0x82e <servo_1>
    1226:	8f ef       	ldi	r24, 0xFF	; 255
    1228:	9f e7       	ldi	r25, 0x7F	; 127
    122a:	a6 e1       	ldi	r26, 0x16	; 22
    122c:	81 50       	subi	r24, 0x01	; 1
    122e:	90 40       	sbci	r25, 0x00	; 0
    1230:	a0 40       	sbci	r26, 0x00	; 0
    1232:	e1 f7       	brne	.-8      	; 0x122c <twist+0x4c>
    1234:	00 c0       	rjmp	.+0      	; 0x1236 <twist+0x56>
    1236:	00 00       	nop
		_delay_ms(500);
		servo_1(0);
    1238:	80 e0       	ldi	r24, 0x00	; 0
    123a:	0e 94 17 04 	call	0x82e	; 0x82e <servo_1>
    123e:	8f ef       	ldi	r24, 0xFF	; 255
    1240:	9f ef       	ldi	r25, 0xFF	; 255
    1242:	ac e2       	ldi	r26, 0x2C	; 44
    1244:	81 50       	subi	r24, 0x01	; 1
    1246:	90 40       	sbci	r25, 0x00	; 0
    1248:	a0 40       	sbci	r26, 0x00	; 0
    124a:	e1 f7       	brne	.-8      	; 0x1244 <twist+0x64>
    124c:	00 c0       	rjmp	.+0      	; 0x124e <twist+0x6e>
    124e:	00 00       	nop
		_delay_ms(1000);
		servo_1_free();
    1250:	0e 94 49 04 	call	0x892	; 0x892 <servo_1_free>
	}
	return x+1;							//value of x is incremented by 1 i.e every time x is made either even or odd
    1254:	ce 01       	movw	r24, r28
    1256:	01 96       	adiw	r24, 0x01	; 1
}
    1258:	df 91       	pop	r29
    125a:	cf 91       	pop	r28
    125c:	08 95       	ret

0000125e <lift>:
* Example Call:		 y=twist(y);
*
*/

int lift (int x)
{
    125e:	1f 93       	push	r17
    1260:	cf 93       	push	r28
    1262:	df 93       	push	r29
    1264:	ec 01       	movw	r28, r24
	if(x%2!=0)							//first section makes the servo rotate by 90 degrees
    1266:	80 ff       	sbrs	r24, 0
    1268:	1b c0       	rjmp	.+54     	; 0x12a0 <lift+0x42>
    126a:	10 e0       	ldi	r17, 0x00	; 0
		
		unsigned char k = 0;
		
		for (k = 0; k <90; k++)			//k is slowly incremented from 0 to 90 degrees by introducing delay of 30 milliseconds after each increment.
		{
			servo_2(k);
    126c:	81 2f       	mov	r24, r17
    126e:	0e 94 30 04 	call	0x860	; 0x860 <servo_2>
    1272:	89 e9       	ldi	r24, 0x99	; 153
    1274:	99 e5       	ldi	r25, 0x59	; 89
    1276:	a1 e0       	ldi	r26, 0x01	; 1
    1278:	81 50       	subi	r24, 0x01	; 1
    127a:	90 40       	sbci	r25, 0x00	; 0
    127c:	a0 40       	sbci	r26, 0x00	; 0
    127e:	e1 f7       	brne	.-8      	; 0x1278 <lift+0x1a>
    1280:	00 00       	nop
	if(x%2!=0)							//first section makes the servo rotate by 90 degrees
	{
		
		unsigned char k = 0;
		
		for (k = 0; k <90; k++)			//k is slowly incremented from 0 to 90 degrees by introducing delay of 30 milliseconds after each increment.
    1282:	1f 5f       	subi	r17, 0xFF	; 255
    1284:	1a 35       	cpi	r17, 0x5A	; 90
    1286:	91 f7       	brne	.-28     	; 0x126c <lift+0xe>
    1288:	8f ef       	ldi	r24, 0xFF	; 255
    128a:	9f e7       	ldi	r25, 0x7F	; 127
    128c:	a6 e1       	ldi	r26, 0x16	; 22
    128e:	81 50       	subi	r24, 0x01	; 1
    1290:	90 40       	sbci	r25, 0x00	; 0
    1292:	a0 40       	sbci	r26, 0x00	; 0
    1294:	e1 f7       	brne	.-8      	; 0x128e <lift+0x30>
    1296:	00 c0       	rjmp	.+0      	; 0x1298 <lift+0x3a>
    1298:	00 00       	nop
		{
			servo_2(k);
			_delay_ms(30);
		}
		_delay_ms(500);
		servo_2_free();
    129a:	0e 94 50 04 	call	0x8a0	; 0x8a0 <servo_2_free>
    129e:	19 c0       	rjmp	.+50     	; 0x12d2 <lift+0x74>
*
*/

int lift (int x)
{
	if(x%2!=0)							//first section makes the servo rotate by 90 degrees
    12a0:	1a e5       	ldi	r17, 0x5A	; 90
	{
		unsigned char l = 90;
		
		for (l = 90; l >0; l--)			//l is slowly decremented from 90 to 0 degrees by introducing delay of 30 milliseconds after each decrement.
		{
			servo_2(l);
    12a2:	81 2f       	mov	r24, r17
    12a4:	0e 94 30 04 	call	0x860	; 0x860 <servo_2>
    12a8:	89 e9       	ldi	r24, 0x99	; 153
    12aa:	99 e5       	ldi	r25, 0x59	; 89
    12ac:	a1 e0       	ldi	r26, 0x01	; 1
    12ae:	81 50       	subi	r24, 0x01	; 1
    12b0:	90 40       	sbci	r25, 0x00	; 0
    12b2:	a0 40       	sbci	r26, 0x00	; 0
    12b4:	e1 f7       	brne	.-8      	; 0x12ae <lift+0x50>
    12b6:	00 00       	nop
	}
	else								//second section makes the servo rotate back to 0 degrees
	{
		unsigned char l = 90;
		
		for (l = 90; l >0; l--)			//l is slowly decremented from 90 to 0 degrees by introducing delay of 30 milliseconds after each decrement.
    12b8:	11 50       	subi	r17, 0x01	; 1
    12ba:	99 f7       	brne	.-26     	; 0x12a2 <lift+0x44>
    12bc:	8f ef       	ldi	r24, 0xFF	; 255
    12be:	9f e7       	ldi	r25, 0x7F	; 127
    12c0:	a6 e1       	ldi	r26, 0x16	; 22
    12c2:	81 50       	subi	r24, 0x01	; 1
    12c4:	90 40       	sbci	r25, 0x00	; 0
    12c6:	a0 40       	sbci	r26, 0x00	; 0
    12c8:	e1 f7       	brne	.-8      	; 0x12c2 <lift+0x64>
    12ca:	00 c0       	rjmp	.+0      	; 0x12cc <lift+0x6e>
    12cc:	00 00       	nop
		{
			servo_2(l);
			_delay_ms(30);
		}
		_delay_ms(500);
		servo_2_free();
    12ce:	0e 94 50 04 	call	0x8a0	; 0x8a0 <servo_2_free>

	}
	return x+1;	//value of x is incremented by 1 i.e every time x is made either even or odd.
    12d2:	ce 01       	movw	r24, r28
    12d4:	01 96       	adiw	r24, 0x01	; 1
}
    12d6:	df 91       	pop	r29
    12d8:	cf 91       	pop	r28
    12da:	1f 91       	pop	r17
    12dc:	08 95       	ret

000012de <arm>:
* Example Call:		 arm(0);_delay_ms(500);
*
*/

void arm (int i)
{
    12de:	cf 93       	push	r28
    12e0:	df 93       	push	r29
    12e2:	ec 01       	movw	r28, r24
	static int x,y;
	y=lift(y);
    12e4:	80 91 5a 02 	lds	r24, 0x025A
    12e8:	90 91 5b 02 	lds	r25, 0x025B
    12ec:	0e 94 2f 09 	call	0x125e	; 0x125e <lift>
    12f0:	90 93 5b 02 	sts	0x025B, r25
    12f4:	80 93 5a 02 	sts	0x025A, r24
    12f8:	8f ef       	ldi	r24, 0xFF	; 255
    12fa:	9f e7       	ldi	r25, 0x7F	; 127
    12fc:	a6 e1       	ldi	r26, 0x16	; 22
    12fe:	81 50       	subi	r24, 0x01	; 1
    1300:	90 40       	sbci	r25, 0x00	; 0
    1302:	a0 40       	sbci	r26, 0x00	; 0
    1304:	e1 f7       	brne	.-8      	; 0x12fe <arm+0x20>
    1306:	00 c0       	rjmp	.+0      	; 0x1308 <arm+0x2a>
    1308:	00 00       	nop
	_delay_ms(500);
	x=twist(x);
    130a:	80 91 5c 02 	lds	r24, 0x025C
    130e:	90 91 5d 02 	lds	r25, 0x025D
    1312:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <twist>
    1316:	90 93 5d 02 	sts	0x025D, r25
    131a:	80 93 5c 02 	sts	0x025C, r24
    131e:	8f ef       	ldi	r24, 0xFF	; 255
    1320:	9f e7       	ldi	r25, 0x7F	; 127
    1322:	a6 e1       	ldi	r26, 0x16	; 22
    1324:	81 50       	subi	r24, 0x01	; 1
    1326:	90 40       	sbci	r25, 0x00	; 0
    1328:	a0 40       	sbci	r26, 0x00	; 0
    132a:	e1 f7       	brne	.-8      	; 0x1324 <arm+0x46>
    132c:	00 c0       	rjmp	.+0      	; 0x132e <arm+0x50>
    132e:	00 00       	nop
	_delay_ms(500);
	y=lift(y);
    1330:	80 91 5a 02 	lds	r24, 0x025A
    1334:	90 91 5b 02 	lds	r25, 0x025B
    1338:	0e 94 2f 09 	call	0x125e	; 0x125e <lift>
    133c:	90 93 5b 02 	sts	0x025B, r25
    1340:	80 93 5a 02 	sts	0x025A, r24
    1344:	8f ef       	ldi	r24, 0xFF	; 255
    1346:	9f e7       	ldi	r25, 0x7F	; 127
    1348:	a6 e1       	ldi	r26, 0x16	; 22
    134a:	81 50       	subi	r24, 0x01	; 1
    134c:	90 40       	sbci	r25, 0x00	; 0
    134e:	a0 40       	sbci	r26, 0x00	; 0
    1350:	e1 f7       	brne	.-8      	; 0x134a <arm+0x6c>
    1352:	00 c0       	rjmp	.+0      	; 0x1354 <arm+0x76>
    1354:	00 00       	nop
	_delay_ms(500);
	if(i==0)
    1356:	20 97       	sbiw	r28, 0x00	; 0
    1358:	51 f4       	brne	.+20     	; 0x136e <arm+0x90>
		count1++;
    135a:	80 91 06 02 	lds	r24, 0x0206
    135e:	90 91 07 02 	lds	r25, 0x0207
    1362:	01 96       	adiw	r24, 0x01	; 1
    1364:	90 93 07 02 	sts	0x0207, r25
    1368:	80 93 06 02 	sts	0x0206, r24
    136c:	0c c0       	rjmp	.+24     	; 0x1386 <arm+0xa8>
	else if(i==1)
    136e:	c1 30       	cpi	r28, 0x01	; 1
    1370:	d1 05       	cpc	r29, r1
    1372:	49 f4       	brne	.+18     	; 0x1386 <arm+0xa8>
		count2++;
    1374:	80 91 04 02 	lds	r24, 0x0204
    1378:	90 91 05 02 	lds	r25, 0x0205
    137c:	01 96       	adiw	r24, 0x01	; 1
    137e:	90 93 05 02 	sts	0x0205, r25
    1382:	80 93 04 02 	sts	0x0204, r24
	else
		return;
}
    1386:	df 91       	pop	r29
    1388:	cf 91       	pop	r28
    138a:	08 95       	ret

0000138c <rf>:
* Output: void
* Logic: Used to take a ninety degree right turn using the function right_wls and subsequently go forward by the number of nodes specified in the input.Updates current postition in D2.
* Example Call: rf(2); //Takes a right and goes forward by two nodes.
*
*/	void rf(unsigned int node, unsigned int i)
{
    138c:	cf 93       	push	r28
    138e:	df 93       	push	r29
    1390:	c8 2f       	mov	r28, r24
    1392:	d9 2f       	mov	r29, r25
	if(i==0)
    1394:	61 15       	cp	r22, r1
    1396:	71 05       	cpc	r23, r1
    1398:	29 f4       	brne	.+10     	; 0x13a4 <rf+0x18>
	{
		right_degrees(90);
    139a:	8a e5       	ldi	r24, 0x5A	; 90
    139c:	90 e0       	ldi	r25, 0x00	; 0
    139e:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
    13a2:	02 c0       	rjmp	.+4      	; 0x13a8 <rf+0x1c>
	}
	else
	right_wls();_delay_ms(500);
    13a4:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    13a8:	8f ef       	ldi	r24, 0xFF	; 255
    13aa:	9f e7       	ldi	r25, 0x7F	; 127
    13ac:	a6 e1       	ldi	r26, 0x16	; 22
    13ae:	81 50       	subi	r24, 0x01	; 1
    13b0:	90 40       	sbci	r25, 0x00	; 0
    13b2:	a0 40       	sbci	r26, 0x00	; 0
    13b4:	e1 f7       	brne	.-8      	; 0x13ae <rf+0x22>
    13b6:	00 c0       	rjmp	.+0      	; 0x13b8 <rf+0x2c>
    13b8:	00 00       	nop
	forward_wls(node);_delay_ms(500);
    13ba:	8c 2f       	mov	r24, r28
    13bc:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    13c0:	8f ef       	ldi	r24, 0xFF	; 255
    13c2:	9f e7       	ldi	r25, 0x7F	; 127
    13c4:	a6 e1       	ldi	r26, 0x16	; 22
    13c6:	81 50       	subi	r24, 0x01	; 1
    13c8:	90 40       	sbci	r25, 0x00	; 0
    13ca:	a0 40       	sbci	r26, 0x00	; 0
    13cc:	e1 f7       	brne	.-8      	; 0x13c6 <rf+0x3a>
    13ce:	00 c0       	rjmp	.+0      	; 0x13d0 <rf+0x44>
    13d0:	00 00       	nop
	if(flag==2)
    13d2:	80 91 51 02 	lds	r24, 0x0251
    13d6:	82 30       	cpi	r24, 0x02	; 2
    13d8:	51 f4       	brne	.+20     	; 0x13ee <rf+0x62>
	CurPos(0,node,node,0);
    13da:	80 e0       	ldi	r24, 0x00	; 0
    13dc:	90 e0       	ldi	r25, 0x00	; 0
    13de:	6c 2f       	mov	r22, r28
    13e0:	7d 2f       	mov	r23, r29
    13e2:	4c 2f       	mov	r20, r28
    13e4:	5d 2f       	mov	r21, r29
    13e6:	20 e0       	ldi	r18, 0x00	; 0
    13e8:	30 e0       	ldi	r19, 0x00	; 0
    13ea:	0e 94 3a 02 	call	0x474	; 0x474 <CurPos>
}
    13ee:	df 91       	pop	r29
    13f0:	cf 91       	pop	r28
    13f2:	08 95       	ret

000013f4 <lf>:
* Logic: Used to take a ninety degree left turn using the function left_wls and subsequently go forward by the number of nodes specified in the input. Updates current postition in D2.
* Example Call: lf(2); //Takes a left and goes forward by two nodes.
*
*/	
void lf(unsigned int node,int i)
{
    13f4:	cf 93       	push	r28
    13f6:	df 93       	push	r29
    13f8:	c8 2f       	mov	r28, r24
    13fa:	d9 2f       	mov	r29, r25
	if(i==0)
    13fc:	61 15       	cp	r22, r1
    13fe:	71 05       	cpc	r23, r1
    1400:	29 f4       	brne	.+10     	; 0x140c <lf+0x18>
	{
		left_degrees(90);
    1402:	8a e5       	ldi	r24, 0x5A	; 90
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    140a:	02 c0       	rjmp	.+4      	; 0x1410 <lf+0x1c>
	}
	else
	left_wls();_delay_ms(500);
    140c:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    1410:	8f ef       	ldi	r24, 0xFF	; 255
    1412:	9f e7       	ldi	r25, 0x7F	; 127
    1414:	a6 e1       	ldi	r26, 0x16	; 22
    1416:	81 50       	subi	r24, 0x01	; 1
    1418:	90 40       	sbci	r25, 0x00	; 0
    141a:	a0 40       	sbci	r26, 0x00	; 0
    141c:	e1 f7       	brne	.-8      	; 0x1416 <lf+0x22>
    141e:	00 c0       	rjmp	.+0      	; 0x1420 <lf+0x2c>
    1420:	00 00       	nop
	forward_wls(node);_delay_ms(500);
    1422:	8c 2f       	mov	r24, r28
    1424:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    1428:	8f ef       	ldi	r24, 0xFF	; 255
    142a:	9f e7       	ldi	r25, 0x7F	; 127
    142c:	a6 e1       	ldi	r26, 0x16	; 22
    142e:	81 50       	subi	r24, 0x01	; 1
    1430:	90 40       	sbci	r25, 0x00	; 0
    1432:	a0 40       	sbci	r26, 0x00	; 0
    1434:	e1 f7       	brne	.-8      	; 0x142e <lf+0x3a>
    1436:	00 c0       	rjmp	.+0      	; 0x1438 <lf+0x44>
    1438:	00 00       	nop
	if(flag==2)
    143a:	80 91 51 02 	lds	r24, 0x0251
    143e:	82 30       	cpi	r24, 0x02	; 2
    1440:	51 f4       	brne	.+20     	; 0x1456 <lf+0x62>
	CurPos(0,node,0,node);
    1442:	80 e0       	ldi	r24, 0x00	; 0
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	6c 2f       	mov	r22, r28
    1448:	7d 2f       	mov	r23, r29
    144a:	40 e0       	ldi	r20, 0x00	; 0
    144c:	50 e0       	ldi	r21, 0x00	; 0
    144e:	2c 2f       	mov	r18, r28
    1450:	3d 2f       	mov	r19, r29
    1452:	0e 94 3a 02 	call	0x474	; 0x474 <CurPos>
}
    1456:	df 91       	pop	r29
    1458:	cf 91       	pop	r28
    145a:	08 95       	ret

0000145c <Start>:
* Example Call: Start();
*
*/	

void Start(void)
{
    145c:	cf 93       	push	r28
    145e:	df 93       	push	r29
	rf(1,1);
    1460:	81 e0       	ldi	r24, 0x01	; 1
    1462:	90 e0       	ldi	r25, 0x00	; 0
    1464:	61 e0       	ldi	r22, 0x01	; 1
    1466:	70 e0       	ldi	r23, 0x00	; 0
    1468:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    146c:	8f ef       	ldi	r24, 0xFF	; 255
    146e:	9f e7       	ldi	r25, 0x7F	; 127
    1470:	a6 e1       	ldi	r26, 0x16	; 22
    1472:	81 50       	subi	r24, 0x01	; 1
    1474:	90 40       	sbci	r25, 0x00	; 0
    1476:	a0 40       	sbci	r26, 0x00	; 0
    1478:	e1 f7       	brne	.-8      	; 0x1472 <Start+0x16>
    147a:	00 c0       	rjmp	.+0      	; 0x147c <Start+0x20>
    147c:	00 00       	nop
	unsigned int value;
	_delay_ms(500);
	Sensor_read = ADC_Conversion(10);
    147e:	8a e0       	ldi	r24, 0x0A	; 10
    1480:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    1484:	80 93 69 02 	sts	0x0269, r24
	value = Sharp_GP2D12_estimation(Sensor_read);				//Stores Distance calculated in a variable "value".
    1488:	80 91 69 02 	lds	r24, 0x0269
    148c:	0e 94 d7 02 	call	0x5ae	; 0x5ae <Sharp_GP2D12_estimation>
	
	if(150<value&&value<190)
    1490:	9c 01       	movw	r18, r24
    1492:	27 59       	subi	r18, 0x97	; 151
    1494:	30 40       	sbci	r19, 0x00	; 0
    1496:	27 32       	cpi	r18, 0x27	; 39
    1498:	31 05       	cpc	r19, r1
    149a:	88 f4       	brcc	.+34     	; 0x14be <Start+0x62>
	{
		forward_wls(1);
    149c:	81 e0       	ldi	r24, 0x01	; 1
    149e:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
		left_wls();
    14a2:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
		arm(0);
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	90 e0       	ldi	r25, 0x00	; 0
    14aa:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
		left_degrees(90);
    14ae:	8a e5       	ldi	r24, 0x5A	; 90
    14b0:	90 e0       	ldi	r25, 0x00	; 0
    14b2:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
		forward_wls(3);
    14b6:	83 e0       	ldi	r24, 0x03	; 3
    14b8:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    14bc:	2a c0       	rjmp	.+84     	; 0x1512 <Start+0xb6>
	}
	else if(200<value&&value<240)
    14be:	89 5c       	subi	r24, 0xC9	; 201
    14c0:	90 40       	sbci	r25, 0x00	; 0
    14c2:	87 32       	cpi	r24, 0x27	; 39
    14c4:	91 05       	cpc	r25, r1
    14c6:	f0 f4       	brcc	.+60     	; 0x1504 <Start+0xa8>
	{
		
		count1++;
    14c8:	80 91 06 02 	lds	r24, 0x0206
    14cc:	90 91 07 02 	lds	r25, 0x0207
    14d0:	01 96       	adiw	r24, 0x01	; 1
    14d2:	90 93 07 02 	sts	0x0207, r25
    14d6:	80 93 06 02 	sts	0x0206, r24
		buzzer_on();_delay_ms(500);buzzer_off();
    14da:	0e 94 cf 02 	call	0x59e	; 0x59e <buzzer_on>
    14de:	8f ef       	ldi	r24, 0xFF	; 255
    14e0:	9f e7       	ldi	r25, 0x7F	; 127
    14e2:	a6 e1       	ldi	r26, 0x16	; 22
    14e4:	81 50       	subi	r24, 0x01	; 1
    14e6:	90 40       	sbci	r25, 0x00	; 0
    14e8:	a0 40       	sbci	r26, 0x00	; 0
    14ea:	e1 f7       	brne	.-8      	; 0x14e4 <Start+0x88>
    14ec:	00 c0       	rjmp	.+0      	; 0x14ee <Start+0x92>
    14ee:	00 00       	nop
    14f0:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
		right_degrees(180);
    14f4:	84 eb       	ldi	r24, 0xB4	; 180
    14f6:	90 e0       	ldi	r25, 0x00	; 0
    14f8:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
		forward_wls(2);
    14fc:	82 e0       	ldi	r24, 0x02	; 2
    14fe:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    1502:	07 c0       	rjmp	.+14     	; 0x1512 <Start+0xb6>
	}
	else
	{
		right_degrees(180);
    1504:	84 eb       	ldi	r24, 0xB4	; 180
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
		forward_wls(2);
    150c:	82 e0       	ldi	r24, 0x02	; 2
    150e:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    1512:	8f ef       	ldi	r24, 0xFF	; 255
    1514:	9f e7       	ldi	r25, 0x7F	; 127
    1516:	a6 e1       	ldi	r26, 0x16	; 22
    1518:	81 50       	subi	r24, 0x01	; 1
    151a:	90 40       	sbci	r25, 0x00	; 0
    151c:	a0 40       	sbci	r26, 0x00	; 0
    151e:	e1 f7       	brne	.-8      	; 0x1518 <Start+0xbc>
    1520:	00 c0       	rjmp	.+0      	; 0x1522 <Start+0xc6>
    1522:	00 00       	nop
	}
	_delay_ms(500);
	Sensor_read = ADC_Conversion(12);
    1524:	8c e0       	ldi	r24, 0x0C	; 12
    1526:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    152a:	80 93 69 02 	sts	0x0269, r24
	value = Sharp_GP2D12_estimation(Sensor_read);				//Stores Distance calculated in a variable "value".
    152e:	80 91 69 02 	lds	r24, 0x0269
    1532:	0e 94 d7 02 	call	0x5ae	; 0x5ae <Sharp_GP2D12_estimation>
    1536:	ec 01       	movw	r28, r24
	print_sensor(2,4,10);
    1538:	82 e0       	ldi	r24, 0x02	; 2
    153a:	64 e0       	ldi	r22, 0x04	; 4
    153c:	4a e0       	ldi	r20, 0x0A	; 10
    153e:	0e 94 3f 03 	call	0x67e	; 0x67e <print_sensor>
	if(150<value&&value<190)
    1542:	ce 01       	movw	r24, r28
    1544:	87 59       	subi	r24, 0x97	; 151
    1546:	90 40       	sbci	r25, 0x00	; 0
    1548:	87 32       	cpi	r24, 0x27	; 39
    154a:	91 05       	cpc	r25, r1
    154c:	00 f5       	brcc	.+64     	; 0x158e <Start+0x132>
	{
		count1++;
    154e:	80 91 06 02 	lds	r24, 0x0206
    1552:	90 91 07 02 	lds	r25, 0x0207
    1556:	01 96       	adiw	r24, 0x01	; 1
    1558:	90 93 07 02 	sts	0x0207, r25
    155c:	80 93 06 02 	sts	0x0206, r24
		buzzer_on();_delay_ms(500);buzzer_off();
    1560:	0e 94 cf 02 	call	0x59e	; 0x59e <buzzer_on>
    1564:	8f ef       	ldi	r24, 0xFF	; 255
    1566:	9f e7       	ldi	r25, 0x7F	; 127
    1568:	a6 e1       	ldi	r26, 0x16	; 22
    156a:	81 50       	subi	r24, 0x01	; 1
    156c:	90 40       	sbci	r25, 0x00	; 0
    156e:	a0 40       	sbci	r26, 0x00	; 0
    1570:	e1 f7       	brne	.-8      	; 0x156a <Start+0x10e>
    1572:	00 c0       	rjmp	.+0      	; 0x1574 <Start+0x118>
    1574:	00 00       	nop
    1576:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
		right_degrees(180);
    157a:	84 eb       	ldi	r24, 0xB4	; 180
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
		forward_wls(1);
    1582:	81 e0       	ldi	r24, 0x01	; 1
    1584:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
		left_wls();
    1588:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    158c:	21 c0       	rjmp	.+66     	; 0x15d0 <Start+0x174>
		}
	else if(200<value&&value<240)
    158e:	c9 5c       	subi	r28, 0xC9	; 201
    1590:	d0 40       	sbci	r29, 0x00	; 0
    1592:	c7 32       	cpi	r28, 0x27	; 39
    1594:	d1 05       	cpc	r29, r1
    1596:	98 f4       	brcc	.+38     	; 0x15be <Start+0x162>
	{
		forward_wls(1);
    1598:	81 e0       	ldi	r24, 0x01	; 1
    159a:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
		right_wls();
    159e:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
		arm(0);
    15a2:	80 e0       	ldi	r24, 0x00	; 0
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
		right_degrees(90);
    15aa:	8a e5       	ldi	r24, 0x5A	; 90
    15ac:	90 e0       	ldi	r25, 0x00	; 0
    15ae:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
		forward_wls(1);
    15b2:	81 e0       	ldi	r24, 0x01	; 1
    15b4:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
		left_wls();
    15b8:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    15bc:	09 c0       	rjmp	.+18     	; 0x15d0 <Start+0x174>
	}
	else
	{
		right_degrees(180);
    15be:	84 eb       	ldi	r24, 0xB4	; 180
    15c0:	90 e0       	ldi	r25, 0x00	; 0
    15c2:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
		forward_wls(1);
    15c6:	81 e0       	ldi	r24, 0x01	; 1
    15c8:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
		left_wls();
    15cc:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
	
	}
	Cur_Pos[0]=2;
    15d0:	82 e0       	ldi	r24, 0x02	; 2
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	90 93 01 02 	sts	0x0201, r25
    15d8:	80 93 00 02 	sts	0x0200, r24
	Cur_Pos[1]=0;
    15dc:	10 92 03 02 	sts	0x0203, r1
    15e0:	10 92 02 02 	sts	0x0202, r1
}
    15e4:	df 91       	pop	r29
    15e6:	cf 91       	pop	r28
    15e8:	08 95       	ret

000015ea <IRCorridor>:
*/	
void IRCorridor(void)
{	unsigned int IR_1,IR_3,IR_5;
	unsigned int flag5=0;
	unsigned int flag6=0;
	turn_on_ir_proxi_sensors();
    15ea:	0e 94 04 04 	call	0x808	; 0x808 <turn_on_ir_proxi_sensors>
	ShaftCountRight=0;
    15ee:	10 92 52 02 	sts	0x0252, r1
    15f2:	10 92 53 02 	sts	0x0253, r1
    15f6:	10 92 54 02 	sts	0x0254, r1
    15fa:	10 92 55 02 	sts	0x0255, r1
	forward_wls(1);
    15fe:	81 e0       	ldi	r24, 0x01	; 1
    1600:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
*
*/	
void IRCorridor(void)
{	unsigned int IR_1,IR_3,IR_5;
	unsigned int flag5=0;
	unsigned int flag6=0;
    1604:	ee 24       	eor	r14, r14
    1606:	ff 24       	eor	r15, r15
* Example Call: IRCorridor();
*
*/	
void IRCorridor(void)
{	unsigned int IR_1,IR_3,IR_5;
	unsigned int flag5=0;
    1608:	cc 24       	eor	r12, r12
    160a:	dd 24       	eor	r13, r13
		IR_3=ADC_Conversion(6);//ADC conversion initializations
		forward();
		velocity(225,225);
		if ( (IR_3<= 130) && flag6==0) // checks whether IR proximity is less than 130 mm., and stops if obstacle is detected.
		{	
			flag6=1;
    160c:	aa 24       	eor	r10, r10
    160e:	bb 24       	eor	r11, r11
    1610:	a3 94       	inc	r10
	turn_on_ir_proxi_sensors();
	ShaftCountRight=0;
	forward_wls(1);
	while(1)
	{
		IR_1=ADC_Conversion(4);//ADC conversion initializations
    1612:	84 e0       	ldi	r24, 0x04	; 4
    1614:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    1618:	08 2f       	mov	r16, r24
		IR_5=ADC_Conversion(8);//ADC conversion initializations
    161a:	88 e0       	ldi	r24, 0x08	; 8
    161c:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    1620:	c8 2f       	mov	r28, r24
    1622:	d0 e0       	ldi	r29, 0x00	; 0
		IR_3=ADC_Conversion(6);//ADC conversion initializations
    1624:	86 e0       	ldi	r24, 0x06	; 6
    1626:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    162a:	18 2f       	mov	r17, r24
		forward();
    162c:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
		velocity(225,225);
    1630:	81 ee       	ldi	r24, 0xE1	; 225
    1632:	61 ee       	ldi	r22, 0xE1	; 225
    1634:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
		if ( (IR_3<= 130) && flag6==0) // checks whether IR proximity is less than 130 mm., and stops if obstacle is detected.
    1638:	13 38       	cpi	r17, 0x83	; 131
    163a:	40 f5       	brcc	.+80     	; 0x168c <IRCorridor+0xa2>
    163c:	e1 14       	cp	r14, r1
    163e:	f1 04       	cpc	r15, r1
    1640:	29 f5       	brne	.+74     	; 0x168c <IRCorridor+0xa2>
		{	
			flag6=1;
			flag5=1;
			forward();
    1642:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(0,0);     
    1646:	80 e0       	ldi	r24, 0x00	; 0
    1648:	60 e0       	ldi	r22, 0x00	; 0
    164a:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
    164e:	8f ef       	ldi	r24, 0xFF	; 255
    1650:	9f e7       	ldi	r25, 0x7F	; 127
    1652:	a6 e1       	ldi	r26, 0x16	; 22
    1654:	81 50       	subi	r24, 0x01	; 1
    1656:	90 40       	sbci	r25, 0x00	; 0
    1658:	a0 40       	sbci	r26, 0x00	; 0
    165a:	e1 f7       	brne	.-8      	; 0x1654 <IRCorridor+0x6a>
    165c:	00 c0       	rjmp	.+0      	; 0x165e <IRCorridor+0x74>
    165e:	00 00       	nop
			_delay_ms(500);
			velocity(225,225);
    1660:	81 ee       	ldi	r24, 0xE1	; 225
    1662:	61 ee       	ldi	r22, 0xE1	; 225
    1664:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
			left_degrees(90);
    1668:	8a e5       	ldi	r24, 0x5A	; 90
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
			stop();
    1670:	0e 94 67 04 	call	0x8ce	; 0x8ce <stop>
    1674:	8f ef       	ldi	r24, 0xFF	; 255
    1676:	9f e7       	ldi	r25, 0x7F	; 127
    1678:	a6 e1       	ldi	r26, 0x16	; 22
    167a:	81 50       	subi	r24, 0x01	; 1
    167c:	90 40       	sbci	r25, 0x00	; 0
    167e:	a0 40       	sbci	r26, 0x00	; 0
    1680:	e1 f7       	brne	.-8      	; 0x167a <IRCorridor+0x90>
    1682:	00 c0       	rjmp	.+0      	; 0x1684 <IRCorridor+0x9a>
    1684:	00 00       	nop
		IR_3=ADC_Conversion(6);//ADC conversion initializations
		forward();
		velocity(225,225);
		if ( (IR_3<= 130) && flag6==0) // checks whether IR proximity is less than 130 mm., and stops if obstacle is detected.
		{	
			flag6=1;
    1686:	75 01       	movw	r14, r10
			flag5=1;
    1688:	65 01       	movw	r12, r10
    168a:	c3 cf       	rjmp	.-122    	; 0x1612 <IRCorridor+0x28>
			stop();
			_delay_ms(500);
			
			
		}
		else if(( IR_5>=154 ) && flag5==1 && flag6==1)  //checks whether right  IR proxmity is greater than 154 if true , turns right.
    168c:	ca 39       	cpi	r28, 0x9A	; 154
    168e:	d1 05       	cpc	r29, r1
    1690:	e0 f1       	brcs	.+120    	; 0x170a <IRCorridor+0x120>
    1692:	91 e0       	ldi	r25, 0x01	; 1
    1694:	c9 16       	cp	r12, r25
    1696:	d1 04       	cpc	r13, r1
    1698:	c1 f5       	brne	.+112    	; 0x170a <IRCorridor+0x120>
    169a:	a1 e0       	ldi	r26, 0x01	; 1
    169c:	ea 16       	cp	r14, r26
    169e:	f1 04       	cpc	r15, r1
    16a0:	a1 f5       	brne	.+104    	; 0x170a <IRCorridor+0x120>
    16a2:	86 e6       	ldi	r24, 0x66	; 102
    16a4:	96 e2       	ldi	r25, 0x26	; 38
    16a6:	a7 e2       	ldi	r26, 0x27	; 39
    16a8:	81 50       	subi	r24, 0x01	; 1
    16aa:	90 40       	sbci	r25, 0x00	; 0
    16ac:	a0 40       	sbci	r26, 0x00	; 0
    16ae:	e1 f7       	brne	.-8      	; 0x16a8 <IRCorridor+0xbe>
		{ 
			_delay_ms(870);
			forward();
    16b0:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(0,0);
    16b4:	80 e0       	ldi	r24, 0x00	; 0
    16b6:	60 e0       	ldi	r22, 0x00	; 0
    16b8:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
    16bc:	8f ef       	ldi	r24, 0xFF	; 255
    16be:	9f e7       	ldi	r25, 0x7F	; 127
    16c0:	a6 e1       	ldi	r26, 0x16	; 22
    16c2:	81 50       	subi	r24, 0x01	; 1
    16c4:	90 40       	sbci	r25, 0x00	; 0
    16c6:	a0 40       	sbci	r26, 0x00	; 0
    16c8:	e1 f7       	brne	.-8      	; 0x16c2 <IRCorridor+0xd8>
    16ca:	00 c0       	rjmp	.+0      	; 0x16cc <IRCorridor+0xe2>
    16cc:	00 00       	nop
			_delay_ms(500);
			velocity(225,225);
    16ce:	81 ee       	ldi	r24, 0xE1	; 225
    16d0:	61 ee       	ldi	r22, 0xE1	; 225
    16d2:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
			right_degrees(90);
    16d6:	8a e5       	ldi	r24, 0x5A	; 90
    16d8:	90 e0       	ldi	r25, 0x00	; 0
    16da:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
			flag5=1;
			forward_mm(150);
    16de:	86 e9       	ldi	r24, 0x96	; 150
    16e0:	90 e0       	ldi	r25, 0x00	; 0
    16e2:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <forward_mm>
			velocity(220,220);
    16e6:	8c ed       	ldi	r24, 0xDC	; 220
    16e8:	6c ed       	ldi	r22, 0xDC	; 220
    16ea:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
		{   forward();
			velocity(220,150);
		}											
	}
		 // Cases for calculation of distance travelled by the robot for determination of gate through which the robot enters d2.
		if(88<ShaftCountRight&&ShaftCountRight<97)
    16ee:	80 91 52 02 	lds	r24, 0x0252
    16f2:	90 91 53 02 	lds	r25, 0x0253
    16f6:	a0 91 54 02 	lds	r26, 0x0254
    16fa:	b0 91 55 02 	lds	r27, 0x0255
    16fe:	89 35       	cpi	r24, 0x59	; 89
    1700:	91 05       	cpc	r25, r1
    1702:	a1 05       	cpc	r26, r1
    1704:	b1 05       	cpc	r27, r1
    1706:	38 f5       	brcc	.+78     	; 0x1756 <IRCorridor+0x16c>
    1708:	3e c0       	rjmp	.+124    	; 0x1786 <IRCorridor+0x19c>
			forward_mm(150);
			velocity(220,220);
			break;
		}
		//avoiding collision with the walls
		else if(IR_5<143 && flag6==1 && flag5==1)  
    170a:	cf 38       	cpi	r28, 0x8F	; 143
    170c:	d1 05       	cpc	r29, r1
    170e:	78 f4       	brcc	.+30     	; 0x172e <IRCorridor+0x144>
    1710:	91 e0       	ldi	r25, 0x01	; 1
    1712:	e9 16       	cp	r14, r25
    1714:	f1 04       	cpc	r15, r1
    1716:	59 f4       	brne	.+22     	; 0x172e <IRCorridor+0x144>
    1718:	a1 e0       	ldi	r26, 0x01	; 1
    171a:	ca 16       	cp	r12, r26
    171c:	d1 04       	cpc	r13, r1
    171e:	39 f4       	brne	.+14     	; 0x172e <IRCorridor+0x144>
		{
			forward();
    1720:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(150,220);
    1724:	86 e9       	ldi	r24, 0x96	; 150
    1726:	6c ed       	ldi	r22, 0xDC	; 220
    1728:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
    172c:	72 cf       	rjmp	.-284    	; 0x1612 <IRCorridor+0x28>
		}
		else if (IR_1< 143 && flag6==1 && flag5==1)
    172e:	0f 38       	cpi	r16, 0x8F	; 143
    1730:	08 f0       	brcs	.+2      	; 0x1734 <IRCorridor+0x14a>
    1732:	6f cf       	rjmp	.-290    	; 0x1612 <IRCorridor+0x28>
    1734:	b1 e0       	ldi	r27, 0x01	; 1
    1736:	eb 16       	cp	r14, r27
    1738:	f1 04       	cpc	r15, r1
    173a:	09 f0       	breq	.+2      	; 0x173e <IRCorridor+0x154>
    173c:	6a cf       	rjmp	.-300    	; 0x1612 <IRCorridor+0x28>
    173e:	81 e0       	ldi	r24, 0x01	; 1
    1740:	c8 16       	cp	r12, r24
    1742:	d1 04       	cpc	r13, r1
    1744:	09 f0       	breq	.+2      	; 0x1748 <IRCorridor+0x15e>
    1746:	65 cf       	rjmp	.-310    	; 0x1612 <IRCorridor+0x28>
		{   forward();
    1748:	0e 94 57 04 	call	0x8ae	; 0x8ae <forward>
			velocity(220,150);
    174c:	8c ed       	ldi	r24, 0xDC	; 220
    174e:	66 e9       	ldi	r22, 0x96	; 150
    1750:	0e 94 8c 02 	call	0x518	; 0x518 <velocity>
    1754:	5e cf       	rjmp	.-324    	; 0x1612 <IRCorridor+0x28>
		}											
	}
		 // Cases for calculation of distance travelled by the robot for determination of gate through which the robot enters d2.
		if(88<ShaftCountRight&&ShaftCountRight<97)
    1756:	80 91 52 02 	lds	r24, 0x0252
    175a:	90 91 53 02 	lds	r25, 0x0253
    175e:	a0 91 54 02 	lds	r26, 0x0254
    1762:	b0 91 55 02 	lds	r27, 0x0255
    1766:	81 36       	cpi	r24, 0x61	; 97
    1768:	91 05       	cpc	r25, r1
    176a:	a1 05       	cpc	r26, r1
    176c:	b1 05       	cpc	r27, r1
    176e:	58 f4       	brcc	.+22     	; 0x1786 <IRCorridor+0x19c>
		{
			Cur_Pos[0]=0;
    1770:	10 92 01 02 	sts	0x0201, r1
    1774:	10 92 00 02 	sts	0x0200, r1
			Cur_Pos[1]=5;
    1778:	85 e0       	ldi	r24, 0x05	; 5
    177a:	90 e0       	ldi	r25, 0x00	; 0
    177c:	90 93 03 02 	sts	0x0203, r25
    1780:	80 93 02 02 	sts	0x0202, r24
    1784:	94 c0       	rjmp	.+296    	; 0x18ae <IRCorridor+0x2c4>
		}
		else if(125<ShaftCountRight&&ShaftCountRight<143)
    1786:	80 91 52 02 	lds	r24, 0x0252
    178a:	90 91 53 02 	lds	r25, 0x0253
    178e:	a0 91 54 02 	lds	r26, 0x0254
    1792:	b0 91 55 02 	lds	r27, 0x0255
    1796:	8e 37       	cpi	r24, 0x7E	; 126
    1798:	91 05       	cpc	r25, r1
    179a:	a1 05       	cpc	r26, r1
    179c:	b1 05       	cpc	r27, r1
    179e:	c0 f0       	brcs	.+48     	; 0x17d0 <IRCorridor+0x1e6>
    17a0:	80 91 52 02 	lds	r24, 0x0252
    17a4:	90 91 53 02 	lds	r25, 0x0253
    17a8:	a0 91 54 02 	lds	r26, 0x0254
    17ac:	b0 91 55 02 	lds	r27, 0x0255
    17b0:	8f 38       	cpi	r24, 0x8F	; 143
    17b2:	91 05       	cpc	r25, r1
    17b4:	a1 05       	cpc	r26, r1
    17b6:	b1 05       	cpc	r27, r1
    17b8:	58 f4       	brcc	.+22     	; 0x17d0 <IRCorridor+0x1e6>
		{
			Cur_Pos[0]=0;
    17ba:	10 92 01 02 	sts	0x0201, r1
    17be:	10 92 00 02 	sts	0x0200, r1
			Cur_Pos[1]=4;
    17c2:	84 e0       	ldi	r24, 0x04	; 4
    17c4:	90 e0       	ldi	r25, 0x00	; 0
    17c6:	90 93 03 02 	sts	0x0203, r25
    17ca:	80 93 02 02 	sts	0x0202, r24
    17ce:	6f c0       	rjmp	.+222    	; 0x18ae <IRCorridor+0x2c4>
		}
		else if(162<ShaftCountRight&&ShaftCountRight<181)
    17d0:	80 91 52 02 	lds	r24, 0x0252
    17d4:	90 91 53 02 	lds	r25, 0x0253
    17d8:	a0 91 54 02 	lds	r26, 0x0254
    17dc:	b0 91 55 02 	lds	r27, 0x0255
    17e0:	83 3a       	cpi	r24, 0xA3	; 163
    17e2:	91 05       	cpc	r25, r1
    17e4:	a1 05       	cpc	r26, r1
    17e6:	b1 05       	cpc	r27, r1
    17e8:	c0 f0       	brcs	.+48     	; 0x181a <IRCorridor+0x230>
    17ea:	80 91 52 02 	lds	r24, 0x0252
    17ee:	90 91 53 02 	lds	r25, 0x0253
    17f2:	a0 91 54 02 	lds	r26, 0x0254
    17f6:	b0 91 55 02 	lds	r27, 0x0255
    17fa:	85 3b       	cpi	r24, 0xB5	; 181
    17fc:	91 05       	cpc	r25, r1
    17fe:	a1 05       	cpc	r26, r1
    1800:	b1 05       	cpc	r27, r1
    1802:	58 f4       	brcc	.+22     	; 0x181a <IRCorridor+0x230>
		{
			Cur_Pos[0]=0;
    1804:	10 92 01 02 	sts	0x0201, r1
    1808:	10 92 00 02 	sts	0x0200, r1
			Cur_Pos[1]=3;
    180c:	83 e0       	ldi	r24, 0x03	; 3
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	90 93 03 02 	sts	0x0203, r25
    1814:	80 93 02 02 	sts	0x0202, r24
    1818:	4a c0       	rjmp	.+148    	; 0x18ae <IRCorridor+0x2c4>
		}
		else if(200<ShaftCountRight&&ShaftCountRight<218)
    181a:	80 91 52 02 	lds	r24, 0x0252
    181e:	90 91 53 02 	lds	r25, 0x0253
    1822:	a0 91 54 02 	lds	r26, 0x0254
    1826:	b0 91 55 02 	lds	r27, 0x0255
    182a:	89 3c       	cpi	r24, 0xC9	; 201
    182c:	91 05       	cpc	r25, r1
    182e:	a1 05       	cpc	r26, r1
    1830:	b1 05       	cpc	r27, r1
    1832:	c0 f0       	brcs	.+48     	; 0x1864 <IRCorridor+0x27a>
    1834:	80 91 52 02 	lds	r24, 0x0252
    1838:	90 91 53 02 	lds	r25, 0x0253
    183c:	a0 91 54 02 	lds	r26, 0x0254
    1840:	b0 91 55 02 	lds	r27, 0x0255
    1844:	8a 3d       	cpi	r24, 0xDA	; 218
    1846:	91 05       	cpc	r25, r1
    1848:	a1 05       	cpc	r26, r1
    184a:	b1 05       	cpc	r27, r1
    184c:	58 f4       	brcc	.+22     	; 0x1864 <IRCorridor+0x27a>
		{
			Cur_Pos[0]=0;
    184e:	10 92 01 02 	sts	0x0201, r1
    1852:	10 92 00 02 	sts	0x0200, r1
			Cur_Pos[1]=2;
    1856:	82 e0       	ldi	r24, 0x02	; 2
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	90 93 03 02 	sts	0x0203, r25
    185e:	80 93 02 02 	sts	0x0202, r24
    1862:	25 c0       	rjmp	.+74     	; 0x18ae <IRCorridor+0x2c4>
		}
		else if(237<ShaftCountRight&&ShaftCountRight<256)
    1864:	80 91 52 02 	lds	r24, 0x0252
    1868:	90 91 53 02 	lds	r25, 0x0253
    186c:	a0 91 54 02 	lds	r26, 0x0254
    1870:	b0 91 55 02 	lds	r27, 0x0255
    1874:	8e 3e       	cpi	r24, 0xEE	; 238
    1876:	91 05       	cpc	r25, r1
    1878:	a1 05       	cpc	r26, r1
    187a:	b1 05       	cpc	r27, r1
    187c:	c0 f0       	brcs	.+48     	; 0x18ae <IRCorridor+0x2c4>
    187e:	80 91 52 02 	lds	r24, 0x0252
    1882:	90 91 53 02 	lds	r25, 0x0253
    1886:	a0 91 54 02 	lds	r26, 0x0254
    188a:	b0 91 55 02 	lds	r27, 0x0255
    188e:	8f 3f       	cpi	r24, 0xFF	; 255
    1890:	91 05       	cpc	r25, r1
    1892:	a1 05       	cpc	r26, r1
    1894:	b1 05       	cpc	r27, r1
    1896:	09 f0       	breq	.+2      	; 0x189a <IRCorridor+0x2b0>
    1898:	50 f4       	brcc	.+20     	; 0x18ae <IRCorridor+0x2c4>
		{
			Cur_Pos[0]=0;
    189a:	10 92 01 02 	sts	0x0201, r1
    189e:	10 92 00 02 	sts	0x0200, r1
			Cur_Pos[1]=1;
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	90 e0       	ldi	r25, 0x00	; 0
    18a6:	90 93 03 02 	sts	0x0203, r25
    18aa:	80 93 02 02 	sts	0x0202, r24
		}
		buzzer_on();
    18ae:	0e 94 cf 02 	call	0x59e	; 0x59e <buzzer_on>
    18b2:	8f ef       	ldi	r24, 0xFF	; 255
    18b4:	9f ef       	ldi	r25, 0xFF	; 255
    18b6:	ac e2       	ldi	r26, 0x2C	; 44
    18b8:	81 50       	subi	r24, 0x01	; 1
    18ba:	90 40       	sbci	r25, 0x00	; 0
    18bc:	a0 40       	sbci	r26, 0x00	; 0
    18be:	e1 f7       	brne	.-8      	; 0x18b8 <IRCorridor+0x2ce>
    18c0:	00 c0       	rjmp	.+0      	; 0x18c2 <IRCorridor+0x2d8>
    18c2:	00 00       	nop
		_delay_ms(1000);
		buzzer_off();							//Buzzer at end of Corridor and start of D2
    18c4:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
	forward_wls(1);				//Following code takes the robot to position H7 and updates Cur_Pos accordingly. 
    18c8:	81 e0       	ldi	r24, 0x01	; 1
    18ca:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
	Cur_Pos[1]-=1;
    18ce:	80 91 02 02 	lds	r24, 0x0202
    18d2:	90 91 03 02 	lds	r25, 0x0203
    18d6:	01 97       	sbiw	r24, 0x01	; 1
    18d8:	90 93 03 02 	sts	0x0203, r25
    18dc:	80 93 02 02 	sts	0x0202, r24
	left_wls();
    18e0:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
	forward_wls(Cur_Pos[1]-1);
    18e4:	80 91 02 02 	lds	r24, 0x0202
    18e8:	90 91 03 02 	lds	r25, 0x0203
    18ec:	81 50       	subi	r24, 0x01	; 1
    18ee:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
	Cur_Pos[1]=0;
    18f2:	10 92 03 02 	sts	0x0203, r1
    18f6:	10 92 02 02 	sts	0x0202, r1
	flag=2;
    18fa:	82 e0       	ldi	r24, 0x02	; 2
    18fc:	80 93 51 02 	sts	0x0251, r24
	int i,j;
	for(i=0; i<8; i++)				//Re-initializes the array for D2 storage
	{
		for(j=0; i<6; j++)
    1900:	80 e0       	ldi	r24, 0x00	; 0
    1902:	90 e0       	ldi	r25, 0x00	; 0
		{
			Blk_Pos[i][j]=0;
    1904:	28 e0       	ldi	r18, 0x08	; 8
    1906:	32 e0       	ldi	r19, 0x02	; 2
    1908:	fc 01       	movw	r30, r24
    190a:	ee 0f       	add	r30, r30
    190c:	ff 1f       	adc	r31, r31
    190e:	e2 0f       	add	r30, r18
    1910:	f3 1f       	adc	r31, r19
    1912:	11 82       	std	Z+1, r1	; 0x01
    1914:	10 82       	st	Z, r1
	Cur_Pos[1]=0;
	flag=2;
	int i,j;
	for(i=0; i<8; i++)				//Re-initializes the array for D2 storage
	{
		for(j=0; i<6; j++)
    1916:	01 96       	adiw	r24, 0x01	; 1
    1918:	f7 cf       	rjmp	.-18     	; 0x1908 <IRCorridor+0x31e>

0000191a <exit1>:
* Logic: Called on row 1 for exiting D1 or when count exceeds six(Maximum number of blocks in D1). Takes appropriate exit route according to current position and block positions.* Example Call: <Example of how to call this function>
* Example Call: exit1();
*
*/	
void exit1(int i)
{
    191a:	bc 01       	movw	r22, r24
	if(Cur_Pos[1]==5)																			//If block is on row 2
    191c:	80 91 02 02 	lds	r24, 0x0202
    1920:	90 91 03 02 	lds	r25, 0x0203
    1924:	85 30       	cpi	r24, 0x05	; 5
    1926:	91 05       	cpc	r25, r1
    1928:	81 f5       	brne	.+96     	; 0x198a <exit1+0x70>
	{
		if(Blk_Pos[5][3]==0)																	//Checks whether D2 is empty, if yes, exits directly.
    192a:	80 91 40 02 	lds	r24, 0x0240
    192e:	90 91 41 02 	lds	r25, 0x0241
    1932:	00 97       	sbiw	r24, 0x00	; 0
    1934:	71 f4       	brne	.+28     	; 0x1952 <exit1+0x38>
		{
				lf(5-Cur_Pos[0], i);															//Goes left to reach node E2.
    1936:	20 91 00 02 	lds	r18, 0x0200
    193a:	30 91 01 02 	lds	r19, 0x0201
    193e:	85 e0       	ldi	r24, 0x05	; 5
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	82 1b       	sub	r24, r18
    1944:	93 0b       	sbc	r25, r19
    1946:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
						flag=2;																				//Sets flag to 2 indicating end of D1.
    194a:	82 e0       	ldi	r24, 0x02	; 2
    194c:	80 93 51 02 	sts	0x0251, r24
    1950:	35 c0       	rjmp	.+106    	; 0x19bc <exit1+0xa2>
		}
		else if(Blk_Pos[5][3]==1)																// If not empty it goes round D2
    1952:	80 91 40 02 	lds	r24, 0x0240
    1956:	90 91 41 02 	lds	r25, 0x0241
    195a:	81 30       	cpi	r24, 0x01	; 1
    195c:	91 05       	cpc	r25, r1
    195e:	71 f5       	brne	.+92     	; 0x19bc <exit1+0xa2>
		{
			forward_wls(1);
    1960:	81 e0       	ldi	r24, 0x01	; 1
    1962:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
			lf(2, 1);
    1966:	82 e0       	ldi	r24, 0x02	; 2
    1968:	90 e0       	ldi	r25, 0x00	; 0
    196a:	61 e0       	ldi	r22, 0x01	; 1
    196c:	70 e0       	ldi	r23, 0x00	; 0
    196e:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
			lf(1, 1);
    1972:	81 e0       	ldi	r24, 0x01	; 1
    1974:	90 e0       	ldi	r25, 0x00	; 0
    1976:	61 e0       	ldi	r22, 0x01	; 1
    1978:	70 e0       	ldi	r23, 0x00	; 0
    197a:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
			right_wls();
    197e:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
			flag=2;
    1982:	82 e0       	ldi	r24, 0x02	; 2
    1984:	80 93 51 02 	sts	0x0251, r24
    1988:	19 c0       	rjmp	.+50     	; 0x19bc <exit1+0xa2>

		}
	}
	else if(Cur_Pos[1]==6)
    198a:	80 91 02 02 	lds	r24, 0x0202
    198e:	90 91 03 02 	lds	r25, 0x0203
    1992:	86 30       	cpi	r24, 0x06	; 6
    1994:	91 05       	cpc	r25, r1
    1996:	91 f4       	brne	.+36     	; 0x19bc <exit1+0xa2>
	{
		
						lf(4-Cur_Pos[0], i);
    1998:	20 91 00 02 	lds	r18, 0x0200
    199c:	30 91 01 02 	lds	r19, 0x0201
    19a0:	84 e0       	ldi	r24, 0x04	; 4
    19a2:	90 e0       	ldi	r25, 0x00	; 0
    19a4:	82 1b       	sub	r24, r18
    19a6:	93 0b       	sbc	r25, r19
    19a8:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
						left_wls();
    19ac:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
						forward_wls(1);
    19b0:	81 e0       	ldi	r24, 0x01	; 1
    19b2:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
						flag=2;
    19b6:	82 e0       	ldi	r24, 0x02	; 2
    19b8:	80 93 51 02 	sts	0x0251, r24
	}
	buzzer_on();_delay_ms(1000);buzzer_off();					//Buzzer at end of D1
    19bc:	0e 94 cf 02 	call	0x59e	; 0x59e <buzzer_on>
    19c0:	8f ef       	ldi	r24, 0xFF	; 255
    19c2:	9f ef       	ldi	r25, 0xFF	; 255
    19c4:	ac e2       	ldi	r26, 0x2C	; 44
    19c6:	81 50       	subi	r24, 0x01	; 1
    19c8:	90 40       	sbci	r25, 0x00	; 0
    19ca:	a0 40       	sbci	r26, 0x00	; 0
    19cc:	e1 f7       	brne	.-8      	; 0x19c6 <exit1+0xac>
    19ce:	00 c0       	rjmp	.+0      	; 0x19d0 <exit1+0xb6>
    19d0:	00 00       	nop
    19d2:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>

}
    19d6:	08 95       	ret

000019d8 <exit2>:
* Example Call: exit2();
*	
*/	
void exit2(void)
{
	forward_wls(6-Cur_Pos[1]);	//Goes forward from current row position to row 1.
    19d8:	20 91 02 02 	lds	r18, 0x0202
    19dc:	30 91 03 02 	lds	r19, 0x0203
    19e0:	86 e0       	ldi	r24, 0x06	; 6
    19e2:	82 1b       	sub	r24, r18
    19e4:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
	lf(4-Cur_Pos[0], 1);			//Goes left from current column to column I.
    19e8:	20 91 00 02 	lds	r18, 0x0200
    19ec:	30 91 01 02 	lds	r19, 0x0201
    19f0:	84 e0       	ldi	r24, 0x04	; 4
    19f2:	90 e0       	ldi	r25, 0x00	; 0
    19f4:	82 1b       	sub	r24, r18
    19f6:	93 0b       	sbc	r25, r19
    19f8:	61 e0       	ldi	r22, 0x01	; 1
    19fa:	70 e0       	ldi	r23, 0x00	; 0
    19fc:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
	flag=3;
    1a00:	83 e0       	ldi	r24, 0x03	; 3
    1a02:	80 93 51 02 	sts	0x0251, r24
	buzzer_on();_delay_ms(5000);buzzer_off();
    1a06:	0e 94 cf 02 	call	0x59e	; 0x59e <buzzer_on>
    1a0a:	8f ef       	ldi	r24, 0xFF	; 255
    1a0c:	9f ef       	ldi	r25, 0xFF	; 255
    1a0e:	a0 ee       	ldi	r26, 0xE0	; 224
    1a10:	81 50       	subi	r24, 0x01	; 1
    1a12:	90 40       	sbci	r25, 0x00	; 0
    1a14:	a0 40       	sbci	r26, 0x00	; 0
    1a16:	e1 f7       	brne	.-8      	; 0x1a10 <exit2+0x38>
    1a18:	00 c0       	rjmp	.+0      	; 0x1a1a <exit2+0x42>
    1a1a:	00 00       	nop
    1a1c:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
}
    1a20:	08 95       	ret

00001a22 <D1>:
* Logic: Function for sorting blocks in D1
* Example Call: D1();
*	
*/
void D1(void)
{
    1a22:	cf 92       	push	r12
    1a24:	df 92       	push	r13
    1a26:	ff 92       	push	r15
    1a28:	0f 93       	push	r16
    1a2a:	1f 93       	push	r17
    1a2c:	cf 93       	push	r28
    1a2e:	df 93       	push	r29
			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
			if(flag==0) // Flag is set to zero initially, when this state occurs 
			{
				if(Cur_Pos[1]==0)
    1a30:	02 e0       	ldi	r16, 0x02	; 2
    1a32:	12 e0       	ldi	r17, 0x02	; 2
						}					
					}
			else
			{
				/*Actual Buzzer sound*/buzzer_on();_delay_ms(1000);buzzer_off();
				forward_wls(5-Cur_Pos[0]);
    1a34:	c0 e0       	ldi	r28, 0x00	; 0
    1a36:	d2 e0       	ldi	r29, 0x02	; 2
    1a38:	0f 2e       	mov	r0, r31
    1a3a:	f5 e0       	ldi	r31, 0x05	; 5
    1a3c:	ff 2e       	mov	r15, r31
    1a3e:	f0 2d       	mov	r31, r0
							
							
							if(count1<7)
							{
							unsigned short int tmp=Cur_Pos[1]+1;				//Stores value of next row, in order to reduce execution time when accessing block position.
								if(Blk_Pos[tmp][0]==0)							// Checks if block position at column A in the next row is zero. Proceeds to check in the next columns in order to determine the exact configuration of the blocks in the next row.  
    1a40:	0f 2e       	mov	r0, r31
    1a42:	f8 e0       	ldi	r31, 0x08	; 8
    1a44:	cf 2e       	mov	r12, r31
    1a46:	f2 e0       	ldi	r31, 0x02	; 2
    1a48:	df 2e       	mov	r13, r31
    1a4a:	f0 2d       	mov	r31, r0
void D1(void)
{
		while(1)
		
		{
			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    1a4c:	83 e0       	ldi	r24, 0x03	; 3
    1a4e:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    1a52:	80 93 50 02 	sts	0x0250, r24
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    1a56:	82 e0       	ldi	r24, 0x02	; 2
    1a58:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    1a5c:	80 93 4f 02 	sts	0x024F, r24
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    1a60:	81 e0       	ldi	r24, 0x01	; 1
    1a62:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    1a66:	80 93 4e 02 	sts	0x024E, r24
			if(flag==0) // Flag is set to zero initially, when this state occurs 
    1a6a:	20 91 51 02 	lds	r18, 0x0251
    1a6e:	22 23       	and	r18, r18
    1a70:	e9 f4       	brne	.+58     	; 0x1aac <D1+0x8a>
			{
				if(Cur_Pos[1]==0)
    1a72:	d8 01       	movw	r26, r16
    1a74:	8d 91       	ld	r24, X+
    1a76:	9c 91       	ld	r25, X
    1a78:	11 97       	sbiw	r26, 0x01	; 1
    1a7a:	00 97       	sbiw	r24, 0x00	; 0
    1a7c:	b9 f4       	brne	.+46     	; 0x1aac <D1+0x8a>
						{
							
							forward_wls(1);				//Goes forward from START position.
    1a7e:	81 e0       	ldi	r24, 0x01	; 1
    1a80:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
							Cur_Pos[1]=0;				//Sets y co-ordinate to row 7.
    1a84:	f8 01       	movw	r30, r16
    1a86:	11 82       	std	Z+1, r1	; 0x01
    1a88:	10 82       	st	Z, r1
							Sharp_Detection();_delay_ms(500); //For detection of blocks at B6 and D6.
    1a8a:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    1a8e:	8f ef       	ldi	r24, 0xFF	; 255
    1a90:	9f e7       	ldi	r25, 0x7F	; 127
    1a92:	a6 e1       	ldi	r26, 0x16	; 22
    1a94:	81 50       	subi	r24, 0x01	; 1
    1a96:	90 40       	sbci	r25, 0x00	; 0
    1a98:	a0 40       	sbci	r26, 0x00	; 0
    1a9a:	e1 f7       	brne	.-8      	; 0x1a94 <D1+0x72>
    1a9c:	00 c0       	rjmp	.+0      	; 0x1a9e <D1+0x7c>
    1a9e:	00 00       	nop
							Start();					//Runs Start function as it is a special case where A6 and E6 are blind spots.
    1aa0:	0e 94 2e 0a 	call	0x145c	; 0x145c <Start>
							flag=1;						//Sets flag to 1 to indicate end of special case
    1aa4:	81 e0       	ldi	r24, 0x01	; 1
    1aa6:	80 93 51 02 	sts	0x0251, r24
    1aaa:	04 c0       	rjmp	.+8      	; 0x1ab4 <D1+0x92>
						}
			}
			if(flag==1)
    1aac:	21 30       	cpi	r18, 0x01	; 1
    1aae:	11 f0       	breq	.+4      	; 0x1ab4 <D1+0x92>
    1ab0:	0c 94 06 1a 	jmp	0x340c	; 0x340c <__stack+0x120d>
			{
				
				if(count1<7)							//Sorts until count is 7
    1ab4:	80 91 06 02 	lds	r24, 0x0206
    1ab8:	90 91 07 02 	lds	r25, 0x0207
    1abc:	87 30       	cpi	r24, 0x07	; 7
    1abe:	91 05       	cpc	r25, r1
    1ac0:	10 f0       	brcs	.+4      	; 0x1ac6 <D1+0xa4>
    1ac2:	0c 94 ea 19 	jmp	0x33d4	; 0x33d4 <__stack+0x11d5>
				{	
						if(Cur_Pos[0]==2&&(Cur_Pos[1]>=0&&Cur_Pos[1]<6)) //Proceeds only if bot is on column 2 and on rows 2 to 6. 
    1ac6:	88 81       	ld	r24, Y
    1ac8:	99 81       	ldd	r25, Y+1	; 0x01
    1aca:	82 30       	cpi	r24, 0x02	; 2
    1acc:	91 05       	cpc	r25, r1
    1ace:	09 f0       	breq	.+2      	; 0x1ad2 <D1+0xb0>
    1ad0:	bd cf       	rjmp	.-134    	; 0x1a4c <D1+0x2a>
    1ad2:	d8 01       	movw	r26, r16
    1ad4:	8d 91       	ld	r24, X+
    1ad6:	9c 91       	ld	r25, X
    1ad8:	11 97       	sbiw	r26, 0x01	; 1
    1ada:	8d 91       	ld	r24, X+
    1adc:	9c 91       	ld	r25, X
    1ade:	11 97       	sbiw	r26, 0x01	; 1
    1ae0:	86 30       	cpi	r24, 0x06	; 6
    1ae2:	91 05       	cpc	r25, r1
    1ae4:	08 f0       	brcs	.+2      	; 0x1ae8 <D1+0xc6>
    1ae6:	b2 cf       	rjmp	.-156    	; 0x1a4c <D1+0x2a>
						{	
							
							
							if(count1<7)
							{
							unsigned short int tmp=Cur_Pos[1]+1;				//Stores value of next row, in order to reduce execution time when accessing block position.
    1ae8:	8d 91       	ld	r24, X+
    1aea:	9c 91       	ld	r25, X
    1aec:	11 97       	sbiw	r26, 0x01	; 1
    1aee:	ac 01       	movw	r20, r24
    1af0:	4f 5f       	subi	r20, 0xFF	; 255
    1af2:	5f 4f       	sbci	r21, 0xFF	; 255
								if(Blk_Pos[tmp][0]==0)							// Checks if block position at column A in the next row is zero. Proceeds to check in the next columns in order to determine the exact configuration of the blocks in the next row.  
    1af4:	ca 01       	movw	r24, r20
    1af6:	88 0f       	add	r24, r24
    1af8:	99 1f       	adc	r25, r25
    1afa:	9a 01       	movw	r18, r20
    1afc:	22 0f       	add	r18, r18
    1afe:	33 1f       	adc	r19, r19
    1b00:	22 0f       	add	r18, r18
    1b02:	33 1f       	adc	r19, r19
    1b04:	22 0f       	add	r18, r18
    1b06:	33 1f       	adc	r19, r19
    1b08:	82 0f       	add	r24, r18
    1b0a:	93 1f       	adc	r25, r19
    1b0c:	f6 01       	movw	r30, r12
    1b0e:	e8 0f       	add	r30, r24
    1b10:	f9 1f       	adc	r31, r25
    1b12:	80 81       	ld	r24, Z
    1b14:	91 81       	ldd	r25, Z+1	; 0x01
    1b16:	00 97       	sbiw	r24, 0x00	; 0
    1b18:	09 f0       	breq	.+2      	; 0x1b1c <D1+0xfa>
    1b1a:	35 c5       	rjmp	.+2666   	; 0x2586 <__stack+0x387>
								{
									if(Blk_Pos[tmp][1]==0)						//Checks if block in column B in the next row is zero, proceeds to form individual cases.
    1b1c:	ca 01       	movw	r24, r20
    1b1e:	88 0f       	add	r24, r24
    1b20:	99 1f       	adc	r25, r25
    1b22:	9a 01       	movw	r18, r20
    1b24:	22 0f       	add	r18, r18
    1b26:	33 1f       	adc	r19, r19
    1b28:	22 0f       	add	r18, r18
    1b2a:	33 1f       	adc	r19, r19
    1b2c:	22 0f       	add	r18, r18
    1b2e:	33 1f       	adc	r19, r19
    1b30:	82 0f       	add	r24, r18
    1b32:	93 1f       	adc	r25, r19
    1b34:	f6 01       	movw	r30, r12
    1b36:	e8 0f       	add	r30, r24
    1b38:	f9 1f       	adc	r31, r25
    1b3a:	82 81       	ldd	r24, Z+2	; 0x02
    1b3c:	93 81       	ldd	r25, Z+3	; 0x03
    1b3e:	00 97       	sbiw	r24, 0x00	; 0
    1b40:	09 f0       	breq	.+2      	; 0x1b44 <D1+0x122>
    1b42:	0f c2       	rjmp	.+1054   	; 0x1f62 <D1+0x540>
									{
										if(Blk_Pos[tmp][3]==0)					//Checks if block in column D in the next row is zero, proceeds to form individual cases.
    1b44:	ca 01       	movw	r24, r20
    1b46:	88 0f       	add	r24, r24
    1b48:	99 1f       	adc	r25, r25
    1b4a:	9a 01       	movw	r18, r20
    1b4c:	22 0f       	add	r18, r18
    1b4e:	33 1f       	adc	r19, r19
    1b50:	22 0f       	add	r18, r18
    1b52:	33 1f       	adc	r19, r19
    1b54:	22 0f       	add	r18, r18
    1b56:	33 1f       	adc	r19, r19
    1b58:	82 0f       	add	r24, r18
    1b5a:	93 1f       	adc	r25, r19
    1b5c:	f6 01       	movw	r30, r12
    1b5e:	e8 0f       	add	r30, r24
    1b60:	f9 1f       	adc	r31, r25
    1b62:	86 81       	ldd	r24, Z+6	; 0x06
    1b64:	97 81       	ldd	r25, Z+7	; 0x07
    1b66:	00 97       	sbiw	r24, 0x00	; 0
    1b68:	09 f0       	breq	.+2      	; 0x1b6c <D1+0x14a>
    1b6a:	98 c0       	rjmp	.+304    	; 0x1c9c <D1+0x27a>
										{
											if(Blk_Pos[tmp][4]==0)				//Checks if block in column E in the next row is zero, proceeds to form individual cases. The case formed thus is when there are no blocks in the next row. Henceforth denoted as (0, 0, 0, 0, 0).
    1b6c:	fa 01       	movw	r30, r20
    1b6e:	ee 0f       	add	r30, r30
    1b70:	ff 1f       	adc	r31, r31
    1b72:	c9 01       	movw	r24, r18
    1b74:	8e 0f       	add	r24, r30
    1b76:	9f 1f       	adc	r25, r31
    1b78:	f6 01       	movw	r30, r12
    1b7a:	e8 0f       	add	r30, r24
    1b7c:	f9 1f       	adc	r31, r25
    1b7e:	80 85       	ldd	r24, Z+8	; 0x08
    1b80:	91 85       	ldd	r25, Z+9	; 0x09
    1b82:	00 97       	sbiw	r24, 0x00	; 0
    1b84:	59 f5       	brne	.+86     	; 0x1bdc <D1+0x1ba>
											{
												if(Cur_Pos[1]==5)			//This case runs for (0,0,0,0,0) in row 1, where instead of going to row 1 it exits D1 from row 2 instead.
    1b86:	8d 91       	ld	r24, X+
    1b88:	9c 91       	ld	r25, X
    1b8a:	11 97       	sbiw	r26, 0x01	; 1
    1b8c:	85 30       	cpi	r24, 0x05	; 5
    1b8e:	91 05       	cpc	r25, r1
    1b90:	29 f4       	brne	.+10     	; 0x1b9c <D1+0x17a>
												{
													exit1(1);
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    1b9a:	58 cf       	rjmp	.-336    	; 0x1a4c <D1+0x2a>
												}
												else						//Case for (0,0,0,0,0), goes forward and calls Sharp_Detection();
												{
													forward_wls(1);_delay_ms(500);
    1b9c:	81 e0       	ldi	r24, 0x01	; 1
    1b9e:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    1ba2:	8f ef       	ldi	r24, 0xFF	; 255
    1ba4:	9f e7       	ldi	r25, 0x7F	; 127
    1ba6:	a6 e1       	ldi	r26, 0x16	; 22
    1ba8:	81 50       	subi	r24, 0x01	; 1
    1baa:	90 40       	sbci	r25, 0x00	; 0
    1bac:	a0 40       	sbci	r26, 0x00	; 0
    1bae:	e1 f7       	brne	.-8      	; 0x1ba8 <D1+0x186>
    1bb0:	00 c0       	rjmp	.+0      	; 0x1bb2 <D1+0x190>
    1bb2:	00 00       	nop
													Cur_Pos[1]+=1;
    1bb4:	d8 01       	movw	r26, r16
    1bb6:	8d 91       	ld	r24, X+
    1bb8:	9c 91       	ld	r25, X
    1bba:	11 97       	sbiw	r26, 0x01	; 1
    1bbc:	01 96       	adiw	r24, 0x01	; 1
    1bbe:	11 96       	adiw	r26, 0x01	; 1
    1bc0:	9c 93       	st	X, r25
    1bc2:	8e 93       	st	-X, r24
													Sharp_Detection();_delay_ms(500);
    1bc4:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    1bc8:	8f ef       	ldi	r24, 0xFF	; 255
    1bca:	9f e7       	ldi	r25, 0x7F	; 127
    1bcc:	a6 e1       	ldi	r26, 0x16	; 22
    1bce:	81 50       	subi	r24, 0x01	; 1
    1bd0:	90 40       	sbci	r25, 0x00	; 0
    1bd2:	a0 40       	sbci	r26, 0x00	; 0
    1bd4:	e1 f7       	brne	.-8      	; 0x1bce <D1+0x1ac>
    1bd6:	00 c0       	rjmp	.+0      	; 0x1bd8 <D1+0x1b6>
    1bd8:	00 00       	nop
    1bda:	38 cf       	rjmp	.-400    	; 0x1a4c <D1+0x2a>
													
												}
											}
											else								//Case for (1,0,0,0,0)
											{
												forward_wls(1);_delay_ms(500);
    1bdc:	81 e0       	ldi	r24, 0x01	; 1
    1bde:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    1be2:	8f ef       	ldi	r24, 0xFF	; 255
    1be4:	9f e7       	ldi	r25, 0x7F	; 127
    1be6:	a6 e1       	ldi	r26, 0x16	; 22
    1be8:	81 50       	subi	r24, 0x01	; 1
    1bea:	90 40       	sbci	r25, 0x00	; 0
    1bec:	a0 40       	sbci	r26, 0x00	; 0
    1bee:	e1 f7       	brne	.-8      	; 0x1be8 <D1+0x1c6>
    1bf0:	00 c0       	rjmp	.+0      	; 0x1bf2 <D1+0x1d0>
    1bf2:	00 00       	nop
												Cur_Pos[1]+=1;
    1bf4:	d8 01       	movw	r26, r16
    1bf6:	8d 91       	ld	r24, X+
    1bf8:	9c 91       	ld	r25, X
    1bfa:	11 97       	sbiw	r26, 0x01	; 1
    1bfc:	01 96       	adiw	r24, 0x01	; 1
    1bfe:	11 96       	adiw	r26, 0x01	; 1
    1c00:	9c 93       	st	X, r25
    1c02:	8e 93       	st	-X, r24
												Sharp_Detection();_delay_ms(500); 
    1c04:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    1c08:	8f ef       	ldi	r24, 0xFF	; 255
    1c0a:	9f e7       	ldi	r25, 0x7F	; 127
    1c0c:	a6 e1       	ldi	r26, 0x16	; 22
    1c0e:	81 50       	subi	r24, 0x01	; 1
    1c10:	90 40       	sbci	r25, 0x00	; 0
    1c12:	a0 40       	sbci	r26, 0x00	; 0
    1c14:	e1 f7       	brne	.-8      	; 0x1c0e <D1+0x1ec>
    1c16:	00 c0       	rjmp	.+0      	; 0x1c18 <D1+0x1f6>
    1c18:	00 00       	nop
												lf(1,1);_delay_ms(500);
    1c1a:	81 e0       	ldi	r24, 0x01	; 1
    1c1c:	90 e0       	ldi	r25, 0x00	; 0
    1c1e:	61 e0       	ldi	r22, 0x01	; 1
    1c20:	70 e0       	ldi	r23, 0x00	; 0
    1c22:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    1c26:	8f ef       	ldi	r24, 0xFF	; 255
    1c28:	9f e7       	ldi	r25, 0x7F	; 127
    1c2a:	a6 e1       	ldi	r26, 0x16	; 22
    1c2c:	81 50       	subi	r24, 0x01	; 1
    1c2e:	90 40       	sbci	r25, 0x00	; 0
    1c30:	a0 40       	sbci	r26, 0x00	; 0
    1c32:	e1 f7       	brne	.-8      	; 0x1c2c <D1+0x20a>
    1c34:	00 c0       	rjmp	.+0      	; 0x1c36 <D1+0x214>
    1c36:	00 00       	nop
												arm(0);_delay_ms(500);
    1c38:	80 e0       	ldi	r24, 0x00	; 0
    1c3a:	90 e0       	ldi	r25, 0x00	; 0
    1c3c:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    1c40:	8f ef       	ldi	r24, 0xFF	; 255
    1c42:	9f e7       	ldi	r25, 0x7F	; 127
    1c44:	a6 e1       	ldi	r26, 0x16	; 22
    1c46:	81 50       	subi	r24, 0x01	; 1
    1c48:	90 40       	sbci	r25, 0x00	; 0
    1c4a:	a0 40       	sbci	r26, 0x00	; 0
    1c4c:	e1 f7       	brne	.-8      	; 0x1c46 <D1+0x224>
    1c4e:	00 c0       	rjmp	.+0      	; 0x1c50 <D1+0x22e>
    1c50:	00 00       	nop
												right_degrees(90);
    1c52:	8a e5       	ldi	r24, 0x5A	; 90
    1c54:	90 e0       	ldi	r25, 0x00	; 0
    1c56:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
												rf(1,1);
    1c5a:	81 e0       	ldi	r24, 0x01	; 1
    1c5c:	90 e0       	ldi	r25, 0x00	; 0
    1c5e:	61 e0       	ldi	r22, 0x01	; 1
    1c60:	70 e0       	ldi	r23, 0x00	; 0
    1c62:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
												left_wls();_delay_ms(500);
    1c66:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    1c6a:	8f ef       	ldi	r24, 0xFF	; 255
    1c6c:	9f e7       	ldi	r25, 0x7F	; 127
    1c6e:	a6 e1       	ldi	r26, 0x16	; 22
    1c70:	81 50       	subi	r24, 0x01	; 1
    1c72:	90 40       	sbci	r25, 0x00	; 0
    1c74:	a0 40       	sbci	r26, 0x00	; 0
    1c76:	e1 f7       	brne	.-8      	; 0x1c70 <D1+0x24e>
    1c78:	00 c0       	rjmp	.+0      	; 0x1c7a <D1+0x258>
    1c7a:	00 00       	nop
												if(Cur_Pos[1]==6)			//This case runs for (0,0,0,0,1) in row 1, where instead of going to row 1 it exits D1 from row 2 instead.
    1c7c:	d8 01       	movw	r26, r16
    1c7e:	8d 91       	ld	r24, X+
    1c80:	9c 91       	ld	r25, X
    1c82:	11 97       	sbiw	r26, 0x01	; 1
    1c84:	86 30       	cpi	r24, 0x06	; 6
    1c86:	91 05       	cpc	r25, r1
    1c88:	09 f0       	breq	.+2      	; 0x1c8c <D1+0x26a>
    1c8a:	e0 ce       	rjmp	.-576    	; 0x1a4c <D1+0x2a>
												{
													forward_wls(1);
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
													exit1(1);
    1c92:	81 e0       	ldi	r24, 0x01	; 1
    1c94:	90 e0       	ldi	r25, 0x00	; 0
    1c96:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    1c9a:	d8 ce       	rjmp	.-592    	; 0x1a4c <D1+0x2a>
												}
											}
										}
										else								
										{
											if(Blk_Pos[tmp][4]==0)				//Case for (0,1,0,0,0)
    1c9c:	fa 01       	movw	r30, r20
    1c9e:	ee 0f       	add	r30, r30
    1ca0:	ff 1f       	adc	r31, r31
    1ca2:	ca 01       	movw	r24, r20
    1ca4:	88 0f       	add	r24, r24
    1ca6:	99 1f       	adc	r25, r25
    1ca8:	88 0f       	add	r24, r24
    1caa:	99 1f       	adc	r25, r25
    1cac:	88 0f       	add	r24, r24
    1cae:	99 1f       	adc	r25, r25
    1cb0:	8e 0f       	add	r24, r30
    1cb2:	9f 1f       	adc	r25, r31
    1cb4:	f6 01       	movw	r30, r12
    1cb6:	e8 0f       	add	r30, r24
    1cb8:	f9 1f       	adc	r31, r25
    1cba:	80 85       	ldd	r24, Z+8	; 0x08
    1cbc:	91 85       	ldd	r25, Z+9	; 0x09
    1cbe:	00 97       	sbiw	r24, 0x00	; 0
    1cc0:	09 f0       	breq	.+2      	; 0x1cc4 <D1+0x2a2>
    1cc2:	6e c0       	rjmp	.+220    	; 0x1da0 <D1+0x37e>
											{
												if(Cur_Pos[1]==5)
    1cc4:	f8 01       	movw	r30, r16
    1cc6:	80 81       	ld	r24, Z
    1cc8:	91 81       	ldd	r25, Z+1	; 0x01
    1cca:	85 30       	cpi	r24, 0x05	; 5
    1ccc:	91 05       	cpc	r25, r1
    1cce:	19 f5       	brne	.+70     	; 0x1d16 <D1+0x2f4>
												{
													lf(1,1);
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	61 e0       	ldi	r22, 0x01	; 1
    1cd6:	70 e0       	ldi	r23, 0x00	; 0
    1cd8:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
													right_wls();_delay_ms(500);
    1cdc:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    1ce0:	8f ef       	ldi	r24, 0xFF	; 255
    1ce2:	9f e7       	ldi	r25, 0x7F	; 127
    1ce4:	a6 e1       	ldi	r26, 0x16	; 22
    1ce6:	81 50       	subi	r24, 0x01	; 1
    1ce8:	90 40       	sbci	r25, 0x00	; 0
    1cea:	a0 40       	sbci	r26, 0x00	; 0
    1cec:	e1 f7       	brne	.-8      	; 0x1ce6 <D1+0x2c4>
    1cee:	00 c0       	rjmp	.+0      	; 0x1cf0 <D1+0x2ce>
    1cf0:	00 00       	nop
													arm(0);_delay_ms(500);
    1cf2:	80 e0       	ldi	r24, 0x00	; 0
    1cf4:	90 e0       	ldi	r25, 0x00	; 0
    1cf6:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    1cfa:	8f ef       	ldi	r24, 0xFF	; 255
    1cfc:	9f e7       	ldi	r25, 0x7F	; 127
    1cfe:	a6 e1       	ldi	r26, 0x16	; 22
    1d00:	81 50       	subi	r24, 0x01	; 1
    1d02:	90 40       	sbci	r25, 0x00	; 0
    1d04:	a0 40       	sbci	r26, 0x00	; 0
    1d06:	e1 f7       	brne	.-8      	; 0x1d00 <D1+0x2de>
    1d08:	00 c0       	rjmp	.+0      	; 0x1d0a <D1+0x2e8>
    1d0a:	00 00       	nop
													exit1(0);
    1d0c:	80 e0       	ldi	r24, 0x00	; 0
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    1d14:	9b ce       	rjmp	.-714    	; 0x1a4c <D1+0x2a>
												}
												else
												{
													forward_wls(1);_delay_ms(500);
    1d16:	81 e0       	ldi	r24, 0x01	; 1
    1d18:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    1d1c:	8f ef       	ldi	r24, 0xFF	; 255
    1d1e:	9f e7       	ldi	r25, 0x7F	; 127
    1d20:	a6 e1       	ldi	r26, 0x16	; 22
    1d22:	81 50       	subi	r24, 0x01	; 1
    1d24:	90 40       	sbci	r25, 0x00	; 0
    1d26:	a0 40       	sbci	r26, 0x00	; 0
    1d28:	e1 f7       	brne	.-8      	; 0x1d22 <D1+0x300>
    1d2a:	00 c0       	rjmp	.+0      	; 0x1d2c <D1+0x30a>
    1d2c:	00 00       	nop
													Cur_Pos[1]+=1;
    1d2e:	d8 01       	movw	r26, r16
    1d30:	8d 91       	ld	r24, X+
    1d32:	9c 91       	ld	r25, X
    1d34:	11 97       	sbiw	r26, 0x01	; 1
    1d36:	01 96       	adiw	r24, 0x01	; 1
    1d38:	11 96       	adiw	r26, 0x01	; 1
    1d3a:	9c 93       	st	X, r25
    1d3c:	8e 93       	st	-X, r24
													Sharp_Detection();_delay_ms(500);
    1d3e:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    1d42:	8f ef       	ldi	r24, 0xFF	; 255
    1d44:	9f e7       	ldi	r25, 0x7F	; 127
    1d46:	a6 e1       	ldi	r26, 0x16	; 22
    1d48:	81 50       	subi	r24, 0x01	; 1
    1d4a:	90 40       	sbci	r25, 0x00	; 0
    1d4c:	a0 40       	sbci	r26, 0x00	; 0
    1d4e:	e1 f7       	brne	.-8      	; 0x1d48 <D1+0x326>
    1d50:	00 c0       	rjmp	.+0      	; 0x1d52 <D1+0x330>
    1d52:	00 00       	nop
													left_wls();_delay_ms(500);
    1d54:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    1d58:	8f ef       	ldi	r24, 0xFF	; 255
    1d5a:	9f e7       	ldi	r25, 0x7F	; 127
    1d5c:	a6 e1       	ldi	r26, 0x16	; 22
    1d5e:	81 50       	subi	r24, 0x01	; 1
    1d60:	90 40       	sbci	r25, 0x00	; 0
    1d62:	a0 40       	sbci	r26, 0x00	; 0
    1d64:	e1 f7       	brne	.-8      	; 0x1d5e <D1+0x33c>
    1d66:	00 c0       	rjmp	.+0      	; 0x1d68 <D1+0x346>
    1d68:	00 00       	nop
													arm(0);_delay_ms(500);
    1d6a:	80 e0       	ldi	r24, 0x00	; 0
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    1d72:	8f ef       	ldi	r24, 0xFF	; 255
    1d74:	9f e7       	ldi	r25, 0x7F	; 127
    1d76:	a6 e1       	ldi	r26, 0x16	; 22
    1d78:	81 50       	subi	r24, 0x01	; 1
    1d7a:	90 40       	sbci	r25, 0x00	; 0
    1d7c:	a0 40       	sbci	r26, 0x00	; 0
    1d7e:	e1 f7       	brne	.-8      	; 0x1d78 <D1+0x356>
    1d80:	00 c0       	rjmp	.+0      	; 0x1d82 <D1+0x360>
    1d82:	00 00       	nop
													right_degrees(90);_delay_ms(500);																
    1d84:	8a e5       	ldi	r24, 0x5A	; 90
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
    1d8c:	8f ef       	ldi	r24, 0xFF	; 255
    1d8e:	9f e7       	ldi	r25, 0x7F	; 127
    1d90:	a6 e1       	ldi	r26, 0x16	; 22
    1d92:	81 50       	subi	r24, 0x01	; 1
    1d94:	90 40       	sbci	r25, 0x00	; 0
    1d96:	a0 40       	sbci	r26, 0x00	; 0
    1d98:	e1 f7       	brne	.-8      	; 0x1d92 <D1+0x370>
    1d9a:	00 c0       	rjmp	.+0      	; 0x1d9c <D1+0x37a>
    1d9c:	00 00       	nop
    1d9e:	56 ce       	rjmp	.-852    	; 0x1a4c <D1+0x2a>
												}
											}
											else								//Case for (1,1,0,0,0)
											{
												if(Cur_Pos[1]==5)
    1da0:	d8 01       	movw	r26, r16
    1da2:	8d 91       	ld	r24, X+
    1da4:	9c 91       	ld	r25, X
    1da6:	11 97       	sbiw	r26, 0x01	; 1
    1da8:	85 30       	cpi	r24, 0x05	; 5
    1daa:	91 05       	cpc	r25, r1
    1dac:	09 f0       	breq	.+2      	; 0x1db0 <D1+0x38e>
    1dae:	53 c0       	rjmp	.+166    	; 0x1e56 <D1+0x434>
												{
													lf(1,1);_delay_ms(500);
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	90 e0       	ldi	r25, 0x00	; 0
    1db4:	61 e0       	ldi	r22, 0x01	; 1
    1db6:	70 e0       	ldi	r23, 0x00	; 0
    1db8:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    1dbc:	8f ef       	ldi	r24, 0xFF	; 255
    1dbe:	9f e7       	ldi	r25, 0x7F	; 127
    1dc0:	a6 e1       	ldi	r26, 0x16	; 22
    1dc2:	81 50       	subi	r24, 0x01	; 1
    1dc4:	90 40       	sbci	r25, 0x00	; 0
    1dc6:	a0 40       	sbci	r26, 0x00	; 0
    1dc8:	e1 f7       	brne	.-8      	; 0x1dc2 <D1+0x3a0>
    1dca:	00 c0       	rjmp	.+0      	; 0x1dcc <D1+0x3aa>
    1dcc:	00 00       	nop
													right_wls();_delay_ms(500);
    1dce:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    1dd2:	8f ef       	ldi	r24, 0xFF	; 255
    1dd4:	9f e7       	ldi	r25, 0x7F	; 127
    1dd6:	a6 e1       	ldi	r26, 0x16	; 22
    1dd8:	81 50       	subi	r24, 0x01	; 1
    1dda:	90 40       	sbci	r25, 0x00	; 0
    1ddc:	a0 40       	sbci	r26, 0x00	; 0
    1dde:	e1 f7       	brne	.-8      	; 0x1dd8 <D1+0x3b6>
    1de0:	00 c0       	rjmp	.+0      	; 0x1de2 <D1+0x3c0>
    1de2:	00 00       	nop
													arm(0);_delay_ms(500);
    1de4:	80 e0       	ldi	r24, 0x00	; 0
    1de6:	90 e0       	ldi	r25, 0x00	; 0
    1de8:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    1dec:	8f ef       	ldi	r24, 0xFF	; 255
    1dee:	9f e7       	ldi	r25, 0x7F	; 127
    1df0:	a6 e1       	ldi	r26, 0x16	; 22
    1df2:	81 50       	subi	r24, 0x01	; 1
    1df4:	90 40       	sbci	r25, 0x00	; 0
    1df6:	a0 40       	sbci	r26, 0x00	; 0
    1df8:	e1 f7       	brne	.-8      	; 0x1df2 <D1+0x3d0>
    1dfa:	00 c0       	rjmp	.+0      	; 0x1dfc <D1+0x3da>
    1dfc:	00 00       	nop
													lf(1, 0);_delay_ms(500);
    1dfe:	81 e0       	ldi	r24, 0x01	; 1
    1e00:	90 e0       	ldi	r25, 0x00	; 0
    1e02:	60 e0       	ldi	r22, 0x00	; 0
    1e04:	70 e0       	ldi	r23, 0x00	; 0
    1e06:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    1e0a:	8f ef       	ldi	r24, 0xFF	; 255
    1e0c:	9f e7       	ldi	r25, 0x7F	; 127
    1e0e:	a6 e1       	ldi	r26, 0x16	; 22
    1e10:	81 50       	subi	r24, 0x01	; 1
    1e12:	90 40       	sbci	r25, 0x00	; 0
    1e14:	a0 40       	sbci	r26, 0x00	; 0
    1e16:	e1 f7       	brne	.-8      	; 0x1e10 <D1+0x3ee>
    1e18:	00 c0       	rjmp	.+0      	; 0x1e1a <D1+0x3f8>
    1e1a:	00 00       	nop
													right_wls();_delay_ms(500);
    1e1c:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    1e20:	8f ef       	ldi	r24, 0xFF	; 255
    1e22:	9f e7       	ldi	r25, 0x7F	; 127
    1e24:	a6 e1       	ldi	r26, 0x16	; 22
    1e26:	81 50       	subi	r24, 0x01	; 1
    1e28:	90 40       	sbci	r25, 0x00	; 0
    1e2a:	a0 40       	sbci	r26, 0x00	; 0
    1e2c:	e1 f7       	brne	.-8      	; 0x1e26 <D1+0x404>
    1e2e:	00 c0       	rjmp	.+0      	; 0x1e30 <D1+0x40e>
    1e30:	00 00       	nop
													arm(0);_delay_ms(500);
    1e32:	80 e0       	ldi	r24, 0x00	; 0
    1e34:	90 e0       	ldi	r25, 0x00	; 0
    1e36:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    1e3a:	8f ef       	ldi	r24, 0xFF	; 255
    1e3c:	9f e7       	ldi	r25, 0x7F	; 127
    1e3e:	a6 e1       	ldi	r26, 0x16	; 22
    1e40:	81 50       	subi	r24, 0x01	; 1
    1e42:	90 40       	sbci	r25, 0x00	; 0
    1e44:	a0 40       	sbci	r26, 0x00	; 0
    1e46:	e1 f7       	brne	.-8      	; 0x1e40 <D1+0x41e>
    1e48:	00 c0       	rjmp	.+0      	; 0x1e4a <D1+0x428>
    1e4a:	00 00       	nop
													exit1(0);
    1e4c:	80 e0       	ldi	r24, 0x00	; 0
    1e4e:	90 e0       	ldi	r25, 0x00	; 0
    1e50:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    1e54:	fb cd       	rjmp	.-1034   	; 0x1a4c <D1+0x2a>
												}
												else
												{
													lf(2,1);_delay_ms(500);
    1e56:	82 e0       	ldi	r24, 0x02	; 2
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	61 e0       	ldi	r22, 0x01	; 1
    1e5c:	70 e0       	ldi	r23, 0x00	; 0
    1e5e:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    1e62:	8f ef       	ldi	r24, 0xFF	; 255
    1e64:	9f e7       	ldi	r25, 0x7F	; 127
    1e66:	a6 e1       	ldi	r26, 0x16	; 22
    1e68:	81 50       	subi	r24, 0x01	; 1
    1e6a:	90 40       	sbci	r25, 0x00	; 0
    1e6c:	a0 40       	sbci	r26, 0x00	; 0
    1e6e:	e1 f7       	brne	.-8      	; 0x1e68 <D1+0x446>
    1e70:	00 c0       	rjmp	.+0      	; 0x1e72 <D1+0x450>
    1e72:	00 00       	nop
													right_wls();_delay_ms(500);
    1e74:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    1e78:	8f ef       	ldi	r24, 0xFF	; 255
    1e7a:	9f e7       	ldi	r25, 0x7F	; 127
    1e7c:	a6 e1       	ldi	r26, 0x16	; 22
    1e7e:	81 50       	subi	r24, 0x01	; 1
    1e80:	90 40       	sbci	r25, 0x00	; 0
    1e82:	a0 40       	sbci	r26, 0x00	; 0
    1e84:	e1 f7       	brne	.-8      	; 0x1e7e <D1+0x45c>
    1e86:	00 c0       	rjmp	.+0      	; 0x1e88 <D1+0x466>
    1e88:	00 00       	nop
													arm(0);_delay_ms(500);
    1e8a:	80 e0       	ldi	r24, 0x00	; 0
    1e8c:	90 e0       	ldi	r25, 0x00	; 0
    1e8e:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    1e92:	8f ef       	ldi	r24, 0xFF	; 255
    1e94:	9f e7       	ldi	r25, 0x7F	; 127
    1e96:	a6 e1       	ldi	r26, 0x16	; 22
    1e98:	81 50       	subi	r24, 0x01	; 1
    1e9a:	90 40       	sbci	r25, 0x00	; 0
    1e9c:	a0 40       	sbci	r26, 0x00	; 0
    1e9e:	e1 f7       	brne	.-8      	; 0x1e98 <D1+0x476>
    1ea0:	00 c0       	rjmp	.+0      	; 0x1ea2 <D1+0x480>
    1ea2:	00 00       	nop
													rf(2,0);_delay_ms(500);
    1ea4:	82 e0       	ldi	r24, 0x02	; 2
    1ea6:	90 e0       	ldi	r25, 0x00	; 0
    1ea8:	60 e0       	ldi	r22, 0x00	; 0
    1eaa:	70 e0       	ldi	r23, 0x00	; 0
    1eac:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    1eb0:	8f ef       	ldi	r24, 0xFF	; 255
    1eb2:	9f e7       	ldi	r25, 0x7F	; 127
    1eb4:	a6 e1       	ldi	r26, 0x16	; 22
    1eb6:	81 50       	subi	r24, 0x01	; 1
    1eb8:	90 40       	sbci	r25, 0x00	; 0
    1eba:	a0 40       	sbci	r26, 0x00	; 0
    1ebc:	e1 f7       	brne	.-8      	; 0x1eb6 <D1+0x494>
    1ebe:	00 c0       	rjmp	.+0      	; 0x1ec0 <D1+0x49e>
    1ec0:	00 00       	nop
													left_wls();_delay_ms(500);
    1ec2:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    1ec6:	8f ef       	ldi	r24, 0xFF	; 255
    1ec8:	9f e7       	ldi	r25, 0x7F	; 127
    1eca:	a6 e1       	ldi	r26, 0x16	; 22
    1ecc:	81 50       	subi	r24, 0x01	; 1
    1ece:	90 40       	sbci	r25, 0x00	; 0
    1ed0:	a0 40       	sbci	r26, 0x00	; 0
    1ed2:	e1 f7       	brne	.-8      	; 0x1ecc <D1+0x4aa>
    1ed4:	00 c0       	rjmp	.+0      	; 0x1ed6 <D1+0x4b4>
    1ed6:	00 00       	nop
													forward_wls(1);_delay_ms(500);
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
    1eda:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    1ede:	8f ef       	ldi	r24, 0xFF	; 255
    1ee0:	9f e7       	ldi	r25, 0x7F	; 127
    1ee2:	a6 e1       	ldi	r26, 0x16	; 22
    1ee4:	81 50       	subi	r24, 0x01	; 1
    1ee6:	90 40       	sbci	r25, 0x00	; 0
    1ee8:	a0 40       	sbci	r26, 0x00	; 0
    1eea:	e1 f7       	brne	.-8      	; 0x1ee4 <D1+0x4c2>
    1eec:	00 c0       	rjmp	.+0      	; 0x1eee <D1+0x4cc>
    1eee:	00 00       	nop
													Cur_Pos[1]+=1;
    1ef0:	d8 01       	movw	r26, r16
    1ef2:	8d 91       	ld	r24, X+
    1ef4:	9c 91       	ld	r25, X
    1ef6:	11 97       	sbiw	r26, 0x01	; 1
    1ef8:	01 96       	adiw	r24, 0x01	; 1
    1efa:	11 96       	adiw	r26, 0x01	; 1
    1efc:	9c 93       	st	X, r25
    1efe:	8e 93       	st	-X, r24
													Sharp_Detection();_delay_ms(500);
    1f00:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    1f04:	8f ef       	ldi	r24, 0xFF	; 255
    1f06:	9f e7       	ldi	r25, 0x7F	; 127
    1f08:	a6 e1       	ldi	r26, 0x16	; 22
    1f0a:	81 50       	subi	r24, 0x01	; 1
    1f0c:	90 40       	sbci	r25, 0x00	; 0
    1f0e:	a0 40       	sbci	r26, 0x00	; 0
    1f10:	e1 f7       	brne	.-8      	; 0x1f0a <D1+0x4e8>
    1f12:	00 c0       	rjmp	.+0      	; 0x1f14 <D1+0x4f2>
    1f14:	00 00       	nop
													left_wls();_delay_ms(500);
    1f16:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    1f1a:	8f ef       	ldi	r24, 0xFF	; 255
    1f1c:	9f e7       	ldi	r25, 0x7F	; 127
    1f1e:	a6 e1       	ldi	r26, 0x16	; 22
    1f20:	81 50       	subi	r24, 0x01	; 1
    1f22:	90 40       	sbci	r25, 0x00	; 0
    1f24:	a0 40       	sbci	r26, 0x00	; 0
    1f26:	e1 f7       	brne	.-8      	; 0x1f20 <D1+0x4fe>
    1f28:	00 c0       	rjmp	.+0      	; 0x1f2a <D1+0x508>
    1f2a:	00 00       	nop
													arm(0);_delay_ms(500);
    1f2c:	80 e0       	ldi	r24, 0x00	; 0
    1f2e:	90 e0       	ldi	r25, 0x00	; 0
    1f30:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    1f34:	8f ef       	ldi	r24, 0xFF	; 255
    1f36:	9f e7       	ldi	r25, 0x7F	; 127
    1f38:	a6 e1       	ldi	r26, 0x16	; 22
    1f3a:	81 50       	subi	r24, 0x01	; 1
    1f3c:	90 40       	sbci	r25, 0x00	; 0
    1f3e:	a0 40       	sbci	r26, 0x00	; 0
    1f40:	e1 f7       	brne	.-8      	; 0x1f3a <D1+0x518>
    1f42:	00 c0       	rjmp	.+0      	; 0x1f44 <D1+0x522>
    1f44:	00 00       	nop
													right_degrees(90);_delay_ms(500);
    1f46:	8a e5       	ldi	r24, 0x5A	; 90
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
    1f4e:	8f ef       	ldi	r24, 0xFF	; 255
    1f50:	9f e7       	ldi	r25, 0x7F	; 127
    1f52:	a6 e1       	ldi	r26, 0x16	; 22
    1f54:	81 50       	subi	r24, 0x01	; 1
    1f56:	90 40       	sbci	r25, 0x00	; 0
    1f58:	a0 40       	sbci	r26, 0x00	; 0
    1f5a:	e1 f7       	brne	.-8      	; 0x1f54 <D1+0x532>
    1f5c:	00 c0       	rjmp	.+0      	; 0x1f5e <D1+0x53c>
    1f5e:	00 00       	nop
    1f60:	75 cd       	rjmp	.-1302   	; 0x1a4c <D1+0x2a>
											}
										}
									}
									else								
									{
										if(Blk_Pos[tmp][3]==0)
    1f62:	ca 01       	movw	r24, r20
    1f64:	88 0f       	add	r24, r24
    1f66:	99 1f       	adc	r25, r25
    1f68:	9a 01       	movw	r18, r20
    1f6a:	22 0f       	add	r18, r18
    1f6c:	33 1f       	adc	r19, r19
    1f6e:	22 0f       	add	r18, r18
    1f70:	33 1f       	adc	r19, r19
    1f72:	22 0f       	add	r18, r18
    1f74:	33 1f       	adc	r19, r19
    1f76:	82 0f       	add	r24, r18
    1f78:	93 1f       	adc	r25, r19
    1f7a:	f6 01       	movw	r30, r12
    1f7c:	e8 0f       	add	r30, r24
    1f7e:	f9 1f       	adc	r31, r25
    1f80:	86 81       	ldd	r24, Z+6	; 0x06
    1f82:	97 81       	ldd	r25, Z+7	; 0x07
    1f84:	00 97       	sbiw	r24, 0x00	; 0
    1f86:	09 f0       	breq	.+2      	; 0x1f8a <D1+0x568>
    1f88:	3f c1       	rjmp	.+638    	; 0x2208 <__stack+0x9>
										{
											if(Blk_Pos[tmp][4]==0)				//Case for (0,0,0,1,0)
    1f8a:	fa 01       	movw	r30, r20
    1f8c:	ee 0f       	add	r30, r30
    1f8e:	ff 1f       	adc	r31, r31
    1f90:	c9 01       	movw	r24, r18
    1f92:	8e 0f       	add	r24, r30
    1f94:	9f 1f       	adc	r25, r31
    1f96:	f6 01       	movw	r30, r12
    1f98:	e8 0f       	add	r30, r24
    1f9a:	f9 1f       	adc	r31, r25
    1f9c:	80 85       	ldd	r24, Z+8	; 0x08
    1f9e:	91 85       	ldd	r25, Z+9	; 0x09
    1fa0:	00 97       	sbiw	r24, 0x00	; 0
    1fa2:	09 f0       	breq	.+2      	; 0x1fa6 <D1+0x584>
    1fa4:	82 c0       	rjmp	.+260    	; 0x20aa <D1+0x688>
											{									
												
												if(Cur_Pos[1]==5)
    1fa6:	d8 01       	movw	r26, r16
    1fa8:	8d 91       	ld	r24, X+
    1faa:	9c 91       	ld	r25, X
    1fac:	11 97       	sbiw	r26, 0x01	; 1
    1fae:	85 30       	cpi	r24, 0x05	; 5
    1fb0:	91 05       	cpc	r25, r1
    1fb2:	b1 f5       	brne	.+108    	; 0x2020 <D1+0x5fe>
												{
													forward_wls(1);_delay_ms(500);
    1fb4:	81 e0       	ldi	r24, 0x01	; 1
    1fb6:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    1fba:	8f ef       	ldi	r24, 0xFF	; 255
    1fbc:	9f e7       	ldi	r25, 0x7F	; 127
    1fbe:	a6 e1       	ldi	r26, 0x16	; 22
    1fc0:	81 50       	subi	r24, 0x01	; 1
    1fc2:	90 40       	sbci	r25, 0x00	; 0
    1fc4:	a0 40       	sbci	r26, 0x00	; 0
    1fc6:	e1 f7       	brne	.-8      	; 0x1fc0 <D1+0x59e>
    1fc8:	00 c0       	rjmp	.+0      	; 0x1fca <D1+0x5a8>
    1fca:	00 00       	nop
													right_wls();_delay_ms(500);
    1fcc:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    1fd0:	8f ef       	ldi	r24, 0xFF	; 255
    1fd2:	9f e7       	ldi	r25, 0x7F	; 127
    1fd4:	a6 e1       	ldi	r26, 0x16	; 22
    1fd6:	81 50       	subi	r24, 0x01	; 1
    1fd8:	90 40       	sbci	r25, 0x00	; 0
    1fda:	a0 40       	sbci	r26, 0x00	; 0
    1fdc:	e1 f7       	brne	.-8      	; 0x1fd6 <D1+0x5b4>
    1fde:	00 c0       	rjmp	.+0      	; 0x1fe0 <D1+0x5be>
    1fe0:	00 00       	nop
													arm(0);_delay_ms(500);
    1fe2:	80 e0       	ldi	r24, 0x00	; 0
    1fe4:	90 e0       	ldi	r25, 0x00	; 0
    1fe6:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    1fea:	8f ef       	ldi	r24, 0xFF	; 255
    1fec:	9f e7       	ldi	r25, 0x7F	; 127
    1fee:	a6 e1       	ldi	r26, 0x16	; 22
    1ff0:	81 50       	subi	r24, 0x01	; 1
    1ff2:	90 40       	sbci	r25, 0x00	; 0
    1ff4:	a0 40       	sbci	r26, 0x00	; 0
    1ff6:	e1 f7       	brne	.-8      	; 0x1ff0 <D1+0x5ce>
    1ff8:	00 c0       	rjmp	.+0      	; 0x1ffa <D1+0x5d8>
    1ffa:	00 00       	nop
													left_degrees(90);_delay_ms(500);
    1ffc:	8a e5       	ldi	r24, 0x5A	; 90
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    2004:	8f ef       	ldi	r24, 0xFF	; 255
    2006:	9f e7       	ldi	r25, 0x7F	; 127
    2008:	a6 e1       	ldi	r26, 0x16	; 22
    200a:	81 50       	subi	r24, 0x01	; 1
    200c:	90 40       	sbci	r25, 0x00	; 0
    200e:	a0 40       	sbci	r26, 0x00	; 0
    2010:	e1 f7       	brne	.-8      	; 0x200a <D1+0x5e8>
    2012:	00 c0       	rjmp	.+0      	; 0x2014 <D1+0x5f2>
    2014:	00 00       	nop
													exit1(1);
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	90 e0       	ldi	r25, 0x00	; 0
    201a:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    201e:	16 cd       	rjmp	.-1492   	; 0x1a4c <D1+0x2a>
												}
												else
												{
													forward_wls(1);_delay_ms(500);
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    2026:	8f ef       	ldi	r24, 0xFF	; 255
    2028:	9f e7       	ldi	r25, 0x7F	; 127
    202a:	a6 e1       	ldi	r26, 0x16	; 22
    202c:	81 50       	subi	r24, 0x01	; 1
    202e:	90 40       	sbci	r25, 0x00	; 0
    2030:	a0 40       	sbci	r26, 0x00	; 0
    2032:	e1 f7       	brne	.-8      	; 0x202c <D1+0x60a>
    2034:	00 c0       	rjmp	.+0      	; 0x2036 <D1+0x614>
    2036:	00 00       	nop
													right_wls();_delay_ms(500);
    2038:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    203c:	8f ef       	ldi	r24, 0xFF	; 255
    203e:	9f e7       	ldi	r25, 0x7F	; 127
    2040:	a6 e1       	ldi	r26, 0x16	; 22
    2042:	81 50       	subi	r24, 0x01	; 1
    2044:	90 40       	sbci	r25, 0x00	; 0
    2046:	a0 40       	sbci	r26, 0x00	; 0
    2048:	e1 f7       	brne	.-8      	; 0x2042 <D1+0x620>
    204a:	00 c0       	rjmp	.+0      	; 0x204c <D1+0x62a>
    204c:	00 00       	nop
													Cur_Pos[1]+=1;
    204e:	d8 01       	movw	r26, r16
    2050:	8d 91       	ld	r24, X+
    2052:	9c 91       	ld	r25, X
    2054:	11 97       	sbiw	r26, 0x01	; 1
    2056:	01 96       	adiw	r24, 0x01	; 1
    2058:	11 96       	adiw	r26, 0x01	; 1
    205a:	9c 93       	st	X, r25
    205c:	8e 93       	st	-X, r24
													Sharp_Detection();_delay_ms(500);
    205e:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    2062:	8f ef       	ldi	r24, 0xFF	; 255
    2064:	9f e7       	ldi	r25, 0x7F	; 127
    2066:	a6 e1       	ldi	r26, 0x16	; 22
    2068:	81 50       	subi	r24, 0x01	; 1
    206a:	90 40       	sbci	r25, 0x00	; 0
    206c:	a0 40       	sbci	r26, 0x00	; 0
    206e:	e1 f7       	brne	.-8      	; 0x2068 <D1+0x646>
    2070:	00 c0       	rjmp	.+0      	; 0x2072 <D1+0x650>
    2072:	00 00       	nop
													arm(0);_delay_ms(500);
    2074:	80 e0       	ldi	r24, 0x00	; 0
    2076:	90 e0       	ldi	r25, 0x00	; 0
    2078:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    207c:	8f ef       	ldi	r24, 0xFF	; 255
    207e:	9f e7       	ldi	r25, 0x7F	; 127
    2080:	a6 e1       	ldi	r26, 0x16	; 22
    2082:	81 50       	subi	r24, 0x01	; 1
    2084:	90 40       	sbci	r25, 0x00	; 0
    2086:	a0 40       	sbci	r26, 0x00	; 0
    2088:	e1 f7       	brne	.-8      	; 0x2082 <D1+0x660>
    208a:	00 c0       	rjmp	.+0      	; 0x208c <D1+0x66a>
    208c:	00 00       	nop
													left_degrees(90);_delay_ms(500);
    208e:	8a e5       	ldi	r24, 0x5A	; 90
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    2096:	8f ef       	ldi	r24, 0xFF	; 255
    2098:	9f e7       	ldi	r25, 0x7F	; 127
    209a:	a6 e1       	ldi	r26, 0x16	; 22
    209c:	81 50       	subi	r24, 0x01	; 1
    209e:	90 40       	sbci	r25, 0x00	; 0
    20a0:	a0 40       	sbci	r26, 0x00	; 0
    20a2:	e1 f7       	brne	.-8      	; 0x209c <D1+0x67a>
    20a4:	00 c0       	rjmp	.+0      	; 0x20a6 <D1+0x684>
    20a6:	00 00       	nop
    20a8:	d1 cc       	rjmp	.-1630   	; 0x1a4c <D1+0x2a>
												}
												
											}
											else								//Case for (1,0,0,1,0)
											{	
												if(Cur_Pos[1]==5)
    20aa:	d8 01       	movw	r26, r16
    20ac:	8d 91       	ld	r24, X+
    20ae:	9c 91       	ld	r25, X
    20b0:	11 97       	sbiw	r26, 0x01	; 1
    20b2:	85 30       	cpi	r24, 0x05	; 5
    20b4:	91 05       	cpc	r25, r1
    20b6:	b1 f5       	brne	.+108    	; 0x2124 <D1+0x702>
												{
													lf(1,1);
    20b8:	81 e0       	ldi	r24, 0x01	; 1
    20ba:	90 e0       	ldi	r25, 0x00	; 0
    20bc:	61 e0       	ldi	r22, 0x01	; 1
    20be:	70 e0       	ldi	r23, 0x00	; 0
    20c0:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
													right_wls();
    20c4:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
													arm(0);_delay_ms(500);
    20c8:	80 e0       	ldi	r24, 0x00	; 0
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    20d0:	8f ef       	ldi	r24, 0xFF	; 255
    20d2:	9f e7       	ldi	r25, 0x7F	; 127
    20d4:	a6 e1       	ldi	r26, 0x16	; 22
    20d6:	81 50       	subi	r24, 0x01	; 1
    20d8:	90 40       	sbci	r25, 0x00	; 0
    20da:	a0 40       	sbci	r26, 0x00	; 0
    20dc:	e1 f7       	brne	.-8      	; 0x20d6 <D1+0x6b4>
    20de:	00 c0       	rjmp	.+0      	; 0x20e0 <D1+0x6be>
    20e0:	00 00       	nop
													lf(3,0);_delay_ms(500);
    20e2:	83 e0       	ldi	r24, 0x03	; 3
    20e4:	90 e0       	ldi	r25, 0x00	; 0
    20e6:	60 e0       	ldi	r22, 0x00	; 0
    20e8:	70 e0       	ldi	r23, 0x00	; 0
    20ea:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    20ee:	8f ef       	ldi	r24, 0xFF	; 255
    20f0:	9f e7       	ldi	r25, 0x7F	; 127
    20f2:	a6 e1       	ldi	r26, 0x16	; 22
    20f4:	81 50       	subi	r24, 0x01	; 1
    20f6:	90 40       	sbci	r25, 0x00	; 0
    20f8:	a0 40       	sbci	r26, 0x00	; 0
    20fa:	e1 f7       	brne	.-8      	; 0x20f4 <D1+0x6d2>
    20fc:	00 c0       	rjmp	.+0      	; 0x20fe <D1+0x6dc>
    20fe:	00 00       	nop
													arm(0);_delay_ms(500);
    2100:	80 e0       	ldi	r24, 0x00	; 0
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2108:	8f ef       	ldi	r24, 0xFF	; 255
    210a:	9f e7       	ldi	r25, 0x7F	; 127
    210c:	a6 e1       	ldi	r26, 0x16	; 22
    210e:	81 50       	subi	r24, 0x01	; 1
    2110:	90 40       	sbci	r25, 0x00	; 0
    2112:	a0 40       	sbci	r26, 0x00	; 0
    2114:	e1 f7       	brne	.-8      	; 0x210e <D1+0x6ec>
    2116:	00 c0       	rjmp	.+0      	; 0x2118 <D1+0x6f6>
    2118:	00 00       	nop
													exit1(0);
    211a:	80 e0       	ldi	r24, 0x00	; 0
    211c:	90 e0       	ldi	r25, 0x00	; 0
    211e:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    2122:	94 cc       	rjmp	.-1752   	; 0x1a4c <D1+0x2a>
												}
												else
												{
													forward_wls(1);_delay_ms(500);
    2124:	81 e0       	ldi	r24, 0x01	; 1
    2126:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    212a:	8f ef       	ldi	r24, 0xFF	; 255
    212c:	9f e7       	ldi	r25, 0x7F	; 127
    212e:	a6 e1       	ldi	r26, 0x16	; 22
    2130:	81 50       	subi	r24, 0x01	; 1
    2132:	90 40       	sbci	r25, 0x00	; 0
    2134:	a0 40       	sbci	r26, 0x00	; 0
    2136:	e1 f7       	brne	.-8      	; 0x2130 <D1+0x70e>
    2138:	00 c0       	rjmp	.+0      	; 0x213a <D1+0x718>
    213a:	00 00       	nop
													Cur_Pos[1]+=1;
    213c:	d8 01       	movw	r26, r16
    213e:	8d 91       	ld	r24, X+
    2140:	9c 91       	ld	r25, X
    2142:	11 97       	sbiw	r26, 0x01	; 1
    2144:	01 96       	adiw	r24, 0x01	; 1
    2146:	11 96       	adiw	r26, 0x01	; 1
    2148:	9c 93       	st	X, r25
    214a:	8e 93       	st	-X, r24
													Sharp_Detection();_delay_ms(500);
    214c:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    2150:	8f ef       	ldi	r24, 0xFF	; 255
    2152:	9f e7       	ldi	r25, 0x7F	; 127
    2154:	a6 e1       	ldi	r26, 0x16	; 22
    2156:	81 50       	subi	r24, 0x01	; 1
    2158:	90 40       	sbci	r25, 0x00	; 0
    215a:	a0 40       	sbci	r26, 0x00	; 0
    215c:	e1 f7       	brne	.-8      	; 0x2156 <D1+0x734>
    215e:	00 c0       	rjmp	.+0      	; 0x2160 <D1+0x73e>
    2160:	00 00       	nop
													right_wls();_delay_ms(500);
    2162:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2166:	8f ef       	ldi	r24, 0xFF	; 255
    2168:	9f e7       	ldi	r25, 0x7F	; 127
    216a:	a6 e1       	ldi	r26, 0x16	; 22
    216c:	81 50       	subi	r24, 0x01	; 1
    216e:	90 40       	sbci	r25, 0x00	; 0
    2170:	a0 40       	sbci	r26, 0x00	; 0
    2172:	e1 f7       	brne	.-8      	; 0x216c <D1+0x74a>
    2174:	00 c0       	rjmp	.+0      	; 0x2176 <D1+0x754>
    2176:	00 00       	nop
													arm(0);_delay_ms(500);
    2178:	80 e0       	ldi	r24, 0x00	; 0
    217a:	90 e0       	ldi	r25, 0x00	; 0
    217c:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2180:	8f ef       	ldi	r24, 0xFF	; 255
    2182:	9f e7       	ldi	r25, 0x7F	; 127
    2184:	a6 e1       	ldi	r26, 0x16	; 22
    2186:	81 50       	subi	r24, 0x01	; 1
    2188:	90 40       	sbci	r25, 0x00	; 0
    218a:	a0 40       	sbci	r26, 0x00	; 0
    218c:	e1 f7       	brne	.-8      	; 0x2186 <D1+0x764>
    218e:	00 c0       	rjmp	.+0      	; 0x2190 <D1+0x76e>
    2190:	00 00       	nop
													left_wls();_delay_ms(500); 
    2192:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    2196:	8f ef       	ldi	r24, 0xFF	; 255
    2198:	9f e7       	ldi	r25, 0x7F	; 127
    219a:	a6 e1       	ldi	r26, 0x16	; 22
    219c:	81 50       	subi	r24, 0x01	; 1
    219e:	90 40       	sbci	r25, 0x00	; 0
    21a0:	a0 40       	sbci	r26, 0x00	; 0
    21a2:	e1 f7       	brne	.-8      	; 0x219c <D1+0x77a>
    21a4:	00 c0       	rjmp	.+0      	; 0x21a6 <D1+0x784>
    21a6:	00 00       	nop
													lf(1,1);_delay_ms(500);
    21a8:	81 e0       	ldi	r24, 0x01	; 1
    21aa:	90 e0       	ldi	r25, 0x00	; 0
    21ac:	61 e0       	ldi	r22, 0x01	; 1
    21ae:	70 e0       	ldi	r23, 0x00	; 0
    21b0:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    21b4:	8f ef       	ldi	r24, 0xFF	; 255
    21b6:	9f e7       	ldi	r25, 0x7F	; 127
    21b8:	a6 e1       	ldi	r26, 0x16	; 22
    21ba:	81 50       	subi	r24, 0x01	; 1
    21bc:	90 40       	sbci	r25, 0x00	; 0
    21be:	a0 40       	sbci	r26, 0x00	; 0
    21c0:	e1 f7       	brne	.-8      	; 0x21ba <D1+0x798>
    21c2:	00 c0       	rjmp	.+0      	; 0x21c4 <D1+0x7a2>
    21c4:	00 00       	nop
													arm(0);_delay_ms(500);
    21c6:	80 e0       	ldi	r24, 0x00	; 0
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    21ce:	8f ef       	ldi	r24, 0xFF	; 255
    21d0:	9f e7       	ldi	r25, 0x7F	; 127
    21d2:	a6 e1       	ldi	r26, 0x16	; 22
    21d4:	81 50       	subi	r24, 0x01	; 1
    21d6:	90 40       	sbci	r25, 0x00	; 0
    21d8:	a0 40       	sbci	r26, 0x00	; 0
    21da:	e1 f7       	brne	.-8      	; 0x21d4 <D1+0x7b2>
    21dc:	00 c0       	rjmp	.+0      	; 0x21de <D1+0x7bc>
    21de:	00 00       	nop
													right_wls();
    21e0:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
													rf(1,1);
    21e4:	81 e0       	ldi	r24, 0x01	; 1
    21e6:	90 e0       	ldi	r25, 0x00	; 0
    21e8:	61 e0       	ldi	r22, 0x01	; 1
    21ea:	70 e0       	ldi	r23, 0x00	; 0
    21ec:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
													left_wls();_delay_ms(500);
    21f0:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    21f4:	8f ef       	ldi	r24, 0xFF	; 255
    21f6:	9f e7       	ldi	r25, 0x7F	; 127
    21f8:	a6 e1       	ldi	r26, 0x16	; 22
    21fa:	81 50       	subi	r24, 0x01	; 1
    21fc:	90 40       	sbci	r25, 0x00	; 0
    21fe:	a0 40       	sbci	r26, 0x00	; 0
    2200:	e1 f7       	brne	.-8      	; 0x21fa <D1+0x7d8>
    2202:	00 c0       	rjmp	.+0      	; 0x2204 <__stack+0x5>
    2204:	00 00       	nop
    2206:	22 cc       	rjmp	.-1980   	; 0x1a4c <D1+0x2a>
												}
											}
										}
										else									
										{
											if(Blk_Pos[tmp][4]==0)				//Case for (0,1,0,1,0)
    2208:	fa 01       	movw	r30, r20
    220a:	ee 0f       	add	r30, r30
    220c:	ff 1f       	adc	r31, r31
    220e:	ca 01       	movw	r24, r20
    2210:	88 0f       	add	r24, r24
    2212:	99 1f       	adc	r25, r25
    2214:	88 0f       	add	r24, r24
    2216:	99 1f       	adc	r25, r25
    2218:	88 0f       	add	r24, r24
    221a:	99 1f       	adc	r25, r25
    221c:	8e 0f       	add	r24, r30
    221e:	9f 1f       	adc	r25, r31
    2220:	f6 01       	movw	r30, r12
    2222:	e8 0f       	add	r30, r24
    2224:	f9 1f       	adc	r31, r25
    2226:	80 85       	ldd	r24, Z+8	; 0x08
    2228:	91 85       	ldd	r25, Z+9	; 0x09
    222a:	00 97       	sbiw	r24, 0x00	; 0
    222c:	09 f0       	breq	.+2      	; 0x2230 <__stack+0x31>
    222e:	98 c0       	rjmp	.+304    	; 0x2360 <__stack+0x161>
											{
												if(Cur_Pos[1]==5)
    2230:	d8 01       	movw	r26, r16
    2232:	8d 91       	ld	r24, X+
    2234:	9c 91       	ld	r25, X
    2236:	11 97       	sbiw	r26, 0x01	; 1
    2238:	85 30       	cpi	r24, 0x05	; 5
    223a:	91 05       	cpc	r25, r1
    223c:	79 f5       	brne	.+94     	; 0x229c <__stack+0x9d>
												{
														rf(1,1);
    223e:	81 e0       	ldi	r24, 0x01	; 1
    2240:	90 e0       	ldi	r25, 0x00	; 0
    2242:	61 e0       	ldi	r22, 0x01	; 1
    2244:	70 e0       	ldi	r23, 0x00	; 0
    2246:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
														left_wls();
    224a:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
														arm(0);_delay_ms(500);
    224e:	80 e0       	ldi	r24, 0x00	; 0
    2250:	90 e0       	ldi	r25, 0x00	; 0
    2252:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2256:	8f ef       	ldi	r24, 0xFF	; 255
    2258:	9f e7       	ldi	r25, 0x7F	; 127
    225a:	a6 e1       	ldi	r26, 0x16	; 22
    225c:	81 50       	subi	r24, 0x01	; 1
    225e:	90 40       	sbci	r25, 0x00	; 0
    2260:	a0 40       	sbci	r26, 0x00	; 0
    2262:	e1 f7       	brne	.-8      	; 0x225c <__stack+0x5d>
    2264:	00 c0       	rjmp	.+0      	; 0x2266 <__stack+0x67>
    2266:	00 00       	nop
														lf(2,0);
    2268:	82 e0       	ldi	r24, 0x02	; 2
    226a:	90 e0       	ldi	r25, 0x00	; 0
    226c:	60 e0       	ldi	r22, 0x00	; 0
    226e:	70 e0       	ldi	r23, 0x00	; 0
    2270:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
														right_wls();
    2274:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
														arm(0);_delay_ms(500);
    2278:	80 e0       	ldi	r24, 0x00	; 0
    227a:	90 e0       	ldi	r25, 0x00	; 0
    227c:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2280:	8f ef       	ldi	r24, 0xFF	; 255
    2282:	9f e7       	ldi	r25, 0x7F	; 127
    2284:	a6 e1       	ldi	r26, 0x16	; 22
    2286:	81 50       	subi	r24, 0x01	; 1
    2288:	90 40       	sbci	r25, 0x00	; 0
    228a:	a0 40       	sbci	r26, 0x00	; 0
    228c:	e1 f7       	brne	.-8      	; 0x2286 <__stack+0x87>
    228e:	00 c0       	rjmp	.+0      	; 0x2290 <__stack+0x91>
    2290:	00 00       	nop
														exit1(0);
    2292:	80 e0       	ldi	r24, 0x00	; 0
    2294:	90 e0       	ldi	r25, 0x00	; 0
    2296:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    229a:	d8 cb       	rjmp	.-2128   	; 0x1a4c <D1+0x2a>
												}
												else
												{
														forward_wls(1);_delay_ms(500);		//No detection following forward as placement rules forbid placing of blocks in the next row if blocks are placed in the given configuration in a certain row.
    229c:	81 e0       	ldi	r24, 0x01	; 1
    229e:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    22a2:	8f ef       	ldi	r24, 0xFF	; 255
    22a4:	9f e7       	ldi	r25, 0x7F	; 127
    22a6:	a6 e1       	ldi	r26, 0x16	; 22
    22a8:	81 50       	subi	r24, 0x01	; 1
    22aa:	90 40       	sbci	r25, 0x00	; 0
    22ac:	a0 40       	sbci	r26, 0x00	; 0
    22ae:	e1 f7       	brne	.-8      	; 0x22a8 <__stack+0xa9>
    22b0:	00 c0       	rjmp	.+0      	; 0x22b2 <__stack+0xb3>
    22b2:	00 00       	nop
														left_wls();_delay_ms(500);
    22b4:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    22b8:	8f ef       	ldi	r24, 0xFF	; 255
    22ba:	9f e7       	ldi	r25, 0x7F	; 127
    22bc:	a6 e1       	ldi	r26, 0x16	; 22
    22be:	81 50       	subi	r24, 0x01	; 1
    22c0:	90 40       	sbci	r25, 0x00	; 0
    22c2:	a0 40       	sbci	r26, 0x00	; 0
    22c4:	e1 f7       	brne	.-8      	; 0x22be <__stack+0xbf>
    22c6:	00 c0       	rjmp	.+0      	; 0x22c8 <__stack+0xc9>
    22c8:	00 00       	nop
														arm(0);_delay_ms(500);
    22ca:	80 e0       	ldi	r24, 0x00	; 0
    22cc:	90 e0       	ldi	r25, 0x00	; 0
    22ce:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    22d2:	8f ef       	ldi	r24, 0xFF	; 255
    22d4:	9f e7       	ldi	r25, 0x7F	; 127
    22d6:	a6 e1       	ldi	r26, 0x16	; 22
    22d8:	81 50       	subi	r24, 0x01	; 1
    22da:	90 40       	sbci	r25, 0x00	; 0
    22dc:	a0 40       	sbci	r26, 0x00	; 0
    22de:	e1 f7       	brne	.-8      	; 0x22d8 <__stack+0xd9>
    22e0:	00 c0       	rjmp	.+0      	; 0x22e2 <__stack+0xe3>
    22e2:	00 00       	nop
														right_degrees(180);
    22e4:	84 eb       	ldi	r24, 0xB4	; 180
    22e6:	90 e0       	ldi	r25, 0x00	; 0
    22e8:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
														arm(0);_delay_ms(500);
    22ec:	80 e0       	ldi	r24, 0x00	; 0
    22ee:	90 e0       	ldi	r25, 0x00	; 0
    22f0:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    22f4:	8f ef       	ldi	r24, 0xFF	; 255
    22f6:	9f e7       	ldi	r25, 0x7F	; 127
    22f8:	a6 e1       	ldi	r26, 0x16	; 22
    22fa:	81 50       	subi	r24, 0x01	; 1
    22fc:	90 40       	sbci	r25, 0x00	; 0
    22fe:	a0 40       	sbci	r26, 0x00	; 0
    2300:	e1 f7       	brne	.-8      	; 0x22fa <__stack+0xfb>
    2302:	00 c0       	rjmp	.+0      	; 0x2304 <__stack+0x105>
    2304:	00 00       	nop
														left_degrees(90);_delay_ms(500);
    2306:	8a e5       	ldi	r24, 0x5A	; 90
    2308:	90 e0       	ldi	r25, 0x00	; 0
    230a:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    230e:	8f ef       	ldi	r24, 0xFF	; 255
    2310:	9f e7       	ldi	r25, 0x7F	; 127
    2312:	a6 e1       	ldi	r26, 0x16	; 22
    2314:	81 50       	subi	r24, 0x01	; 1
    2316:	90 40       	sbci	r25, 0x00	; 0
    2318:	a0 40       	sbci	r26, 0x00	; 0
    231a:	e1 f7       	brne	.-8      	; 0x2314 <__stack+0x115>
    231c:	00 c0       	rjmp	.+0      	; 0x231e <__stack+0x11f>
    231e:	00 00       	nop
														forward_wls(1);_delay_ms(500);
    2320:	81 e0       	ldi	r24, 0x01	; 1
    2322:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    2326:	8f ef       	ldi	r24, 0xFF	; 255
    2328:	9f e7       	ldi	r25, 0x7F	; 127
    232a:	a6 e1       	ldi	r26, 0x16	; 22
    232c:	81 50       	subi	r24, 0x01	; 1
    232e:	90 40       	sbci	r25, 0x00	; 0
    2330:	a0 40       	sbci	r26, 0x00	; 0
    2332:	e1 f7       	brne	.-8      	; 0x232c <__stack+0x12d>
    2334:	00 c0       	rjmp	.+0      	; 0x2336 <__stack+0x137>
    2336:	00 00       	nop
														Cur_Pos[1]+=1;
    2338:	d8 01       	movw	r26, r16
    233a:	8d 91       	ld	r24, X+
    233c:	9c 91       	ld	r25, X
    233e:	11 97       	sbiw	r26, 0x01	; 1
    2340:	01 96       	adiw	r24, 0x01	; 1
    2342:	11 96       	adiw	r26, 0x01	; 1
    2344:	9c 93       	st	X, r25
    2346:	8e 93       	st	-X, r24
														Sharp_Detection();_delay_ms(500);
    2348:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    234c:	8f ef       	ldi	r24, 0xFF	; 255
    234e:	9f e7       	ldi	r25, 0x7F	; 127
    2350:	a6 e1       	ldi	r26, 0x16	; 22
    2352:	81 50       	subi	r24, 0x01	; 1
    2354:	90 40       	sbci	r25, 0x00	; 0
    2356:	a0 40       	sbci	r26, 0x00	; 0
    2358:	e1 f7       	brne	.-8      	; 0x2352 <__stack+0x153>
    235a:	00 c0       	rjmp	.+0      	; 0x235c <__stack+0x15d>
    235c:	00 00       	nop
    235e:	76 cb       	rjmp	.-2324   	; 0x1a4c <D1+0x2a>
												}
											}
											else								//Case for (1,1,0,1,0)
											{
												if(Cur_Pos[1]==5)
    2360:	d8 01       	movw	r26, r16
    2362:	8d 91       	ld	r24, X+
    2364:	9c 91       	ld	r25, X
    2366:	11 97       	sbiw	r26, 0x01	; 1
    2368:	85 30       	cpi	r24, 0x05	; 5
    236a:	91 05       	cpc	r25, r1
    236c:	09 f0       	breq	.+2      	; 0x2370 <__stack+0x171>
    236e:	68 c0       	rjmp	.+208    	; 0x2440 <__stack+0x241>
												{
													rf(1,1);
    2370:	81 e0       	ldi	r24, 0x01	; 1
    2372:	90 e0       	ldi	r25, 0x00	; 0
    2374:	61 e0       	ldi	r22, 0x01	; 1
    2376:	70 e0       	ldi	r23, 0x00	; 0
    2378:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
													left_wls();
    237c:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
													arm(0);_delay_ms(500);
    2380:	80 e0       	ldi	r24, 0x00	; 0
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2388:	8f ef       	ldi	r24, 0xFF	; 255
    238a:	9f e7       	ldi	r25, 0x7F	; 127
    238c:	a6 e1       	ldi	r26, 0x16	; 22
    238e:	81 50       	subi	r24, 0x01	; 1
    2390:	90 40       	sbci	r25, 0x00	; 0
    2392:	a0 40       	sbci	r26, 0x00	; 0
    2394:	e1 f7       	brne	.-8      	; 0x238e <__stack+0x18f>
    2396:	00 c0       	rjmp	.+0      	; 0x2398 <__stack+0x199>
    2398:	00 00       	nop
													lf(1,0);_delay_ms(500);
    239a:	81 e0       	ldi	r24, 0x01	; 1
    239c:	90 e0       	ldi	r25, 0x00	; 0
    239e:	60 e0       	ldi	r22, 0x00	; 0
    23a0:	70 e0       	ldi	r23, 0x00	; 0
    23a2:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    23a6:	8f ef       	ldi	r24, 0xFF	; 255
    23a8:	9f e7       	ldi	r25, 0x7F	; 127
    23aa:	a6 e1       	ldi	r26, 0x16	; 22
    23ac:	81 50       	subi	r24, 0x01	; 1
    23ae:	90 40       	sbci	r25, 0x00	; 0
    23b0:	a0 40       	sbci	r26, 0x00	; 0
    23b2:	e1 f7       	brne	.-8      	; 0x23ac <__stack+0x1ad>
    23b4:	00 c0       	rjmp	.+0      	; 0x23b6 <__stack+0x1b7>
    23b6:	00 00       	nop
													right_wls();_delay_ms(500);
    23b8:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    23bc:	8f ef       	ldi	r24, 0xFF	; 255
    23be:	9f e7       	ldi	r25, 0x7F	; 127
    23c0:	a6 e1       	ldi	r26, 0x16	; 22
    23c2:	81 50       	subi	r24, 0x01	; 1
    23c4:	90 40       	sbci	r25, 0x00	; 0
    23c6:	a0 40       	sbci	r26, 0x00	; 0
    23c8:	e1 f7       	brne	.-8      	; 0x23c2 <__stack+0x1c3>
    23ca:	00 c0       	rjmp	.+0      	; 0x23cc <__stack+0x1cd>
    23cc:	00 00       	nop
													arm(0);_delay_ms(500);
    23ce:	80 e0       	ldi	r24, 0x00	; 0
    23d0:	90 e0       	ldi	r25, 0x00	; 0
    23d2:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    23d6:	8f ef       	ldi	r24, 0xFF	; 255
    23d8:	9f e7       	ldi	r25, 0x7F	; 127
    23da:	a6 e1       	ldi	r26, 0x16	; 22
    23dc:	81 50       	subi	r24, 0x01	; 1
    23de:	90 40       	sbci	r25, 0x00	; 0
    23e0:	a0 40       	sbci	r26, 0x00	; 0
    23e2:	e1 f7       	brne	.-8      	; 0x23dc <__stack+0x1dd>
    23e4:	00 c0       	rjmp	.+0      	; 0x23e6 <__stack+0x1e7>
    23e6:	00 00       	nop
													lf(3,0);_delay_ms(500);
    23e8:	83 e0       	ldi	r24, 0x03	; 3
    23ea:	90 e0       	ldi	r25, 0x00	; 0
    23ec:	60 e0       	ldi	r22, 0x00	; 0
    23ee:	70 e0       	ldi	r23, 0x00	; 0
    23f0:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    23f4:	8f ef       	ldi	r24, 0xFF	; 255
    23f6:	9f e7       	ldi	r25, 0x7F	; 127
    23f8:	a6 e1       	ldi	r26, 0x16	; 22
    23fa:	81 50       	subi	r24, 0x01	; 1
    23fc:	90 40       	sbci	r25, 0x00	; 0
    23fe:	a0 40       	sbci	r26, 0x00	; 0
    2400:	e1 f7       	brne	.-8      	; 0x23fa <__stack+0x1fb>
    2402:	00 c0       	rjmp	.+0      	; 0x2404 <__stack+0x205>
    2404:	00 00       	nop
													right_wls();_delay_ms(500);
    2406:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    240a:	8f ef       	ldi	r24, 0xFF	; 255
    240c:	9f e7       	ldi	r25, 0x7F	; 127
    240e:	a6 e1       	ldi	r26, 0x16	; 22
    2410:	81 50       	subi	r24, 0x01	; 1
    2412:	90 40       	sbci	r25, 0x00	; 0
    2414:	a0 40       	sbci	r26, 0x00	; 0
    2416:	e1 f7       	brne	.-8      	; 0x2410 <__stack+0x211>
    2418:	00 c0       	rjmp	.+0      	; 0x241a <__stack+0x21b>
    241a:	00 00       	nop
													arm(0);_delay_ms(500);
    241c:	80 e0       	ldi	r24, 0x00	; 0
    241e:	90 e0       	ldi	r25, 0x00	; 0
    2420:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2424:	8f ef       	ldi	r24, 0xFF	; 255
    2426:	9f e7       	ldi	r25, 0x7F	; 127
    2428:	a6 e1       	ldi	r26, 0x16	; 22
    242a:	81 50       	subi	r24, 0x01	; 1
    242c:	90 40       	sbci	r25, 0x00	; 0
    242e:	a0 40       	sbci	r26, 0x00	; 0
    2430:	e1 f7       	brne	.-8      	; 0x242a <__stack+0x22b>
    2432:	00 c0       	rjmp	.+0      	; 0x2434 <__stack+0x235>
    2434:	00 00       	nop
													exit1(0);
    2436:	80 e0       	ldi	r24, 0x00	; 0
    2438:	90 e0       	ldi	r25, 0x00	; 0
    243a:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    243e:	06 cb       	rjmp	.-2548   	; 0x1a4c <D1+0x2a>
												}
												else
												{
													lf(2,1);_delay_ms(500);
    2440:	82 e0       	ldi	r24, 0x02	; 2
    2442:	90 e0       	ldi	r25, 0x00	; 0
    2444:	61 e0       	ldi	r22, 0x01	; 1
    2446:	70 e0       	ldi	r23, 0x00	; 0
    2448:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    244c:	8f ef       	ldi	r24, 0xFF	; 255
    244e:	9f e7       	ldi	r25, 0x7F	; 127
    2450:	a6 e1       	ldi	r26, 0x16	; 22
    2452:	81 50       	subi	r24, 0x01	; 1
    2454:	90 40       	sbci	r25, 0x00	; 0
    2456:	a0 40       	sbci	r26, 0x00	; 0
    2458:	e1 f7       	brne	.-8      	; 0x2452 <__stack+0x253>
    245a:	00 c0       	rjmp	.+0      	; 0x245c <__stack+0x25d>
    245c:	00 00       	nop
													right_wls();_delay_ms(500);
    245e:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2462:	8f ef       	ldi	r24, 0xFF	; 255
    2464:	9f e7       	ldi	r25, 0x7F	; 127
    2466:	a6 e1       	ldi	r26, 0x16	; 22
    2468:	81 50       	subi	r24, 0x01	; 1
    246a:	90 40       	sbci	r25, 0x00	; 0
    246c:	a0 40       	sbci	r26, 0x00	; 0
    246e:	e1 f7       	brne	.-8      	; 0x2468 <__stack+0x269>
    2470:	00 c0       	rjmp	.+0      	; 0x2472 <__stack+0x273>
    2472:	00 00       	nop
													arm(0);_delay_ms(500);
    2474:	80 e0       	ldi	r24, 0x00	; 0
    2476:	90 e0       	ldi	r25, 0x00	; 0
    2478:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    247c:	8f ef       	ldi	r24, 0xFF	; 255
    247e:	9f e7       	ldi	r25, 0x7F	; 127
    2480:	a6 e1       	ldi	r26, 0x16	; 22
    2482:	81 50       	subi	r24, 0x01	; 1
    2484:	90 40       	sbci	r25, 0x00	; 0
    2486:	a0 40       	sbci	r26, 0x00	; 0
    2488:	e1 f7       	brne	.-8      	; 0x2482 <__stack+0x283>
    248a:	00 c0       	rjmp	.+0      	; 0x248c <__stack+0x28d>
    248c:	00 00       	nop
													rf(2,0);_delay_ms(500);
    248e:	82 e0       	ldi	r24, 0x02	; 2
    2490:	90 e0       	ldi	r25, 0x00	; 0
    2492:	60 e0       	ldi	r22, 0x00	; 0
    2494:	70 e0       	ldi	r23, 0x00	; 0
    2496:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    249a:	8f ef       	ldi	r24, 0xFF	; 255
    249c:	9f e7       	ldi	r25, 0x7F	; 127
    249e:	a6 e1       	ldi	r26, 0x16	; 22
    24a0:	81 50       	subi	r24, 0x01	; 1
    24a2:	90 40       	sbci	r25, 0x00	; 0
    24a4:	a0 40       	sbci	r26, 0x00	; 0
    24a6:	e1 f7       	brne	.-8      	; 0x24a0 <__stack+0x2a1>
    24a8:	00 c0       	rjmp	.+0      	; 0x24aa <__stack+0x2ab>
    24aa:	00 00       	nop
													left_wls();_delay_ms(500);
    24ac:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    24b0:	8f ef       	ldi	r24, 0xFF	; 255
    24b2:	9f e7       	ldi	r25, 0x7F	; 127
    24b4:	a6 e1       	ldi	r26, 0x16	; 22
    24b6:	81 50       	subi	r24, 0x01	; 1
    24b8:	90 40       	sbci	r25, 0x00	; 0
    24ba:	a0 40       	sbci	r26, 0x00	; 0
    24bc:	e1 f7       	brne	.-8      	; 0x24b6 <__stack+0x2b7>
    24be:	00 c0       	rjmp	.+0      	; 0x24c0 <__stack+0x2c1>
    24c0:	00 00       	nop
													forward_wls(1);_delay_ms(500);
    24c2:	81 e0       	ldi	r24, 0x01	; 1
    24c4:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    24c8:	8f ef       	ldi	r24, 0xFF	; 255
    24ca:	9f e7       	ldi	r25, 0x7F	; 127
    24cc:	a6 e1       	ldi	r26, 0x16	; 22
    24ce:	81 50       	subi	r24, 0x01	; 1
    24d0:	90 40       	sbci	r25, 0x00	; 0
    24d2:	a0 40       	sbci	r26, 0x00	; 0
    24d4:	e1 f7       	brne	.-8      	; 0x24ce <__stack+0x2cf>
    24d6:	00 c0       	rjmp	.+0      	; 0x24d8 <__stack+0x2d9>
    24d8:	00 00       	nop
													left_wls();_delay_ms(500);
    24da:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    24de:	8f ef       	ldi	r24, 0xFF	; 255
    24e0:	9f e7       	ldi	r25, 0x7F	; 127
    24e2:	a6 e1       	ldi	r26, 0x16	; 22
    24e4:	81 50       	subi	r24, 0x01	; 1
    24e6:	90 40       	sbci	r25, 0x00	; 0
    24e8:	a0 40       	sbci	r26, 0x00	; 0
    24ea:	e1 f7       	brne	.-8      	; 0x24e4 <__stack+0x2e5>
    24ec:	00 c0       	rjmp	.+0      	; 0x24ee <__stack+0x2ef>
    24ee:	00 00       	nop
													arm(0);_delay_ms(500);
    24f0:	80 e0       	ldi	r24, 0x00	; 0
    24f2:	90 e0       	ldi	r25, 0x00	; 0
    24f4:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    24f8:	8f ef       	ldi	r24, 0xFF	; 255
    24fa:	9f e7       	ldi	r25, 0x7F	; 127
    24fc:	a6 e1       	ldi	r26, 0x16	; 22
    24fe:	81 50       	subi	r24, 0x01	; 1
    2500:	90 40       	sbci	r25, 0x00	; 0
    2502:	a0 40       	sbci	r26, 0x00	; 0
    2504:	e1 f7       	brne	.-8      	; 0x24fe <__stack+0x2ff>
    2506:	00 c0       	rjmp	.+0      	; 0x2508 <__stack+0x309>
    2508:	00 00       	nop
													right_degrees(180);
    250a:	84 eb       	ldi	r24, 0xB4	; 180
    250c:	90 e0       	ldi	r25, 0x00	; 0
    250e:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
													arm(0);_delay_ms(500);
    2512:	80 e0       	ldi	r24, 0x00	; 0
    2514:	90 e0       	ldi	r25, 0x00	; 0
    2516:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    251a:	8f ef       	ldi	r24, 0xFF	; 255
    251c:	9f e7       	ldi	r25, 0x7F	; 127
    251e:	a6 e1       	ldi	r26, 0x16	; 22
    2520:	81 50       	subi	r24, 0x01	; 1
    2522:	90 40       	sbci	r25, 0x00	; 0
    2524:	a0 40       	sbci	r26, 0x00	; 0
    2526:	e1 f7       	brne	.-8      	; 0x2520 <__stack+0x321>
    2528:	00 c0       	rjmp	.+0      	; 0x252a <__stack+0x32b>
    252a:	00 00       	nop
													left_degrees(90);_delay_ms(500);
    252c:	8a e5       	ldi	r24, 0x5A	; 90
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    2534:	8f ef       	ldi	r24, 0xFF	; 255
    2536:	9f e7       	ldi	r25, 0x7F	; 127
    2538:	a6 e1       	ldi	r26, 0x16	; 22
    253a:	81 50       	subi	r24, 0x01	; 1
    253c:	90 40       	sbci	r25, 0x00	; 0
    253e:	a0 40       	sbci	r26, 0x00	; 0
    2540:	e1 f7       	brne	.-8      	; 0x253a <__stack+0x33b>
    2542:	00 c0       	rjmp	.+0      	; 0x2544 <__stack+0x345>
    2544:	00 00       	nop
													forward_wls(1);_delay_ms(500);
    2546:	81 e0       	ldi	r24, 0x01	; 1
    2548:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    254c:	8f ef       	ldi	r24, 0xFF	; 255
    254e:	9f e7       	ldi	r25, 0x7F	; 127
    2550:	a6 e1       	ldi	r26, 0x16	; 22
    2552:	81 50       	subi	r24, 0x01	; 1
    2554:	90 40       	sbci	r25, 0x00	; 0
    2556:	a0 40       	sbci	r26, 0x00	; 0
    2558:	e1 f7       	brne	.-8      	; 0x2552 <__stack+0x353>
    255a:	00 c0       	rjmp	.+0      	; 0x255c <__stack+0x35d>
    255c:	00 00       	nop
													Cur_Pos[1]+=1;
    255e:	d8 01       	movw	r26, r16
    2560:	8d 91       	ld	r24, X+
    2562:	9c 91       	ld	r25, X
    2564:	11 97       	sbiw	r26, 0x01	; 1
    2566:	01 96       	adiw	r24, 0x01	; 1
    2568:	11 96       	adiw	r26, 0x01	; 1
    256a:	9c 93       	st	X, r25
    256c:	8e 93       	st	-X, r24
													Sharp_Detection();_delay_ms(500);
    256e:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    2572:	8f ef       	ldi	r24, 0xFF	; 255
    2574:	9f e7       	ldi	r25, 0x7F	; 127
    2576:	a6 e1       	ldi	r26, 0x16	; 22
    2578:	81 50       	subi	r24, 0x01	; 1
    257a:	90 40       	sbci	r25, 0x00	; 0
    257c:	a0 40       	sbci	r26, 0x00	; 0
    257e:	e1 f7       	brne	.-8      	; 0x2578 <__stack+0x379>
    2580:	00 c0       	rjmp	.+0      	; 0x2582 <__stack+0x383>
    2582:	00 00       	nop
    2584:	63 ca       	rjmp	.-2874   	; 0x1a4c <D1+0x2a>
									}
									
								}
								else
								{
									if(Blk_Pos[tmp][1]==0)
    2586:	ca 01       	movw	r24, r20
    2588:	88 0f       	add	r24, r24
    258a:	99 1f       	adc	r25, r25
    258c:	9a 01       	movw	r18, r20
    258e:	22 0f       	add	r18, r18
    2590:	33 1f       	adc	r19, r19
    2592:	22 0f       	add	r18, r18
    2594:	33 1f       	adc	r19, r19
    2596:	22 0f       	add	r18, r18
    2598:	33 1f       	adc	r19, r19
    259a:	82 0f       	add	r24, r18
    259c:	93 1f       	adc	r25, r19
    259e:	f6 01       	movw	r30, r12
    25a0:	e8 0f       	add	r30, r24
    25a2:	f9 1f       	adc	r31, r25
    25a4:	82 81       	ldd	r24, Z+2	; 0x02
    25a6:	93 81       	ldd	r25, Z+3	; 0x03
    25a8:	00 97       	sbiw	r24, 0x00	; 0
    25aa:	09 f0       	breq	.+2      	; 0x25ae <__stack+0x3af>
    25ac:	7e c2       	rjmp	.+1276   	; 0x2aaa <__stack+0x8ab>
									{
										if(Blk_Pos[tmp][3]==0)
    25ae:	ca 01       	movw	r24, r20
    25b0:	88 0f       	add	r24, r24
    25b2:	99 1f       	adc	r25, r25
    25b4:	9a 01       	movw	r18, r20
    25b6:	22 0f       	add	r18, r18
    25b8:	33 1f       	adc	r19, r19
    25ba:	22 0f       	add	r18, r18
    25bc:	33 1f       	adc	r19, r19
    25be:	22 0f       	add	r18, r18
    25c0:	33 1f       	adc	r19, r19
    25c2:	82 0f       	add	r24, r18
    25c4:	93 1f       	adc	r25, r19
    25c6:	f6 01       	movw	r30, r12
    25c8:	e8 0f       	add	r30, r24
    25ca:	f9 1f       	adc	r31, r25
    25cc:	86 81       	ldd	r24, Z+6	; 0x06
    25ce:	97 81       	ldd	r25, Z+7	; 0x07
    25d0:	00 97       	sbiw	r24, 0x00	; 0
    25d2:	09 f0       	breq	.+2      	; 0x25d6 <__stack+0x3d7>
    25d4:	fa c0       	rjmp	.+500    	; 0x27ca <__stack+0x5cb>
										{
											if(Blk_Pos[tmp][4]==0)				//Case for (0,0,0,0,1);
    25d6:	fa 01       	movw	r30, r20
    25d8:	ee 0f       	add	r30, r30
    25da:	ff 1f       	adc	r31, r31
    25dc:	c9 01       	movw	r24, r18
    25de:	8e 0f       	add	r24, r30
    25e0:	9f 1f       	adc	r25, r31
    25e2:	f6 01       	movw	r30, r12
    25e4:	e8 0f       	add	r30, r24
    25e6:	f9 1f       	adc	r31, r25
    25e8:	80 85       	ldd	r24, Z+8	; 0x08
    25ea:	91 85       	ldd	r25, Z+9	; 0x09
    25ec:	00 97       	sbiw	r24, 0x00	; 0
    25ee:	09 f0       	breq	.+2      	; 0x25f2 <__stack+0x3f3>
    25f0:	66 c0       	rjmp	.+204    	; 0x26be <__stack+0x4bf>
											{
												forward_wls(1);_delay_ms(500);
    25f2:	81 e0       	ldi	r24, 0x01	; 1
    25f4:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    25f8:	8f ef       	ldi	r24, 0xFF	; 255
    25fa:	9f e7       	ldi	r25, 0x7F	; 127
    25fc:	a6 e1       	ldi	r26, 0x16	; 22
    25fe:	81 50       	subi	r24, 0x01	; 1
    2600:	90 40       	sbci	r25, 0x00	; 0
    2602:	a0 40       	sbci	r26, 0x00	; 0
    2604:	e1 f7       	brne	.-8      	; 0x25fe <__stack+0x3ff>
    2606:	00 c0       	rjmp	.+0      	; 0x2608 <__stack+0x409>
    2608:	00 00       	nop
												Cur_Pos[1]+=1;
    260a:	d8 01       	movw	r26, r16
    260c:	8d 91       	ld	r24, X+
    260e:	9c 91       	ld	r25, X
    2610:	11 97       	sbiw	r26, 0x01	; 1
    2612:	01 96       	adiw	r24, 0x01	; 1
    2614:	11 96       	adiw	r26, 0x01	; 1
    2616:	9c 93       	st	X, r25
    2618:	8e 93       	st	-X, r24
												Sharp_Detection();_delay_ms(500);
    261a:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    261e:	8f ef       	ldi	r24, 0xFF	; 255
    2620:	9f e7       	ldi	r25, 0x7F	; 127
    2622:	a6 e1       	ldi	r26, 0x16	; 22
    2624:	81 50       	subi	r24, 0x01	; 1
    2626:	90 40       	sbci	r25, 0x00	; 0
    2628:	a0 40       	sbci	r26, 0x00	; 0
    262a:	e1 f7       	brne	.-8      	; 0x2624 <__stack+0x425>
    262c:	00 c0       	rjmp	.+0      	; 0x262e <__stack+0x42f>
    262e:	00 00       	nop
												rf(1,1);
    2630:	81 e0       	ldi	r24, 0x01	; 1
    2632:	90 e0       	ldi	r25, 0x00	; 0
    2634:	61 e0       	ldi	r22, 0x01	; 1
    2636:	70 e0       	ldi	r23, 0x00	; 0
    2638:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
												arm(0);_delay_ms(500);
    263c:	80 e0       	ldi	r24, 0x00	; 0
    263e:	90 e0       	ldi	r25, 0x00	; 0
    2640:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2644:	8f ef       	ldi	r24, 0xFF	; 255
    2646:	9f e7       	ldi	r25, 0x7F	; 127
    2648:	a6 e1       	ldi	r26, 0x16	; 22
    264a:	81 50       	subi	r24, 0x01	; 1
    264c:	90 40       	sbci	r25, 0x00	; 0
    264e:	a0 40       	sbci	r26, 0x00	; 0
    2650:	e1 f7       	brne	.-8      	; 0x264a <__stack+0x44b>
    2652:	00 c0       	rjmp	.+0      	; 0x2654 <__stack+0x455>
    2654:	00 00       	nop
												left_degrees(90);_delay_ms(500);
    2656:	8a e5       	ldi	r24, 0x5A	; 90
    2658:	90 e0       	ldi	r25, 0x00	; 0
    265a:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    265e:	8f ef       	ldi	r24, 0xFF	; 255
    2660:	9f e7       	ldi	r25, 0x7F	; 127
    2662:	a6 e1       	ldi	r26, 0x16	; 22
    2664:	81 50       	subi	r24, 0x01	; 1
    2666:	90 40       	sbci	r25, 0x00	; 0
    2668:	a0 40       	sbci	r26, 0x00	; 0
    266a:	e1 f7       	brne	.-8      	; 0x2664 <__stack+0x465>
    266c:	00 c0       	rjmp	.+0      	; 0x266e <__stack+0x46f>
    266e:	00 00       	nop
												lf(1, 1);_delay_ms(500);
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	90 e0       	ldi	r25, 0x00	; 0
    2674:	61 e0       	ldi	r22, 0x01	; 1
    2676:	70 e0       	ldi	r23, 0x00	; 0
    2678:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    267c:	8f ef       	ldi	r24, 0xFF	; 255
    267e:	9f e7       	ldi	r25, 0x7F	; 127
    2680:	a6 e1       	ldi	r26, 0x16	; 22
    2682:	81 50       	subi	r24, 0x01	; 1
    2684:	90 40       	sbci	r25, 0x00	; 0
    2686:	a0 40       	sbci	r26, 0x00	; 0
    2688:	e1 f7       	brne	.-8      	; 0x2682 <__stack+0x483>
    268a:	00 c0       	rjmp	.+0      	; 0x268c <__stack+0x48d>
    268c:	00 00       	nop
												right_wls();_delay_ms(500);
    268e:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2692:	8f ef       	ldi	r24, 0xFF	; 255
    2694:	9f e7       	ldi	r25, 0x7F	; 127
    2696:	a6 e1       	ldi	r26, 0x16	; 22
    2698:	81 50       	subi	r24, 0x01	; 1
    269a:	90 40       	sbci	r25, 0x00	; 0
    269c:	a0 40       	sbci	r26, 0x00	; 0
    269e:	e1 f7       	brne	.-8      	; 0x2698 <__stack+0x499>
    26a0:	00 c0       	rjmp	.+0      	; 0x26a2 <__stack+0x4a3>
    26a2:	00 00       	nop
												if(Cur_Pos[1]==6)
    26a4:	d8 01       	movw	r26, r16
    26a6:	8d 91       	ld	r24, X+
    26a8:	9c 91       	ld	r25, X
    26aa:	11 97       	sbiw	r26, 0x01	; 1
    26ac:	86 30       	cpi	r24, 0x06	; 6
    26ae:	91 05       	cpc	r25, r1
    26b0:	09 f0       	breq	.+2      	; 0x26b4 <__stack+0x4b5>
    26b2:	cc c9       	rjmp	.-3176   	; 0x1a4c <D1+0x2a>
												{
													exit1(1);
    26b4:	81 e0       	ldi	r24, 0x01	; 1
    26b6:	90 e0       	ldi	r25, 0x00	; 0
    26b8:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    26bc:	c7 c9       	rjmp	.-3186   	; 0x1a4c <D1+0x2a>
												}
											
											}
											else								//Case for (1,0,0,0,1)
											{
												forward_wls(1);_delay_ms(500);
    26be:	81 e0       	ldi	r24, 0x01	; 1
    26c0:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    26c4:	8f ef       	ldi	r24, 0xFF	; 255
    26c6:	9f e7       	ldi	r25, 0x7F	; 127
    26c8:	a6 e1       	ldi	r26, 0x16	; 22
    26ca:	81 50       	subi	r24, 0x01	; 1
    26cc:	90 40       	sbci	r25, 0x00	; 0
    26ce:	a0 40       	sbci	r26, 0x00	; 0
    26d0:	e1 f7       	brne	.-8      	; 0x26ca <__stack+0x4cb>
    26d2:	00 c0       	rjmp	.+0      	; 0x26d4 <__stack+0x4d5>
    26d4:	00 00       	nop
												Cur_Pos[1]+=1;
    26d6:	d8 01       	movw	r26, r16
    26d8:	8d 91       	ld	r24, X+
    26da:	9c 91       	ld	r25, X
    26dc:	11 97       	sbiw	r26, 0x01	; 1
    26de:	01 96       	adiw	r24, 0x01	; 1
    26e0:	11 96       	adiw	r26, 0x01	; 1
    26e2:	9c 93       	st	X, r25
    26e4:	8e 93       	st	-X, r24
												Sharp_Detection();_delay_ms(500);
    26e6:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    26ea:	8f ef       	ldi	r24, 0xFF	; 255
    26ec:	9f e7       	ldi	r25, 0x7F	; 127
    26ee:	a6 e1       	ldi	r26, 0x16	; 22
    26f0:	81 50       	subi	r24, 0x01	; 1
    26f2:	90 40       	sbci	r25, 0x00	; 0
    26f4:	a0 40       	sbci	r26, 0x00	; 0
    26f6:	e1 f7       	brne	.-8      	; 0x26f0 <__stack+0x4f1>
    26f8:	00 c0       	rjmp	.+0      	; 0x26fa <__stack+0x4fb>
    26fa:	00 00       	nop
												rf(1, 1);
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	90 e0       	ldi	r25, 0x00	; 0
    2700:	61 e0       	ldi	r22, 0x01	; 1
    2702:	70 e0       	ldi	r23, 0x00	; 0
    2704:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
												arm(0);_delay_ms(500);
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	90 e0       	ldi	r25, 0x00	; 0
    270c:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2710:	8f ef       	ldi	r24, 0xFF	; 255
    2712:	9f e7       	ldi	r25, 0x7F	; 127
    2714:	a6 e1       	ldi	r26, 0x16	; 22
    2716:	81 50       	subi	r24, 0x01	; 1
    2718:	90 40       	sbci	r25, 0x00	; 0
    271a:	a0 40       	sbci	r26, 0x00	; 0
    271c:	e1 f7       	brne	.-8      	; 0x2716 <__stack+0x517>
    271e:	00 c0       	rjmp	.+0      	; 0x2720 <__stack+0x521>
    2720:	00 00       	nop
												left_degrees(90);_delay_ms(500);
    2722:	8a e5       	ldi	r24, 0x5A	; 90
    2724:	90 e0       	ldi	r25, 0x00	; 0
    2726:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    272a:	8f ef       	ldi	r24, 0xFF	; 255
    272c:	9f e7       	ldi	r25, 0x7F	; 127
    272e:	a6 e1       	ldi	r26, 0x16	; 22
    2730:	81 50       	subi	r24, 0x01	; 1
    2732:	90 40       	sbci	r25, 0x00	; 0
    2734:	a0 40       	sbci	r26, 0x00	; 0
    2736:	e1 f7       	brne	.-8      	; 0x2730 <__stack+0x531>
    2738:	00 c0       	rjmp	.+0      	; 0x273a <__stack+0x53b>
    273a:	00 00       	nop
												lf(2, 1);_delay_ms(500);
    273c:	82 e0       	ldi	r24, 0x02	; 2
    273e:	90 e0       	ldi	r25, 0x00	; 0
    2740:	61 e0       	ldi	r22, 0x01	; 1
    2742:	70 e0       	ldi	r23, 0x00	; 0
    2744:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2748:	8f ef       	ldi	r24, 0xFF	; 255
    274a:	9f e7       	ldi	r25, 0x7F	; 127
    274c:	a6 e1       	ldi	r26, 0x16	; 22
    274e:	81 50       	subi	r24, 0x01	; 1
    2750:	90 40       	sbci	r25, 0x00	; 0
    2752:	a0 40       	sbci	r26, 0x00	; 0
    2754:	e1 f7       	brne	.-8      	; 0x274e <__stack+0x54f>
    2756:	00 c0       	rjmp	.+0      	; 0x2758 <__stack+0x559>
    2758:	00 00       	nop
												arm(0);_delay_ms(500);
    275a:	80 e0       	ldi	r24, 0x00	; 0
    275c:	90 e0       	ldi	r25, 0x00	; 0
    275e:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2762:	8f ef       	ldi	r24, 0xFF	; 255
    2764:	9f e7       	ldi	r25, 0x7F	; 127
    2766:	a6 e1       	ldi	r26, 0x16	; 22
    2768:	81 50       	subi	r24, 0x01	; 1
    276a:	90 40       	sbci	r25, 0x00	; 0
    276c:	a0 40       	sbci	r26, 0x00	; 0
    276e:	e1 f7       	brne	.-8      	; 0x2768 <__stack+0x569>
    2770:	00 c0       	rjmp	.+0      	; 0x2772 <__stack+0x573>
    2772:	00 00       	nop
												right_degrees(90);_delay_ms(500);
    2774:	8a e5       	ldi	r24, 0x5A	; 90
    2776:	90 e0       	ldi	r25, 0x00	; 0
    2778:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
    277c:	8f ef       	ldi	r24, 0xFF	; 255
    277e:	9f e7       	ldi	r25, 0x7F	; 127
    2780:	a6 e1       	ldi	r26, 0x16	; 22
    2782:	81 50       	subi	r24, 0x01	; 1
    2784:	90 40       	sbci	r25, 0x00	; 0
    2786:	a0 40       	sbci	r26, 0x00	; 0
    2788:	e1 f7       	brne	.-8      	; 0x2782 <__stack+0x583>
    278a:	00 c0       	rjmp	.+0      	; 0x278c <__stack+0x58d>
    278c:	00 00       	nop
												if(Cur_Pos[1]==6)
    278e:	d8 01       	movw	r26, r16
    2790:	8d 91       	ld	r24, X+
    2792:	9c 91       	ld	r25, X
    2794:	11 97       	sbiw	r26, 0x01	; 1
    2796:	86 30       	cpi	r24, 0x06	; 6
    2798:	91 05       	cpc	r25, r1
    279a:	29 f4       	brne	.+10     	; 0x27a6 <__stack+0x5a7>
												{
													exit1(1);
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	90 e0       	ldi	r25, 0x00	; 0
    27a0:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    27a4:	53 c9       	rjmp	.-3418   	; 0x1a4c <D1+0x2a>
												}
												else
												{
													rf(1,1);
    27a6:	81 e0       	ldi	r24, 0x01	; 1
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	61 e0       	ldi	r22, 0x01	; 1
    27ac:	70 e0       	ldi	r23, 0x00	; 0
    27ae:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
													left_wls();_delay_ms(500);
    27b2:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    27b6:	8f ef       	ldi	r24, 0xFF	; 255
    27b8:	9f e7       	ldi	r25, 0x7F	; 127
    27ba:	a6 e1       	ldi	r26, 0x16	; 22
    27bc:	81 50       	subi	r24, 0x01	; 1
    27be:	90 40       	sbci	r25, 0x00	; 0
    27c0:	a0 40       	sbci	r26, 0x00	; 0
    27c2:	e1 f7       	brne	.-8      	; 0x27bc <__stack+0x5bd>
    27c4:	00 c0       	rjmp	.+0      	; 0x27c6 <__stack+0x5c7>
    27c6:	00 00       	nop
    27c8:	41 c9       	rjmp	.-3454   	; 0x1a4c <D1+0x2a>
												}
											}
										}  
										else
										{
											if(Blk_Pos[tmp][4]==0)				//Case for (0,1,0,0,1)
    27ca:	fa 01       	movw	r30, r20
    27cc:	ee 0f       	add	r30, r30
    27ce:	ff 1f       	adc	r31, r31
    27d0:	ca 01       	movw	r24, r20
    27d2:	88 0f       	add	r24, r24
    27d4:	99 1f       	adc	r25, r25
    27d6:	88 0f       	add	r24, r24
    27d8:	99 1f       	adc	r25, r25
    27da:	88 0f       	add	r24, r24
    27dc:	99 1f       	adc	r25, r25
    27de:	8e 0f       	add	r24, r30
    27e0:	9f 1f       	adc	r25, r31
    27e2:	f6 01       	movw	r30, r12
    27e4:	e8 0f       	add	r30, r24
    27e6:	f9 1f       	adc	r31, r25
    27e8:	80 85       	ldd	r24, Z+8	; 0x08
    27ea:	91 85       	ldd	r25, Z+9	; 0x09
    27ec:	00 97       	sbiw	r24, 0x00	; 0
    27ee:	09 f0       	breq	.+2      	; 0x27f2 <__stack+0x5f3>
    27f0:	82 c0       	rjmp	.+260    	; 0x28f6 <__stack+0x6f7>
											{
												
												forward_wls(1);_delay_ms(500);
    27f2:	81 e0       	ldi	r24, 0x01	; 1
    27f4:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    27f8:	8f ef       	ldi	r24, 0xFF	; 255
    27fa:	9f e7       	ldi	r25, 0x7F	; 127
    27fc:	a6 e1       	ldi	r26, 0x16	; 22
    27fe:	81 50       	subi	r24, 0x01	; 1
    2800:	90 40       	sbci	r25, 0x00	; 0
    2802:	a0 40       	sbci	r26, 0x00	; 0
    2804:	e1 f7       	brne	.-8      	; 0x27fe <__stack+0x5ff>
    2806:	00 c0       	rjmp	.+0      	; 0x2808 <__stack+0x609>
    2808:	00 00       	nop
												Cur_Pos[1]+=1;
    280a:	d8 01       	movw	r26, r16
    280c:	8d 91       	ld	r24, X+
    280e:	9c 91       	ld	r25, X
    2810:	11 97       	sbiw	r26, 0x01	; 1
    2812:	01 96       	adiw	r24, 0x01	; 1
    2814:	11 96       	adiw	r26, 0x01	; 1
    2816:	9c 93       	st	X, r25
    2818:	8e 93       	st	-X, r24
												Sharp_Detection();_delay_ms(500);
    281a:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    281e:	8f ef       	ldi	r24, 0xFF	; 255
    2820:	9f e7       	ldi	r25, 0x7F	; 127
    2822:	a6 e1       	ldi	r26, 0x16	; 22
    2824:	81 50       	subi	r24, 0x01	; 1
    2826:	90 40       	sbci	r25, 0x00	; 0
    2828:	a0 40       	sbci	r26, 0x00	; 0
    282a:	e1 f7       	brne	.-8      	; 0x2824 <__stack+0x625>
    282c:	00 c0       	rjmp	.+0      	; 0x282e <__stack+0x62f>
    282e:	00 00       	nop
												rf(1, 1);_delay_ms(500);
    2830:	81 e0       	ldi	r24, 0x01	; 1
    2832:	90 e0       	ldi	r25, 0x00	; 0
    2834:	61 e0       	ldi	r22, 0x01	; 1
    2836:	70 e0       	ldi	r23, 0x00	; 0
    2838:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    283c:	8f ef       	ldi	r24, 0xFF	; 255
    283e:	9f e7       	ldi	r25, 0x7F	; 127
    2840:	a6 e1       	ldi	r26, 0x16	; 22
    2842:	81 50       	subi	r24, 0x01	; 1
    2844:	90 40       	sbci	r25, 0x00	; 0
    2846:	a0 40       	sbci	r26, 0x00	; 0
    2848:	e1 f7       	brne	.-8      	; 0x2842 <__stack+0x643>
    284a:	00 c0       	rjmp	.+0      	; 0x284c <__stack+0x64d>
    284c:	00 00       	nop
												arm(0);_delay_ms(500);
    284e:	80 e0       	ldi	r24, 0x00	; 0
    2850:	90 e0       	ldi	r25, 0x00	; 0
    2852:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2856:	8f ef       	ldi	r24, 0xFF	; 255
    2858:	9f e7       	ldi	r25, 0x7F	; 127
    285a:	a6 e1       	ldi	r26, 0x16	; 22
    285c:	81 50       	subi	r24, 0x01	; 1
    285e:	90 40       	sbci	r25, 0x00	; 0
    2860:	a0 40       	sbci	r26, 0x00	; 0
    2862:	e1 f7       	brne	.-8      	; 0x285c <__stack+0x65d>
    2864:	00 c0       	rjmp	.+0      	; 0x2866 <__stack+0x667>
    2866:	00 00       	nop
												left_degrees(90);_delay_ms(500);
    2868:	8a e5       	ldi	r24, 0x5A	; 90
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    2870:	8f ef       	ldi	r24, 0xFF	; 255
    2872:	9f e7       	ldi	r25, 0x7F	; 127
    2874:	a6 e1       	ldi	r26, 0x16	; 22
    2876:	81 50       	subi	r24, 0x01	; 1
    2878:	90 40       	sbci	r25, 0x00	; 0
    287a:	a0 40       	sbci	r26, 0x00	; 0
    287c:	e1 f7       	brne	.-8      	; 0x2876 <__stack+0x677>
    287e:	00 c0       	rjmp	.+0      	; 0x2880 <__stack+0x681>
    2880:	00 00       	nop
												lf(1, 1);_delay_ms(500);
    2882:	81 e0       	ldi	r24, 0x01	; 1
    2884:	90 e0       	ldi	r25, 0x00	; 0
    2886:	61 e0       	ldi	r22, 0x01	; 1
    2888:	70 e0       	ldi	r23, 0x00	; 0
    288a:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    288e:	8f ef       	ldi	r24, 0xFF	; 255
    2890:	9f e7       	ldi	r25, 0x7F	; 127
    2892:	a6 e1       	ldi	r26, 0x16	; 22
    2894:	81 50       	subi	r24, 0x01	; 1
    2896:	90 40       	sbci	r25, 0x00	; 0
    2898:	a0 40       	sbci	r26, 0x00	; 0
    289a:	e1 f7       	brne	.-8      	; 0x2894 <__stack+0x695>
    289c:	00 c0       	rjmp	.+0      	; 0x289e <__stack+0x69f>
    289e:	00 00       	nop
												arm(0);_delay_ms(500);
    28a0:	80 e0       	ldi	r24, 0x00	; 0
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    28a8:	8f ef       	ldi	r24, 0xFF	; 255
    28aa:	9f e7       	ldi	r25, 0x7F	; 127
    28ac:	a6 e1       	ldi	r26, 0x16	; 22
    28ae:	81 50       	subi	r24, 0x01	; 1
    28b0:	90 40       	sbci	r25, 0x00	; 0
    28b2:	a0 40       	sbci	r26, 0x00	; 0
    28b4:	e1 f7       	brne	.-8      	; 0x28ae <__stack+0x6af>
    28b6:	00 c0       	rjmp	.+0      	; 0x28b8 <__stack+0x6b9>
    28b8:	00 00       	nop
												right_degrees(90);_delay_ms(500);
    28ba:	8a e5       	ldi	r24, 0x5A	; 90
    28bc:	90 e0       	ldi	r25, 0x00	; 0
    28be:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
    28c2:	8f ef       	ldi	r24, 0xFF	; 255
    28c4:	9f e7       	ldi	r25, 0x7F	; 127
    28c6:	a6 e1       	ldi	r26, 0x16	; 22
    28c8:	81 50       	subi	r24, 0x01	; 1
    28ca:	90 40       	sbci	r25, 0x00	; 0
    28cc:	a0 40       	sbci	r26, 0x00	; 0
    28ce:	e1 f7       	brne	.-8      	; 0x28c8 <__stack+0x6c9>
    28d0:	00 c0       	rjmp	.+0      	; 0x28d2 <__stack+0x6d3>
    28d2:	00 00       	nop
												if(Cur_Pos[1]==5)
    28d4:	d8 01       	movw	r26, r16
    28d6:	8d 91       	ld	r24, X+
    28d8:	9c 91       	ld	r25, X
    28da:	11 97       	sbiw	r26, 0x01	; 1
    28dc:	85 30       	cpi	r24, 0x05	; 5
    28de:	91 05       	cpc	r25, r1
    28e0:	09 f0       	breq	.+2      	; 0x28e4 <__stack+0x6e5>
    28e2:	b4 c8       	rjmp	.-3736   	; 0x1a4c <D1+0x2a>
												{
													back_mm(200);
    28e4:	88 ec       	ldi	r24, 0xC8	; 200
    28e6:	90 e0       	ldi	r25, 0x00	; 0
    28e8:	0e 94 ff 04 	call	0x9fe	; 0x9fe <back_mm>
													exit1(1);
    28ec:	81 e0       	ldi	r24, 0x01	; 1
    28ee:	90 e0       	ldi	r25, 0x00	; 0
    28f0:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    28f4:	ab c8       	rjmp	.-3754   	; 0x1a4c <D1+0x2a>
																		

											}
											else								//Case for (1,1,0,0,1)
											{
												if(Cur_Pos[1]==5)
    28f6:	f8 01       	movw	r30, r16
    28f8:	80 81       	ld	r24, Z
    28fa:	91 81       	ldd	r25, Z+1	; 0x01
    28fc:	85 30       	cpi	r24, 0x05	; 5
    28fe:	91 05       	cpc	r25, r1
    2900:	49 f5       	brne	.+82     	; 0x2954 <__stack+0x755>
												{
													rf(2,1);
    2902:	82 e0       	ldi	r24, 0x02	; 2
    2904:	90 e0       	ldi	r25, 0x00	; 0
    2906:	61 e0       	ldi	r22, 0x01	; 1
    2908:	70 e0       	ldi	r23, 0x00	; 0
    290a:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
													left_wls();
    290e:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
													arm(0);
    2912:	80 e0       	ldi	r24, 0x00	; 0
    2914:	90 e0       	ldi	r25, 0x00	; 0
    2916:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
													lf(3, 0);
    291a:	83 e0       	ldi	r24, 0x03	; 3
    291c:	90 e0       	ldi	r25, 0x00	; 0
    291e:	60 e0       	ldi	r22, 0x00	; 0
    2920:	70 e0       	ldi	r23, 0x00	; 0
    2922:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
													right_wls();
    2926:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
													arm(0);
    292a:	80 e0       	ldi	r24, 0x00	; 0
    292c:	90 e0       	ldi	r25, 0x00	; 0
    292e:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
													lf(1,0);
    2932:	81 e0       	ldi	r24, 0x01	; 1
    2934:	90 e0       	ldi	r25, 0x00	; 0
    2936:	60 e0       	ldi	r22, 0x00	; 0
    2938:	70 e0       	ldi	r23, 0x00	; 0
    293a:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
													right_wls();
    293e:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
													arm(0);
    2942:	80 e0       	ldi	r24, 0x00	; 0
    2944:	90 e0       	ldi	r25, 0x00	; 0
    2946:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
													exit1(0);													
    294a:	80 e0       	ldi	r24, 0x00	; 0
    294c:	90 e0       	ldi	r25, 0x00	; 0
    294e:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    2952:	7c c8       	rjmp	.-3848   	; 0x1a4c <D1+0x2a>
												}
												else
												{
													lf(2,1);_delay_ms(500);
    2954:	82 e0       	ldi	r24, 0x02	; 2
    2956:	90 e0       	ldi	r25, 0x00	; 0
    2958:	61 e0       	ldi	r22, 0x01	; 1
    295a:	70 e0       	ldi	r23, 0x00	; 0
    295c:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2960:	8f ef       	ldi	r24, 0xFF	; 255
    2962:	9f e7       	ldi	r25, 0x7F	; 127
    2964:	a6 e1       	ldi	r26, 0x16	; 22
    2966:	81 50       	subi	r24, 0x01	; 1
    2968:	90 40       	sbci	r25, 0x00	; 0
    296a:	a0 40       	sbci	r26, 0x00	; 0
    296c:	e1 f7       	brne	.-8      	; 0x2966 <__stack+0x767>
    296e:	00 c0       	rjmp	.+0      	; 0x2970 <__stack+0x771>
    2970:	00 00       	nop
													right_wls();_delay_ms(500);
    2972:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2976:	8f ef       	ldi	r24, 0xFF	; 255
    2978:	9f e7       	ldi	r25, 0x7F	; 127
    297a:	a6 e1       	ldi	r26, 0x16	; 22
    297c:	81 50       	subi	r24, 0x01	; 1
    297e:	90 40       	sbci	r25, 0x00	; 0
    2980:	a0 40       	sbci	r26, 0x00	; 0
    2982:	e1 f7       	brne	.-8      	; 0x297c <__stack+0x77d>
    2984:	00 c0       	rjmp	.+0      	; 0x2986 <__stack+0x787>
    2986:	00 00       	nop
													arm(0);_delay_ms(500);
    2988:	80 e0       	ldi	r24, 0x00	; 0
    298a:	90 e0       	ldi	r25, 0x00	; 0
    298c:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2990:	8f ef       	ldi	r24, 0xFF	; 255
    2992:	9f e7       	ldi	r25, 0x7F	; 127
    2994:	a6 e1       	ldi	r26, 0x16	; 22
    2996:	81 50       	subi	r24, 0x01	; 1
    2998:	90 40       	sbci	r25, 0x00	; 0
    299a:	a0 40       	sbci	r26, 0x00	; 0
    299c:	e1 f7       	brne	.-8      	; 0x2996 <__stack+0x797>
    299e:	00 c0       	rjmp	.+0      	; 0x29a0 <__stack+0x7a1>
    29a0:	00 00       	nop
													rf(2, 0);_delay_ms(500);
    29a2:	82 e0       	ldi	r24, 0x02	; 2
    29a4:	90 e0       	ldi	r25, 0x00	; 0
    29a6:	60 e0       	ldi	r22, 0x00	; 0
    29a8:	70 e0       	ldi	r23, 0x00	; 0
    29aa:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    29ae:	8f ef       	ldi	r24, 0xFF	; 255
    29b0:	9f e7       	ldi	r25, 0x7F	; 127
    29b2:	a6 e1       	ldi	r26, 0x16	; 22
    29b4:	81 50       	subi	r24, 0x01	; 1
    29b6:	90 40       	sbci	r25, 0x00	; 0
    29b8:	a0 40       	sbci	r26, 0x00	; 0
    29ba:	e1 f7       	brne	.-8      	; 0x29b4 <__stack+0x7b5>
    29bc:	00 c0       	rjmp	.+0      	; 0x29be <__stack+0x7bf>
    29be:	00 00       	nop
													left_wls();_delay_ms(500);
    29c0:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    29c4:	8f ef       	ldi	r24, 0xFF	; 255
    29c6:	9f e7       	ldi	r25, 0x7F	; 127
    29c8:	a6 e1       	ldi	r26, 0x16	; 22
    29ca:	81 50       	subi	r24, 0x01	; 1
    29cc:	90 40       	sbci	r25, 0x00	; 0
    29ce:	a0 40       	sbci	r26, 0x00	; 0
    29d0:	e1 f7       	brne	.-8      	; 0x29ca <__stack+0x7cb>
    29d2:	00 c0       	rjmp	.+0      	; 0x29d4 <__stack+0x7d5>
    29d4:	00 00       	nop
													forward_wls(1);_delay_ms(500);
    29d6:	81 e0       	ldi	r24, 0x01	; 1
    29d8:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    29dc:	8f ef       	ldi	r24, 0xFF	; 255
    29de:	9f e7       	ldi	r25, 0x7F	; 127
    29e0:	a6 e1       	ldi	r26, 0x16	; 22
    29e2:	81 50       	subi	r24, 0x01	; 1
    29e4:	90 40       	sbci	r25, 0x00	; 0
    29e6:	a0 40       	sbci	r26, 0x00	; 0
    29e8:	e1 f7       	brne	.-8      	; 0x29e2 <__stack+0x7e3>
    29ea:	00 c0       	rjmp	.+0      	; 0x29ec <__stack+0x7ed>
    29ec:	00 00       	nop
													Cur_Pos[1]+=1;
    29ee:	d8 01       	movw	r26, r16
    29f0:	8d 91       	ld	r24, X+
    29f2:	9c 91       	ld	r25, X
    29f4:	11 97       	sbiw	r26, 0x01	; 1
    29f6:	01 96       	adiw	r24, 0x01	; 1
    29f8:	11 96       	adiw	r26, 0x01	; 1
    29fa:	9c 93       	st	X, r25
    29fc:	8e 93       	st	-X, r24
													Sharp_Detection();_delay_ms(500);
    29fe:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    2a02:	8f ef       	ldi	r24, 0xFF	; 255
    2a04:	9f e7       	ldi	r25, 0x7F	; 127
    2a06:	a6 e1       	ldi	r26, 0x16	; 22
    2a08:	81 50       	subi	r24, 0x01	; 1
    2a0a:	90 40       	sbci	r25, 0x00	; 0
    2a0c:	a0 40       	sbci	r26, 0x00	; 0
    2a0e:	e1 f7       	brne	.-8      	; 0x2a08 <__stack+0x809>
    2a10:	00 c0       	rjmp	.+0      	; 0x2a12 <__stack+0x813>
    2a12:	00 00       	nop
													rf(1, 1);
    2a14:	81 e0       	ldi	r24, 0x01	; 1
    2a16:	90 e0       	ldi	r25, 0x00	; 0
    2a18:	61 e0       	ldi	r22, 0x01	; 1
    2a1a:	70 e0       	ldi	r23, 0x00	; 0
    2a1c:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
													arm(0);_delay_ms(500);
    2a20:	80 e0       	ldi	r24, 0x00	; 0
    2a22:	90 e0       	ldi	r25, 0x00	; 0
    2a24:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2a28:	8f ef       	ldi	r24, 0xFF	; 255
    2a2a:	9f e7       	ldi	r25, 0x7F	; 127
    2a2c:	a6 e1       	ldi	r26, 0x16	; 22
    2a2e:	81 50       	subi	r24, 0x01	; 1
    2a30:	90 40       	sbci	r25, 0x00	; 0
    2a32:	a0 40       	sbci	r26, 0x00	; 0
    2a34:	e1 f7       	brne	.-8      	; 0x2a2e <__stack+0x82f>
    2a36:	00 c0       	rjmp	.+0      	; 0x2a38 <__stack+0x839>
    2a38:	00 00       	nop
													left_degrees(90);_delay_ms(500);
    2a3a:	8a e5       	ldi	r24, 0x5A	; 90
    2a3c:	90 e0       	ldi	r25, 0x00	; 0
    2a3e:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    2a42:	8f ef       	ldi	r24, 0xFF	; 255
    2a44:	9f e7       	ldi	r25, 0x7F	; 127
    2a46:	a6 e1       	ldi	r26, 0x16	; 22
    2a48:	81 50       	subi	r24, 0x01	; 1
    2a4a:	90 40       	sbci	r25, 0x00	; 0
    2a4c:	a0 40       	sbci	r26, 0x00	; 0
    2a4e:	e1 f7       	brne	.-8      	; 0x2a48 <__stack+0x849>
    2a50:	00 c0       	rjmp	.+0      	; 0x2a52 <__stack+0x853>
    2a52:	00 00       	nop
													lf(1, 1);_delay_ms(500);
    2a54:	81 e0       	ldi	r24, 0x01	; 1
    2a56:	90 e0       	ldi	r25, 0x00	; 0
    2a58:	61 e0       	ldi	r22, 0x01	; 1
    2a5a:	70 e0       	ldi	r23, 0x00	; 0
    2a5c:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2a60:	8f ef       	ldi	r24, 0xFF	; 255
    2a62:	9f e7       	ldi	r25, 0x7F	; 127
    2a64:	a6 e1       	ldi	r26, 0x16	; 22
    2a66:	81 50       	subi	r24, 0x01	; 1
    2a68:	90 40       	sbci	r25, 0x00	; 0
    2a6a:	a0 40       	sbci	r26, 0x00	; 0
    2a6c:	e1 f7       	brne	.-8      	; 0x2a66 <__stack+0x867>
    2a6e:	00 c0       	rjmp	.+0      	; 0x2a70 <__stack+0x871>
    2a70:	00 00       	nop
													arm(0);_delay_ms(500);
    2a72:	80 e0       	ldi	r24, 0x00	; 0
    2a74:	90 e0       	ldi	r25, 0x00	; 0
    2a76:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2a7a:	8f ef       	ldi	r24, 0xFF	; 255
    2a7c:	9f e7       	ldi	r25, 0x7F	; 127
    2a7e:	a6 e1       	ldi	r26, 0x16	; 22
    2a80:	81 50       	subi	r24, 0x01	; 1
    2a82:	90 40       	sbci	r25, 0x00	; 0
    2a84:	a0 40       	sbci	r26, 0x00	; 0
    2a86:	e1 f7       	brne	.-8      	; 0x2a80 <__stack+0x881>
    2a88:	00 c0       	rjmp	.+0      	; 0x2a8a <__stack+0x88b>
    2a8a:	00 00       	nop
													right_degrees(90);_delay_ms(500);
    2a8c:	8a e5       	ldi	r24, 0x5A	; 90
    2a8e:	90 e0       	ldi	r25, 0x00	; 0
    2a90:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
    2a94:	8f ef       	ldi	r24, 0xFF	; 255
    2a96:	9f e7       	ldi	r25, 0x7F	; 127
    2a98:	a6 e1       	ldi	r26, 0x16	; 22
    2a9a:	81 50       	subi	r24, 0x01	; 1
    2a9c:	90 40       	sbci	r25, 0x00	; 0
    2a9e:	a0 40       	sbci	r26, 0x00	; 0
    2aa0:	e1 f7       	brne	.-8      	; 0x2a9a <__stack+0x89b>
    2aa2:	00 c0       	rjmp	.+0      	; 0x2aa4 <__stack+0x8a5>
    2aa4:	00 00       	nop
    2aa6:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
											}
										}
									}
									else
									{
										if(Blk_Pos[tmp][3]==0)
    2aaa:	ca 01       	movw	r24, r20
    2aac:	88 0f       	add	r24, r24
    2aae:	99 1f       	adc	r25, r25
    2ab0:	9a 01       	movw	r18, r20
    2ab2:	22 0f       	add	r18, r18
    2ab4:	33 1f       	adc	r19, r19
    2ab6:	22 0f       	add	r18, r18
    2ab8:	33 1f       	adc	r19, r19
    2aba:	22 0f       	add	r18, r18
    2abc:	33 1f       	adc	r19, r19
    2abe:	82 0f       	add	r24, r18
    2ac0:	93 1f       	adc	r25, r19
    2ac2:	f6 01       	movw	r30, r12
    2ac4:	e8 0f       	add	r30, r24
    2ac6:	f9 1f       	adc	r31, r25
    2ac8:	86 81       	ldd	r24, Z+6	; 0x06
    2aca:	97 81       	ldd	r25, Z+7	; 0x07
    2acc:	00 97       	sbiw	r24, 0x00	; 0
    2ace:	09 f0       	breq	.+2      	; 0x2ad2 <__stack+0x8d3>
    2ad0:	d1 c1       	rjmp	.+930    	; 0x2e74 <__stack+0xc75>
										{
											if(Blk_Pos[tmp][4]==0)				//Case for (0,0,0,1,1)
    2ad2:	fa 01       	movw	r30, r20
    2ad4:	ee 0f       	add	r30, r30
    2ad6:	ff 1f       	adc	r31, r31
    2ad8:	c9 01       	movw	r24, r18
    2ada:	8e 0f       	add	r24, r30
    2adc:	9f 1f       	adc	r25, r31
    2ade:	f6 01       	movw	r30, r12
    2ae0:	e8 0f       	add	r30, r24
    2ae2:	f9 1f       	adc	r31, r25
    2ae4:	80 85       	ldd	r24, Z+8	; 0x08
    2ae6:	91 85       	ldd	r25, Z+9	; 0x09
    2ae8:	00 97       	sbiw	r24, 0x00	; 0
    2aea:	09 f0       	breq	.+2      	; 0x2aee <__stack+0x8ef>
    2aec:	b9 c0       	rjmp	.+370    	; 0x2c60 <__stack+0xa61>
											{
												rf(2,1);_delay_ms(500);
    2aee:	82 e0       	ldi	r24, 0x02	; 2
    2af0:	90 e0       	ldi	r25, 0x00	; 0
    2af2:	61 e0       	ldi	r22, 0x01	; 1
    2af4:	70 e0       	ldi	r23, 0x00	; 0
    2af6:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    2afa:	8f ef       	ldi	r24, 0xFF	; 255
    2afc:	9f e7       	ldi	r25, 0x7F	; 127
    2afe:	a6 e1       	ldi	r26, 0x16	; 22
    2b00:	81 50       	subi	r24, 0x01	; 1
    2b02:	90 40       	sbci	r25, 0x00	; 0
    2b04:	a0 40       	sbci	r26, 0x00	; 0
    2b06:	e1 f7       	brne	.-8      	; 0x2b00 <__stack+0x901>
    2b08:	00 c0       	rjmp	.+0      	; 0x2b0a <__stack+0x90b>
    2b0a:	00 00       	nop
												left_wls();_delay_ms(500);
    2b0c:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    2b10:	8f ef       	ldi	r24, 0xFF	; 255
    2b12:	9f e7       	ldi	r25, 0x7F	; 127
    2b14:	a6 e1       	ldi	r26, 0x16	; 22
    2b16:	81 50       	subi	r24, 0x01	; 1
    2b18:	90 40       	sbci	r25, 0x00	; 0
    2b1a:	a0 40       	sbci	r26, 0x00	; 0
    2b1c:	e1 f7       	brne	.-8      	; 0x2b16 <__stack+0x917>
    2b1e:	00 c0       	rjmp	.+0      	; 0x2b20 <__stack+0x921>
    2b20:	00 00       	nop
												arm(0);_delay_ms(500);
    2b22:	80 e0       	ldi	r24, 0x00	; 0
    2b24:	90 e0       	ldi	r25, 0x00	; 0
    2b26:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2b2a:	8f ef       	ldi	r24, 0xFF	; 255
    2b2c:	9f e7       	ldi	r25, 0x7F	; 127
    2b2e:	a6 e1       	ldi	r26, 0x16	; 22
    2b30:	81 50       	subi	r24, 0x01	; 1
    2b32:	90 40       	sbci	r25, 0x00	; 0
    2b34:	a0 40       	sbci	r26, 0x00	; 0
    2b36:	e1 f7       	brne	.-8      	; 0x2b30 <__stack+0x931>
    2b38:	00 c0       	rjmp	.+0      	; 0x2b3a <__stack+0x93b>
    2b3a:	00 00       	nop
												if(Cur_Pos[1]==5)
    2b3c:	d8 01       	movw	r26, r16
    2b3e:	8d 91       	ld	r24, X+
    2b40:	9c 91       	ld	r25, X
    2b42:	11 97       	sbiw	r26, 0x01	; 1
    2b44:	85 30       	cpi	r24, 0x05	; 5
    2b46:	91 05       	cpc	r25, r1
    2b48:	69 f5       	brne	.+90     	; 0x2ba4 <__stack+0x9a5>
												{
													lf(1, 0);_delay_ms(500);
    2b4a:	81 e0       	ldi	r24, 0x01	; 1
    2b4c:	90 e0       	ldi	r25, 0x00	; 0
    2b4e:	60 e0       	ldi	r22, 0x00	; 0
    2b50:	70 e0       	ldi	r23, 0x00	; 0
    2b52:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2b56:	8f ef       	ldi	r24, 0xFF	; 255
    2b58:	9f e7       	ldi	r25, 0x7F	; 127
    2b5a:	a6 e1       	ldi	r26, 0x16	; 22
    2b5c:	81 50       	subi	r24, 0x01	; 1
    2b5e:	90 40       	sbci	r25, 0x00	; 0
    2b60:	a0 40       	sbci	r26, 0x00	; 0
    2b62:	e1 f7       	brne	.-8      	; 0x2b5c <__stack+0x95d>
    2b64:	00 c0       	rjmp	.+0      	; 0x2b66 <__stack+0x967>
    2b66:	00 00       	nop
													right_wls();_delay_ms(500);
    2b68:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2b6c:	8f ef       	ldi	r24, 0xFF	; 255
    2b6e:	9f e7       	ldi	r25, 0x7F	; 127
    2b70:	a6 e1       	ldi	r26, 0x16	; 22
    2b72:	81 50       	subi	r24, 0x01	; 1
    2b74:	90 40       	sbci	r25, 0x00	; 0
    2b76:	a0 40       	sbci	r26, 0x00	; 0
    2b78:	e1 f7       	brne	.-8      	; 0x2b72 <__stack+0x973>
    2b7a:	00 c0       	rjmp	.+0      	; 0x2b7c <__stack+0x97d>
    2b7c:	00 00       	nop
													arm(0);_delay_ms(500);
    2b7e:	80 e0       	ldi	r24, 0x00	; 0
    2b80:	90 e0       	ldi	r25, 0x00	; 0
    2b82:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2b86:	8f ef       	ldi	r24, 0xFF	; 255
    2b88:	9f e7       	ldi	r25, 0x7F	; 127
    2b8a:	a6 e1       	ldi	r26, 0x16	; 22
    2b8c:	81 50       	subi	r24, 0x01	; 1
    2b8e:	90 40       	sbci	r25, 0x00	; 0
    2b90:	a0 40       	sbci	r26, 0x00	; 0
    2b92:	e1 f7       	brne	.-8      	; 0x2b8c <__stack+0x98d>
    2b94:	00 c0       	rjmp	.+0      	; 0x2b96 <__stack+0x997>
    2b96:	00 00       	nop
													exit1(0);
    2b98:	80 e0       	ldi	r24, 0x00	; 0
    2b9a:	90 e0       	ldi	r25, 0x00	; 0
    2b9c:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    2ba0:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
												}
												else
												{
												lf(2, 0);_delay_ms(500);
    2ba4:	82 e0       	ldi	r24, 0x02	; 2
    2ba6:	90 e0       	ldi	r25, 0x00	; 0
    2ba8:	60 e0       	ldi	r22, 0x00	; 0
    2baa:	70 e0       	ldi	r23, 0x00	; 0
    2bac:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2bb0:	8f ef       	ldi	r24, 0xFF	; 255
    2bb2:	9f e7       	ldi	r25, 0x7F	; 127
    2bb4:	a6 e1       	ldi	r26, 0x16	; 22
    2bb6:	81 50       	subi	r24, 0x01	; 1
    2bb8:	90 40       	sbci	r25, 0x00	; 0
    2bba:	a0 40       	sbci	r26, 0x00	; 0
    2bbc:	e1 f7       	brne	.-8      	; 0x2bb6 <__stack+0x9b7>
    2bbe:	00 c0       	rjmp	.+0      	; 0x2bc0 <__stack+0x9c1>
    2bc0:	00 00       	nop
												right_wls();_delay_ms(500);
    2bc2:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2bc6:	8f ef       	ldi	r24, 0xFF	; 255
    2bc8:	9f e7       	ldi	r25, 0x7F	; 127
    2bca:	a6 e1       	ldi	r26, 0x16	; 22
    2bcc:	81 50       	subi	r24, 0x01	; 1
    2bce:	90 40       	sbci	r25, 0x00	; 0
    2bd0:	a0 40       	sbci	r26, 0x00	; 0
    2bd2:	e1 f7       	brne	.-8      	; 0x2bcc <__stack+0x9cd>
    2bd4:	00 c0       	rjmp	.+0      	; 0x2bd6 <__stack+0x9d7>
    2bd6:	00 00       	nop
												forward_wls(1);_delay_ms(500);
    2bd8:	81 e0       	ldi	r24, 0x01	; 1
    2bda:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    2bde:	8f ef       	ldi	r24, 0xFF	; 255
    2be0:	9f e7       	ldi	r25, 0x7F	; 127
    2be2:	a6 e1       	ldi	r26, 0x16	; 22
    2be4:	81 50       	subi	r24, 0x01	; 1
    2be6:	90 40       	sbci	r25, 0x00	; 0
    2be8:	a0 40       	sbci	r26, 0x00	; 0
    2bea:	e1 f7       	brne	.-8      	; 0x2be4 <__stack+0x9e5>
    2bec:	00 c0       	rjmp	.+0      	; 0x2bee <__stack+0x9ef>
    2bee:	00 00       	nop
												Cur_Pos[1]+=1;
    2bf0:	d8 01       	movw	r26, r16
    2bf2:	8d 91       	ld	r24, X+
    2bf4:	9c 91       	ld	r25, X
    2bf6:	11 97       	sbiw	r26, 0x01	; 1
    2bf8:	01 96       	adiw	r24, 0x01	; 1
    2bfa:	11 96       	adiw	r26, 0x01	; 1
    2bfc:	9c 93       	st	X, r25
    2bfe:	8e 93       	st	-X, r24
												Sharp_Detection();_delay_ms(500);
    2c00:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    2c04:	8f ef       	ldi	r24, 0xFF	; 255
    2c06:	9f e7       	ldi	r25, 0x7F	; 127
    2c08:	a6 e1       	ldi	r26, 0x16	; 22
    2c0a:	81 50       	subi	r24, 0x01	; 1
    2c0c:	90 40       	sbci	r25, 0x00	; 0
    2c0e:	a0 40       	sbci	r26, 0x00	; 0
    2c10:	e1 f7       	brne	.-8      	; 0x2c0a <__stack+0xa0b>
    2c12:	00 c0       	rjmp	.+0      	; 0x2c14 <__stack+0xa15>
    2c14:	00 00       	nop
												right_wls();_delay_ms(500);
    2c16:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2c1a:	8f ef       	ldi	r24, 0xFF	; 255
    2c1c:	9f e7       	ldi	r25, 0x7F	; 127
    2c1e:	a6 e1       	ldi	r26, 0x16	; 22
    2c20:	81 50       	subi	r24, 0x01	; 1
    2c22:	90 40       	sbci	r25, 0x00	; 0
    2c24:	a0 40       	sbci	r26, 0x00	; 0
    2c26:	e1 f7       	brne	.-8      	; 0x2c20 <__stack+0xa21>
    2c28:	00 c0       	rjmp	.+0      	; 0x2c2a <__stack+0xa2b>
    2c2a:	00 00       	nop
												arm(0);_delay_ms(500);
    2c2c:	80 e0       	ldi	r24, 0x00	; 0
    2c2e:	90 e0       	ldi	r25, 0x00	; 0
    2c30:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2c34:	8f ef       	ldi	r24, 0xFF	; 255
    2c36:	9f e7       	ldi	r25, 0x7F	; 127
    2c38:	a6 e1       	ldi	r26, 0x16	; 22
    2c3a:	81 50       	subi	r24, 0x01	; 1
    2c3c:	90 40       	sbci	r25, 0x00	; 0
    2c3e:	a0 40       	sbci	r26, 0x00	; 0
    2c40:	e1 f7       	brne	.-8      	; 0x2c3a <__stack+0xa3b>
    2c42:	00 c0       	rjmp	.+0      	; 0x2c44 <__stack+0xa45>
    2c44:	00 00       	nop
												left_wls();_delay_ms(500);
    2c46:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    2c4a:	8f ef       	ldi	r24, 0xFF	; 255
    2c4c:	9f e7       	ldi	r25, 0x7F	; 127
    2c4e:	a6 e1       	ldi	r26, 0x16	; 22
    2c50:	81 50       	subi	r24, 0x01	; 1
    2c52:	90 40       	sbci	r25, 0x00	; 0
    2c54:	a0 40       	sbci	r26, 0x00	; 0
    2c56:	e1 f7       	brne	.-8      	; 0x2c50 <__stack+0xa51>
    2c58:	00 c0       	rjmp	.+0      	; 0x2c5a <__stack+0xa5b>
    2c5a:	00 00       	nop
    2c5c:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
												
												}
											}				
											else								//Case for (1,0,0,1,1)
											{
												rf(2,1);_delay_ms(500);
    2c60:	82 e0       	ldi	r24, 0x02	; 2
    2c62:	90 e0       	ldi	r25, 0x00	; 0
    2c64:	61 e0       	ldi	r22, 0x01	; 1
    2c66:	70 e0       	ldi	r23, 0x00	; 0
    2c68:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    2c6c:	8f ef       	ldi	r24, 0xFF	; 255
    2c6e:	9f e7       	ldi	r25, 0x7F	; 127
    2c70:	a6 e1       	ldi	r26, 0x16	; 22
    2c72:	81 50       	subi	r24, 0x01	; 1
    2c74:	90 40       	sbci	r25, 0x00	; 0
    2c76:	a0 40       	sbci	r26, 0x00	; 0
    2c78:	e1 f7       	brne	.-8      	; 0x2c72 <__stack+0xa73>
    2c7a:	00 c0       	rjmp	.+0      	; 0x2c7c <__stack+0xa7d>
    2c7c:	00 00       	nop
												left_wls();_delay_ms(500);
    2c7e:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    2c82:	8f ef       	ldi	r24, 0xFF	; 255
    2c84:	9f e7       	ldi	r25, 0x7F	; 127
    2c86:	a6 e1       	ldi	r26, 0x16	; 22
    2c88:	81 50       	subi	r24, 0x01	; 1
    2c8a:	90 40       	sbci	r25, 0x00	; 0
    2c8c:	a0 40       	sbci	r26, 0x00	; 0
    2c8e:	e1 f7       	brne	.-8      	; 0x2c88 <__stack+0xa89>
    2c90:	00 c0       	rjmp	.+0      	; 0x2c92 <__stack+0xa93>
    2c92:	00 00       	nop
												arm(0);_delay_ms(500);
    2c94:	80 e0       	ldi	r24, 0x00	; 0
    2c96:	90 e0       	ldi	r25, 0x00	; 0
    2c98:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2c9c:	8f ef       	ldi	r24, 0xFF	; 255
    2c9e:	9f e7       	ldi	r25, 0x7F	; 127
    2ca0:	a6 e1       	ldi	r26, 0x16	; 22
    2ca2:	81 50       	subi	r24, 0x01	; 1
    2ca4:	90 40       	sbci	r25, 0x00	; 0
    2ca6:	a0 40       	sbci	r26, 0x00	; 0
    2ca8:	e1 f7       	brne	.-8      	; 0x2ca2 <__stack+0xaa3>
    2caa:	00 c0       	rjmp	.+0      	; 0x2cac <__stack+0xaad>
    2cac:	00 00       	nop
												if(Cur_Pos[1]==5)
    2cae:	d8 01       	movw	r26, r16
    2cb0:	8d 91       	ld	r24, X+
    2cb2:	9c 91       	ld	r25, X
    2cb4:	11 97       	sbiw	r26, 0x01	; 1
    2cb6:	85 30       	cpi	r24, 0x05	; 5
    2cb8:	91 05       	cpc	r25, r1
    2cba:	09 f0       	breq	.+2      	; 0x2cbe <__stack+0xabf>
    2cbc:	54 c0       	rjmp	.+168    	; 0x2d66 <__stack+0xb67>
												{
													lf(1, 0);_delay_ms(500);
    2cbe:	81 e0       	ldi	r24, 0x01	; 1
    2cc0:	90 e0       	ldi	r25, 0x00	; 0
    2cc2:	60 e0       	ldi	r22, 0x00	; 0
    2cc4:	70 e0       	ldi	r23, 0x00	; 0
    2cc6:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2cca:	8f ef       	ldi	r24, 0xFF	; 255
    2ccc:	9f e7       	ldi	r25, 0x7F	; 127
    2cce:	a6 e1       	ldi	r26, 0x16	; 22
    2cd0:	81 50       	subi	r24, 0x01	; 1
    2cd2:	90 40       	sbci	r25, 0x00	; 0
    2cd4:	a0 40       	sbci	r26, 0x00	; 0
    2cd6:	e1 f7       	brne	.-8      	; 0x2cd0 <__stack+0xad1>
    2cd8:	00 c0       	rjmp	.+0      	; 0x2cda <__stack+0xadb>
    2cda:	00 00       	nop
													right_wls();_delay_ms(500);
    2cdc:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2ce0:	8f ef       	ldi	r24, 0xFF	; 255
    2ce2:	9f e7       	ldi	r25, 0x7F	; 127
    2ce4:	a6 e1       	ldi	r26, 0x16	; 22
    2ce6:	81 50       	subi	r24, 0x01	; 1
    2ce8:	90 40       	sbci	r25, 0x00	; 0
    2cea:	a0 40       	sbci	r26, 0x00	; 0
    2cec:	e1 f7       	brne	.-8      	; 0x2ce6 <__stack+0xae7>
    2cee:	00 c0       	rjmp	.+0      	; 0x2cf0 <__stack+0xaf1>
    2cf0:	00 00       	nop
													arm(0);_delay_ms(500);
    2cf2:	80 e0       	ldi	r24, 0x00	; 0
    2cf4:	90 e0       	ldi	r25, 0x00	; 0
    2cf6:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2cfa:	8f ef       	ldi	r24, 0xFF	; 255
    2cfc:	9f e7       	ldi	r25, 0x7F	; 127
    2cfe:	a6 e1       	ldi	r26, 0x16	; 22
    2d00:	81 50       	subi	r24, 0x01	; 1
    2d02:	90 40       	sbci	r25, 0x00	; 0
    2d04:	a0 40       	sbci	r26, 0x00	; 0
    2d06:	e1 f7       	brne	.-8      	; 0x2d00 <__stack+0xb01>
    2d08:	00 c0       	rjmp	.+0      	; 0x2d0a <__stack+0xb0b>
    2d0a:	00 00       	nop
													lf(3, 1);_delay_ms(500);
    2d0c:	83 e0       	ldi	r24, 0x03	; 3
    2d0e:	90 e0       	ldi	r25, 0x00	; 0
    2d10:	61 e0       	ldi	r22, 0x01	; 1
    2d12:	70 e0       	ldi	r23, 0x00	; 0
    2d14:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2d18:	8f ef       	ldi	r24, 0xFF	; 255
    2d1a:	9f e7       	ldi	r25, 0x7F	; 127
    2d1c:	a6 e1       	ldi	r26, 0x16	; 22
    2d1e:	81 50       	subi	r24, 0x01	; 1
    2d20:	90 40       	sbci	r25, 0x00	; 0
    2d22:	a0 40       	sbci	r26, 0x00	; 0
    2d24:	e1 f7       	brne	.-8      	; 0x2d1e <__stack+0xb1f>
    2d26:	00 c0       	rjmp	.+0      	; 0x2d28 <__stack+0xb29>
    2d28:	00 00       	nop
													right_wls();_delay_ms(500);
    2d2a:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2d2e:	8f ef       	ldi	r24, 0xFF	; 255
    2d30:	9f e7       	ldi	r25, 0x7F	; 127
    2d32:	a6 e1       	ldi	r26, 0x16	; 22
    2d34:	81 50       	subi	r24, 0x01	; 1
    2d36:	90 40       	sbci	r25, 0x00	; 0
    2d38:	a0 40       	sbci	r26, 0x00	; 0
    2d3a:	e1 f7       	brne	.-8      	; 0x2d34 <__stack+0xb35>
    2d3c:	00 c0       	rjmp	.+0      	; 0x2d3e <__stack+0xb3f>
    2d3e:	00 00       	nop
													arm(0);_delay_ms(500);
    2d40:	80 e0       	ldi	r24, 0x00	; 0
    2d42:	90 e0       	ldi	r25, 0x00	; 0
    2d44:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2d48:	8f ef       	ldi	r24, 0xFF	; 255
    2d4a:	9f e7       	ldi	r25, 0x7F	; 127
    2d4c:	a6 e1       	ldi	r26, 0x16	; 22
    2d4e:	81 50       	subi	r24, 0x01	; 1
    2d50:	90 40       	sbci	r25, 0x00	; 0
    2d52:	a0 40       	sbci	r26, 0x00	; 0
    2d54:	e1 f7       	brne	.-8      	; 0x2d4e <__stack+0xb4f>
    2d56:	00 c0       	rjmp	.+0      	; 0x2d58 <__stack+0xb59>
    2d58:	00 00       	nop
													exit1(0);
    2d5a:	80 e0       	ldi	r24, 0x00	; 0
    2d5c:	90 e0       	ldi	r25, 0x00	; 0
    2d5e:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    2d62:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
												}
												else
												{
												lf(4, 0);_delay_ms(500);
    2d66:	84 e0       	ldi	r24, 0x04	; 4
    2d68:	90 e0       	ldi	r25, 0x00	; 0
    2d6a:	60 e0       	ldi	r22, 0x00	; 0
    2d6c:	70 e0       	ldi	r23, 0x00	; 0
    2d6e:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2d72:	8f ef       	ldi	r24, 0xFF	; 255
    2d74:	9f e7       	ldi	r25, 0x7F	; 127
    2d76:	a6 e1       	ldi	r26, 0x16	; 22
    2d78:	81 50       	subi	r24, 0x01	; 1
    2d7a:	90 40       	sbci	r25, 0x00	; 0
    2d7c:	a0 40       	sbci	r26, 0x00	; 0
    2d7e:	e1 f7       	brne	.-8      	; 0x2d78 <__stack+0xb79>
    2d80:	00 c0       	rjmp	.+0      	; 0x2d82 <__stack+0xb83>
    2d82:	00 00       	nop
												right_wls();_delay_ms(500);
    2d84:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2d88:	8f ef       	ldi	r24, 0xFF	; 255
    2d8a:	9f e7       	ldi	r25, 0x7F	; 127
    2d8c:	a6 e1       	ldi	r26, 0x16	; 22
    2d8e:	81 50       	subi	r24, 0x01	; 1
    2d90:	90 40       	sbci	r25, 0x00	; 0
    2d92:	a0 40       	sbci	r26, 0x00	; 0
    2d94:	e1 f7       	brne	.-8      	; 0x2d8e <__stack+0xb8f>
    2d96:	00 c0       	rjmp	.+0      	; 0x2d98 <__stack+0xb99>
    2d98:	00 00       	nop
												arm(0);_delay_ms(500);
    2d9a:	80 e0       	ldi	r24, 0x00	; 0
    2d9c:	90 e0       	ldi	r25, 0x00	; 0
    2d9e:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2da2:	8f ef       	ldi	r24, 0xFF	; 255
    2da4:	9f e7       	ldi	r25, 0x7F	; 127
    2da6:	a6 e1       	ldi	r26, 0x16	; 22
    2da8:	81 50       	subi	r24, 0x01	; 1
    2daa:	90 40       	sbci	r25, 0x00	; 0
    2dac:	a0 40       	sbci	r26, 0x00	; 0
    2dae:	e1 f7       	brne	.-8      	; 0x2da8 <__stack+0xba9>
    2db0:	00 c0       	rjmp	.+0      	; 0x2db2 <__stack+0xbb3>
    2db2:	00 00       	nop
												rf(2,0);_delay_ms(500);
    2db4:	82 e0       	ldi	r24, 0x02	; 2
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	60 e0       	ldi	r22, 0x00	; 0
    2dba:	70 e0       	ldi	r23, 0x00	; 0
    2dbc:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    2dc0:	8f ef       	ldi	r24, 0xFF	; 255
    2dc2:	9f e7       	ldi	r25, 0x7F	; 127
    2dc4:	a6 e1       	ldi	r26, 0x16	; 22
    2dc6:	81 50       	subi	r24, 0x01	; 1
    2dc8:	90 40       	sbci	r25, 0x00	; 0
    2dca:	a0 40       	sbci	r26, 0x00	; 0
    2dcc:	e1 f7       	brne	.-8      	; 0x2dc6 <__stack+0xbc7>
    2dce:	00 c0       	rjmp	.+0      	; 0x2dd0 <__stack+0xbd1>
    2dd0:	00 00       	nop
												left_wls();_delay_ms(500);
    2dd2:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    2dd6:	8f ef       	ldi	r24, 0xFF	; 255
    2dd8:	9f e7       	ldi	r25, 0x7F	; 127
    2dda:	a6 e1       	ldi	r26, 0x16	; 22
    2ddc:	81 50       	subi	r24, 0x01	; 1
    2dde:	90 40       	sbci	r25, 0x00	; 0
    2de0:	a0 40       	sbci	r26, 0x00	; 0
    2de2:	e1 f7       	brne	.-8      	; 0x2ddc <__stack+0xbdd>
    2de4:	00 c0       	rjmp	.+0      	; 0x2de6 <__stack+0xbe7>
    2de6:	00 00       	nop
												forward_wls(1);_delay_ms(500);
    2de8:	81 e0       	ldi	r24, 0x01	; 1
    2dea:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    2dee:	8f ef       	ldi	r24, 0xFF	; 255
    2df0:	9f e7       	ldi	r25, 0x7F	; 127
    2df2:	a6 e1       	ldi	r26, 0x16	; 22
    2df4:	81 50       	subi	r24, 0x01	; 1
    2df6:	90 40       	sbci	r25, 0x00	; 0
    2df8:	a0 40       	sbci	r26, 0x00	; 0
    2dfa:	e1 f7       	brne	.-8      	; 0x2df4 <__stack+0xbf5>
    2dfc:	00 c0       	rjmp	.+0      	; 0x2dfe <__stack+0xbff>
    2dfe:	00 00       	nop
												Cur_Pos[1]+=1;
    2e00:	d8 01       	movw	r26, r16
    2e02:	8d 91       	ld	r24, X+
    2e04:	9c 91       	ld	r25, X
    2e06:	11 97       	sbiw	r26, 0x01	; 1
    2e08:	01 96       	adiw	r24, 0x01	; 1
    2e0a:	11 96       	adiw	r26, 0x01	; 1
    2e0c:	9c 93       	st	X, r25
    2e0e:	8e 93       	st	-X, r24
												Sharp_Detection();_delay_ms(500);
    2e10:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    2e14:	8f ef       	ldi	r24, 0xFF	; 255
    2e16:	9f e7       	ldi	r25, 0x7F	; 127
    2e18:	a6 e1       	ldi	r26, 0x16	; 22
    2e1a:	81 50       	subi	r24, 0x01	; 1
    2e1c:	90 40       	sbci	r25, 0x00	; 0
    2e1e:	a0 40       	sbci	r26, 0x00	; 0
    2e20:	e1 f7       	brne	.-8      	; 0x2e1a <__stack+0xc1b>
    2e22:	00 c0       	rjmp	.+0      	; 0x2e24 <__stack+0xc25>
    2e24:	00 00       	nop
												right_wls();_delay_ms(500);
    2e26:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2e2a:	8f ef       	ldi	r24, 0xFF	; 255
    2e2c:	9f e7       	ldi	r25, 0x7F	; 127
    2e2e:	a6 e1       	ldi	r26, 0x16	; 22
    2e30:	81 50       	subi	r24, 0x01	; 1
    2e32:	90 40       	sbci	r25, 0x00	; 0
    2e34:	a0 40       	sbci	r26, 0x00	; 0
    2e36:	e1 f7       	brne	.-8      	; 0x2e30 <__stack+0xc31>
    2e38:	00 c0       	rjmp	.+0      	; 0x2e3a <__stack+0xc3b>
    2e3a:	00 00       	nop
												arm(0);_delay_ms(500);
    2e3c:	80 e0       	ldi	r24, 0x00	; 0
    2e3e:	90 e0       	ldi	r25, 0x00	; 0
    2e40:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2e44:	8f ef       	ldi	r24, 0xFF	; 255
    2e46:	9f e7       	ldi	r25, 0x7F	; 127
    2e48:	a6 e1       	ldi	r26, 0x16	; 22
    2e4a:	81 50       	subi	r24, 0x01	; 1
    2e4c:	90 40       	sbci	r25, 0x00	; 0
    2e4e:	a0 40       	sbci	r26, 0x00	; 0
    2e50:	e1 f7       	brne	.-8      	; 0x2e4a <__stack+0xc4b>
    2e52:	00 c0       	rjmp	.+0      	; 0x2e54 <__stack+0xc55>
    2e54:	00 00       	nop
												left_degrees(90);_delay_ms(500);
    2e56:	8a e5       	ldi	r24, 0x5A	; 90
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    2e5e:	8f ef       	ldi	r24, 0xFF	; 255
    2e60:	9f e7       	ldi	r25, 0x7F	; 127
    2e62:	a6 e1       	ldi	r26, 0x16	; 22
    2e64:	81 50       	subi	r24, 0x01	; 1
    2e66:	90 40       	sbci	r25, 0x00	; 0
    2e68:	a0 40       	sbci	r26, 0x00	; 0
    2e6a:	e1 f7       	brne	.-8      	; 0x2e64 <__stack+0xc65>
    2e6c:	00 c0       	rjmp	.+0      	; 0x2e6e <__stack+0xc6f>
    2e6e:	00 00       	nop
    2e70:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
												}
											}
										}
										else
										{
											if(Blk_Pos[tmp][4]==0)				//Case for (0,1,0,1,1)
    2e74:	fa 01       	movw	r30, r20
    2e76:	ee 0f       	add	r30, r30
    2e78:	ff 1f       	adc	r31, r31
    2e7a:	ca 01       	movw	r24, r20
    2e7c:	88 0f       	add	r24, r24
    2e7e:	99 1f       	adc	r25, r25
    2e80:	88 0f       	add	r24, r24
    2e82:	99 1f       	adc	r25, r25
    2e84:	88 0f       	add	r24, r24
    2e86:	99 1f       	adc	r25, r25
    2e88:	8e 0f       	add	r24, r30
    2e8a:	9f 1f       	adc	r25, r31
    2e8c:	f6 01       	movw	r30, r12
    2e8e:	e8 0f       	add	r30, r24
    2e90:	f9 1f       	adc	r31, r25
    2e92:	80 85       	ldd	r24, Z+8	; 0x08
    2e94:	91 85       	ldd	r25, Z+9	; 0x09
    2e96:	00 97       	sbiw	r24, 0x00	; 0
    2e98:	09 f0       	breq	.+2      	; 0x2e9c <__stack+0xc9d>
    2e9a:	27 c1       	rjmp	.+590    	; 0x30ea <__stack+0xeeb>
											{
												if(Cur_Pos[1]==5)
    2e9c:	d8 01       	movw	r26, r16
    2e9e:	8d 91       	ld	r24, X+
    2ea0:	9c 91       	ld	r25, X
    2ea2:	11 97       	sbiw	r26, 0x01	; 1
    2ea4:	85 30       	cpi	r24, 0x05	; 5
    2ea6:	91 05       	cpc	r25, r1
    2ea8:	09 f0       	breq	.+2      	; 0x2eac <__stack+0xcad>
    2eaa:	7b c0       	rjmp	.+246    	; 0x2fa2 <__stack+0xda3>
												{
													rf(2,1);_delay_ms(500);
    2eac:	82 e0       	ldi	r24, 0x02	; 2
    2eae:	90 e0       	ldi	r25, 0x00	; 0
    2eb0:	61 e0       	ldi	r22, 0x01	; 1
    2eb2:	70 e0       	ldi	r23, 0x00	; 0
    2eb4:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    2eb8:	8f ef       	ldi	r24, 0xFF	; 255
    2eba:	9f e7       	ldi	r25, 0x7F	; 127
    2ebc:	a6 e1       	ldi	r26, 0x16	; 22
    2ebe:	81 50       	subi	r24, 0x01	; 1
    2ec0:	90 40       	sbci	r25, 0x00	; 0
    2ec2:	a0 40       	sbci	r26, 0x00	; 0
    2ec4:	e1 f7       	brne	.-8      	; 0x2ebe <__stack+0xcbf>
    2ec6:	00 c0       	rjmp	.+0      	; 0x2ec8 <__stack+0xcc9>
    2ec8:	00 00       	nop
													left_wls();_delay_ms(500);
    2eca:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    2ece:	8f ef       	ldi	r24, 0xFF	; 255
    2ed0:	9f e7       	ldi	r25, 0x7F	; 127
    2ed2:	a6 e1       	ldi	r26, 0x16	; 22
    2ed4:	81 50       	subi	r24, 0x01	; 1
    2ed6:	90 40       	sbci	r25, 0x00	; 0
    2ed8:	a0 40       	sbci	r26, 0x00	; 0
    2eda:	e1 f7       	brne	.-8      	; 0x2ed4 <__stack+0xcd5>
    2edc:	00 c0       	rjmp	.+0      	; 0x2ede <__stack+0xcdf>
    2ede:	00 00       	nop
													arm(0);_delay_ms(500);
    2ee0:	80 e0       	ldi	r24, 0x00	; 0
    2ee2:	90 e0       	ldi	r25, 0x00	; 0
    2ee4:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2ee8:	8f ef       	ldi	r24, 0xFF	; 255
    2eea:	9f e7       	ldi	r25, 0x7F	; 127
    2eec:	a6 e1       	ldi	r26, 0x16	; 22
    2eee:	81 50       	subi	r24, 0x01	; 1
    2ef0:	90 40       	sbci	r25, 0x00	; 0
    2ef2:	a0 40       	sbci	r26, 0x00	; 0
    2ef4:	e1 f7       	brne	.-8      	; 0x2eee <__stack+0xcef>
    2ef6:	00 c0       	rjmp	.+0      	; 0x2ef8 <__stack+0xcf9>
    2ef8:	00 00       	nop
													lf(1, 0);_delay_ms(500);
    2efa:	81 e0       	ldi	r24, 0x01	; 1
    2efc:	90 e0       	ldi	r25, 0x00	; 0
    2efe:	60 e0       	ldi	r22, 0x00	; 0
    2f00:	70 e0       	ldi	r23, 0x00	; 0
    2f02:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2f06:	8f ef       	ldi	r24, 0xFF	; 255
    2f08:	9f e7       	ldi	r25, 0x7F	; 127
    2f0a:	a6 e1       	ldi	r26, 0x16	; 22
    2f0c:	81 50       	subi	r24, 0x01	; 1
    2f0e:	90 40       	sbci	r25, 0x00	; 0
    2f10:	a0 40       	sbci	r26, 0x00	; 0
    2f12:	e1 f7       	brne	.-8      	; 0x2f0c <__stack+0xd0d>
    2f14:	00 c0       	rjmp	.+0      	; 0x2f16 <__stack+0xd17>
    2f16:	00 00       	nop
													right_wls();_delay_ms(500);
    2f18:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2f1c:	8f ef       	ldi	r24, 0xFF	; 255
    2f1e:	9f e7       	ldi	r25, 0x7F	; 127
    2f20:	a6 e1       	ldi	r26, 0x16	; 22
    2f22:	81 50       	subi	r24, 0x01	; 1
    2f24:	90 40       	sbci	r25, 0x00	; 0
    2f26:	a0 40       	sbci	r26, 0x00	; 0
    2f28:	e1 f7       	brne	.-8      	; 0x2f22 <__stack+0xd23>
    2f2a:	00 c0       	rjmp	.+0      	; 0x2f2c <__stack+0xd2d>
    2f2c:	00 00       	nop
													arm(0);_delay_ms(500);
    2f2e:	80 e0       	ldi	r24, 0x00	; 0
    2f30:	90 e0       	ldi	r25, 0x00	; 0
    2f32:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2f36:	8f ef       	ldi	r24, 0xFF	; 255
    2f38:	9f e7       	ldi	r25, 0x7F	; 127
    2f3a:	a6 e1       	ldi	r26, 0x16	; 22
    2f3c:	81 50       	subi	r24, 0x01	; 1
    2f3e:	90 40       	sbci	r25, 0x00	; 0
    2f40:	a0 40       	sbci	r26, 0x00	; 0
    2f42:	e1 f7       	brne	.-8      	; 0x2f3c <__stack+0xd3d>
    2f44:	00 c0       	rjmp	.+0      	; 0x2f46 <__stack+0xd47>
    2f46:	00 00       	nop
													lf(2, 0);_delay_ms(500);
    2f48:	82 e0       	ldi	r24, 0x02	; 2
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	60 e0       	ldi	r22, 0x00	; 0
    2f4e:	70 e0       	ldi	r23, 0x00	; 0
    2f50:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2f54:	8f ef       	ldi	r24, 0xFF	; 255
    2f56:	9f e7       	ldi	r25, 0x7F	; 127
    2f58:	a6 e1       	ldi	r26, 0x16	; 22
    2f5a:	81 50       	subi	r24, 0x01	; 1
    2f5c:	90 40       	sbci	r25, 0x00	; 0
    2f5e:	a0 40       	sbci	r26, 0x00	; 0
    2f60:	e1 f7       	brne	.-8      	; 0x2f5a <__stack+0xd5b>
    2f62:	00 c0       	rjmp	.+0      	; 0x2f64 <__stack+0xd65>
    2f64:	00 00       	nop
													right_wls();_delay_ms(500);
    2f66:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    2f6a:	8f ef       	ldi	r24, 0xFF	; 255
    2f6c:	9f e7       	ldi	r25, 0x7F	; 127
    2f6e:	a6 e1       	ldi	r26, 0x16	; 22
    2f70:	81 50       	subi	r24, 0x01	; 1
    2f72:	90 40       	sbci	r25, 0x00	; 0
    2f74:	a0 40       	sbci	r26, 0x00	; 0
    2f76:	e1 f7       	brne	.-8      	; 0x2f70 <__stack+0xd71>
    2f78:	00 c0       	rjmp	.+0      	; 0x2f7a <__stack+0xd7b>
    2f7a:	00 00       	nop
													arm(0);_delay_ms(500);
    2f7c:	80 e0       	ldi	r24, 0x00	; 0
    2f7e:	90 e0       	ldi	r25, 0x00	; 0
    2f80:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2f84:	8f ef       	ldi	r24, 0xFF	; 255
    2f86:	9f e7       	ldi	r25, 0x7F	; 127
    2f88:	a6 e1       	ldi	r26, 0x16	; 22
    2f8a:	81 50       	subi	r24, 0x01	; 1
    2f8c:	90 40       	sbci	r25, 0x00	; 0
    2f8e:	a0 40       	sbci	r26, 0x00	; 0
    2f90:	e1 f7       	brne	.-8      	; 0x2f8a <__stack+0xd8b>
    2f92:	00 c0       	rjmp	.+0      	; 0x2f94 <__stack+0xd95>
    2f94:	00 00       	nop
													exit1(0);
    2f96:	80 e0       	ldi	r24, 0x00	; 0
    2f98:	90 e0       	ldi	r25, 0x00	; 0
    2f9a:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    2f9e:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
												}
												else
												{
													rf(2,1);_delay_ms(500);
    2fa2:	82 e0       	ldi	r24, 0x02	; 2
    2fa4:	90 e0       	ldi	r25, 0x00	; 0
    2fa6:	61 e0       	ldi	r22, 0x01	; 1
    2fa8:	70 e0       	ldi	r23, 0x00	; 0
    2faa:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    2fae:	8f ef       	ldi	r24, 0xFF	; 255
    2fb0:	9f e7       	ldi	r25, 0x7F	; 127
    2fb2:	a6 e1       	ldi	r26, 0x16	; 22
    2fb4:	81 50       	subi	r24, 0x01	; 1
    2fb6:	90 40       	sbci	r25, 0x00	; 0
    2fb8:	a0 40       	sbci	r26, 0x00	; 0
    2fba:	e1 f7       	brne	.-8      	; 0x2fb4 <__stack+0xdb5>
    2fbc:	00 c0       	rjmp	.+0      	; 0x2fbe <__stack+0xdbf>
    2fbe:	00 00       	nop
													left_wls();_delay_ms(500);
    2fc0:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    2fc4:	8f ef       	ldi	r24, 0xFF	; 255
    2fc6:	9f e7       	ldi	r25, 0x7F	; 127
    2fc8:	a6 e1       	ldi	r26, 0x16	; 22
    2fca:	81 50       	subi	r24, 0x01	; 1
    2fcc:	90 40       	sbci	r25, 0x00	; 0
    2fce:	a0 40       	sbci	r26, 0x00	; 0
    2fd0:	e1 f7       	brne	.-8      	; 0x2fca <__stack+0xdcb>
    2fd2:	00 c0       	rjmp	.+0      	; 0x2fd4 <__stack+0xdd5>
    2fd4:	00 00       	nop
													arm(0);_delay_ms(500);
    2fd6:	80 e0       	ldi	r24, 0x00	; 0
    2fd8:	90 e0       	ldi	r25, 0x00	; 0
    2fda:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    2fde:	8f ef       	ldi	r24, 0xFF	; 255
    2fe0:	9f e7       	ldi	r25, 0x7F	; 127
    2fe2:	a6 e1       	ldi	r26, 0x16	; 22
    2fe4:	81 50       	subi	r24, 0x01	; 1
    2fe6:	90 40       	sbci	r25, 0x00	; 0
    2fe8:	a0 40       	sbci	r26, 0x00	; 0
    2fea:	e1 f7       	brne	.-8      	; 0x2fe4 <__stack+0xde5>
    2fec:	00 c0       	rjmp	.+0      	; 0x2fee <__stack+0xdef>
    2fee:	00 00       	nop
													lf(2, 0);_delay_ms(500);
    2ff0:	82 e0       	ldi	r24, 0x02	; 2
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	60 e0       	ldi	r22, 0x00	; 0
    2ff6:	70 e0       	ldi	r23, 0x00	; 0
    2ff8:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    2ffc:	8f ef       	ldi	r24, 0xFF	; 255
    2ffe:	9f e7       	ldi	r25, 0x7F	; 127
    3000:	a6 e1       	ldi	r26, 0x16	; 22
    3002:	81 50       	subi	r24, 0x01	; 1
    3004:	90 40       	sbci	r25, 0x00	; 0
    3006:	a0 40       	sbci	r26, 0x00	; 0
    3008:	e1 f7       	brne	.-8      	; 0x3002 <__stack+0xe03>
    300a:	00 c0       	rjmp	.+0      	; 0x300c <__stack+0xe0d>
    300c:	00 00       	nop
													right_wls();_delay_ms(500);
    300e:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    3012:	8f ef       	ldi	r24, 0xFF	; 255
    3014:	9f e7       	ldi	r25, 0x7F	; 127
    3016:	a6 e1       	ldi	r26, 0x16	; 22
    3018:	81 50       	subi	r24, 0x01	; 1
    301a:	90 40       	sbci	r25, 0x00	; 0
    301c:	a0 40       	sbci	r26, 0x00	; 0
    301e:	e1 f7       	brne	.-8      	; 0x3018 <__stack+0xe19>
    3020:	00 c0       	rjmp	.+0      	; 0x3022 <__stack+0xe23>
    3022:	00 00       	nop
													forward_wls(1);_delay_ms(500);
    3024:	81 e0       	ldi	r24, 0x01	; 1
    3026:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    302a:	8f ef       	ldi	r24, 0xFF	; 255
    302c:	9f e7       	ldi	r25, 0x7F	; 127
    302e:	a6 e1       	ldi	r26, 0x16	; 22
    3030:	81 50       	subi	r24, 0x01	; 1
    3032:	90 40       	sbci	r25, 0x00	; 0
    3034:	a0 40       	sbci	r26, 0x00	; 0
    3036:	e1 f7       	brne	.-8      	; 0x3030 <__stack+0xe31>
    3038:	00 c0       	rjmp	.+0      	; 0x303a <__stack+0xe3b>
    303a:	00 00       	nop
													left_wls();_delay_ms(500);
    303c:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    3040:	8f ef       	ldi	r24, 0xFF	; 255
    3042:	9f e7       	ldi	r25, 0x7F	; 127
    3044:	a6 e1       	ldi	r26, 0x16	; 22
    3046:	81 50       	subi	r24, 0x01	; 1
    3048:	90 40       	sbci	r25, 0x00	; 0
    304a:	a0 40       	sbci	r26, 0x00	; 0
    304c:	e1 f7       	brne	.-8      	; 0x3046 <__stack+0xe47>
    304e:	00 c0       	rjmp	.+0      	; 0x3050 <__stack+0xe51>
    3050:	00 00       	nop
													arm(0);_delay_ms(500);
    3052:	80 e0       	ldi	r24, 0x00	; 0
    3054:	90 e0       	ldi	r25, 0x00	; 0
    3056:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    305a:	8f ef       	ldi	r24, 0xFF	; 255
    305c:	9f e7       	ldi	r25, 0x7F	; 127
    305e:	a6 e1       	ldi	r26, 0x16	; 22
    3060:	81 50       	subi	r24, 0x01	; 1
    3062:	90 40       	sbci	r25, 0x00	; 0
    3064:	a0 40       	sbci	r26, 0x00	; 0
    3066:	e1 f7       	brne	.-8      	; 0x3060 <__stack+0xe61>
    3068:	00 c0       	rjmp	.+0      	; 0x306a <__stack+0xe6b>
    306a:	00 00       	nop
													right_degrees(180);
    306c:	84 eb       	ldi	r24, 0xB4	; 180
    306e:	90 e0       	ldi	r25, 0x00	; 0
    3070:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
													arm(0);_delay_ms(500);
    3074:	80 e0       	ldi	r24, 0x00	; 0
    3076:	90 e0       	ldi	r25, 0x00	; 0
    3078:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    307c:	8f ef       	ldi	r24, 0xFF	; 255
    307e:	9f e7       	ldi	r25, 0x7F	; 127
    3080:	a6 e1       	ldi	r26, 0x16	; 22
    3082:	81 50       	subi	r24, 0x01	; 1
    3084:	90 40       	sbci	r25, 0x00	; 0
    3086:	a0 40       	sbci	r26, 0x00	; 0
    3088:	e1 f7       	brne	.-8      	; 0x3082 <__stack+0xe83>
    308a:	00 c0       	rjmp	.+0      	; 0x308c <__stack+0xe8d>
    308c:	00 00       	nop
													left_degrees(90);_delay_ms(500);
    308e:	8a e5       	ldi	r24, 0x5A	; 90
    3090:	90 e0       	ldi	r25, 0x00	; 0
    3092:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    3096:	8f ef       	ldi	r24, 0xFF	; 255
    3098:	9f e7       	ldi	r25, 0x7F	; 127
    309a:	a6 e1       	ldi	r26, 0x16	; 22
    309c:	81 50       	subi	r24, 0x01	; 1
    309e:	90 40       	sbci	r25, 0x00	; 0
    30a0:	a0 40       	sbci	r26, 0x00	; 0
    30a2:	e1 f7       	brne	.-8      	; 0x309c <__stack+0xe9d>
    30a4:	00 c0       	rjmp	.+0      	; 0x30a6 <__stack+0xea7>
    30a6:	00 00       	nop
													forward_wls(1);_delay_ms(500);
    30a8:	81 e0       	ldi	r24, 0x01	; 1
    30aa:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    30ae:	8f ef       	ldi	r24, 0xFF	; 255
    30b0:	9f e7       	ldi	r25, 0x7F	; 127
    30b2:	a6 e1       	ldi	r26, 0x16	; 22
    30b4:	81 50       	subi	r24, 0x01	; 1
    30b6:	90 40       	sbci	r25, 0x00	; 0
    30b8:	a0 40       	sbci	r26, 0x00	; 0
    30ba:	e1 f7       	brne	.-8      	; 0x30b4 <__stack+0xeb5>
    30bc:	00 c0       	rjmp	.+0      	; 0x30be <__stack+0xebf>
    30be:	00 00       	nop
													Cur_Pos[1]+=1;
    30c0:	d8 01       	movw	r26, r16
    30c2:	8d 91       	ld	r24, X+
    30c4:	9c 91       	ld	r25, X
    30c6:	11 97       	sbiw	r26, 0x01	; 1
    30c8:	01 96       	adiw	r24, 0x01	; 1
    30ca:	11 96       	adiw	r26, 0x01	; 1
    30cc:	9c 93       	st	X, r25
    30ce:	8e 93       	st	-X, r24
													Sharp_Detection();_delay_ms(500);
    30d0:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    30d4:	8f ef       	ldi	r24, 0xFF	; 255
    30d6:	9f e7       	ldi	r25, 0x7F	; 127
    30d8:	a6 e1       	ldi	r26, 0x16	; 22
    30da:	81 50       	subi	r24, 0x01	; 1
    30dc:	90 40       	sbci	r25, 0x00	; 0
    30de:	a0 40       	sbci	r26, 0x00	; 0
    30e0:	e1 f7       	brne	.-8      	; 0x30da <__stack+0xedb>
    30e2:	00 c0       	rjmp	.+0      	; 0x30e4 <__stack+0xee5>
    30e4:	00 00       	nop
    30e6:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
												}

											}
											else								//Case for (1,1,0,1,1)
											{
												if(Cur_Pos[1]==5)
    30ea:	d8 01       	movw	r26, r16
    30ec:	8d 91       	ld	r24, X+
    30ee:	9c 91       	ld	r25, X
    30f0:	11 97       	sbiw	r26, 0x01	; 1
    30f2:	85 30       	cpi	r24, 0x05	; 5
    30f4:	91 05       	cpc	r25, r1
    30f6:	09 f0       	breq	.+2      	; 0x30fa <__stack+0xefb>
    30f8:	a2 c0       	rjmp	.+324    	; 0x323e <__stack+0x103f>
												{
													rf(2,1);_delay_ms(500);
    30fa:	82 e0       	ldi	r24, 0x02	; 2
    30fc:	90 e0       	ldi	r25, 0x00	; 0
    30fe:	61 e0       	ldi	r22, 0x01	; 1
    3100:	70 e0       	ldi	r23, 0x00	; 0
    3102:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    3106:	8f ef       	ldi	r24, 0xFF	; 255
    3108:	9f e7       	ldi	r25, 0x7F	; 127
    310a:	a6 e1       	ldi	r26, 0x16	; 22
    310c:	81 50       	subi	r24, 0x01	; 1
    310e:	90 40       	sbci	r25, 0x00	; 0
    3110:	a0 40       	sbci	r26, 0x00	; 0
    3112:	e1 f7       	brne	.-8      	; 0x310c <__stack+0xf0d>
    3114:	00 c0       	rjmp	.+0      	; 0x3116 <__stack+0xf17>
    3116:	00 00       	nop
													left_wls();_delay_ms(500);
    3118:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    311c:	8f ef       	ldi	r24, 0xFF	; 255
    311e:	9f e7       	ldi	r25, 0x7F	; 127
    3120:	a6 e1       	ldi	r26, 0x16	; 22
    3122:	81 50       	subi	r24, 0x01	; 1
    3124:	90 40       	sbci	r25, 0x00	; 0
    3126:	a0 40       	sbci	r26, 0x00	; 0
    3128:	e1 f7       	brne	.-8      	; 0x3122 <__stack+0xf23>
    312a:	00 c0       	rjmp	.+0      	; 0x312c <__stack+0xf2d>
    312c:	00 00       	nop
													arm(0);_delay_ms(500);
    312e:	80 e0       	ldi	r24, 0x00	; 0
    3130:	90 e0       	ldi	r25, 0x00	; 0
    3132:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    3136:	8f ef       	ldi	r24, 0xFF	; 255
    3138:	9f e7       	ldi	r25, 0x7F	; 127
    313a:	a6 e1       	ldi	r26, 0x16	; 22
    313c:	81 50       	subi	r24, 0x01	; 1
    313e:	90 40       	sbci	r25, 0x00	; 0
    3140:	a0 40       	sbci	r26, 0x00	; 0
    3142:	e1 f7       	brne	.-8      	; 0x313c <__stack+0xf3d>
    3144:	00 c0       	rjmp	.+0      	; 0x3146 <__stack+0xf47>
    3146:	00 00       	nop
													lf(1, 0);_delay_ms(500);
    3148:	81 e0       	ldi	r24, 0x01	; 1
    314a:	90 e0       	ldi	r25, 0x00	; 0
    314c:	60 e0       	ldi	r22, 0x00	; 0
    314e:	70 e0       	ldi	r23, 0x00	; 0
    3150:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    3154:	8f ef       	ldi	r24, 0xFF	; 255
    3156:	9f e7       	ldi	r25, 0x7F	; 127
    3158:	a6 e1       	ldi	r26, 0x16	; 22
    315a:	81 50       	subi	r24, 0x01	; 1
    315c:	90 40       	sbci	r25, 0x00	; 0
    315e:	a0 40       	sbci	r26, 0x00	; 0
    3160:	e1 f7       	brne	.-8      	; 0x315a <__stack+0xf5b>
    3162:	00 c0       	rjmp	.+0      	; 0x3164 <__stack+0xf65>
    3164:	00 00       	nop
													right_wls();_delay_ms(500);
    3166:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    316a:	8f ef       	ldi	r24, 0xFF	; 255
    316c:	9f e7       	ldi	r25, 0x7F	; 127
    316e:	a6 e1       	ldi	r26, 0x16	; 22
    3170:	81 50       	subi	r24, 0x01	; 1
    3172:	90 40       	sbci	r25, 0x00	; 0
    3174:	a0 40       	sbci	r26, 0x00	; 0
    3176:	e1 f7       	brne	.-8      	; 0x3170 <__stack+0xf71>
    3178:	00 c0       	rjmp	.+0      	; 0x317a <__stack+0xf7b>
    317a:	00 00       	nop
													arm(0);_delay_ms(500);
    317c:	80 e0       	ldi	r24, 0x00	; 0
    317e:	90 e0       	ldi	r25, 0x00	; 0
    3180:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    3184:	8f ef       	ldi	r24, 0xFF	; 255
    3186:	9f e7       	ldi	r25, 0x7F	; 127
    3188:	a6 e1       	ldi	r26, 0x16	; 22
    318a:	81 50       	subi	r24, 0x01	; 1
    318c:	90 40       	sbci	r25, 0x00	; 0
    318e:	a0 40       	sbci	r26, 0x00	; 0
    3190:	e1 f7       	brne	.-8      	; 0x318a <__stack+0xf8b>
    3192:	00 c0       	rjmp	.+0      	; 0x3194 <__stack+0xf95>
    3194:	00 00       	nop
													lf(2, 0);_delay_ms(500);
    3196:	82 e0       	ldi	r24, 0x02	; 2
    3198:	90 e0       	ldi	r25, 0x00	; 0
    319a:	60 e0       	ldi	r22, 0x00	; 0
    319c:	70 e0       	ldi	r23, 0x00	; 0
    319e:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    31a2:	8f ef       	ldi	r24, 0xFF	; 255
    31a4:	9f e7       	ldi	r25, 0x7F	; 127
    31a6:	a6 e1       	ldi	r26, 0x16	; 22
    31a8:	81 50       	subi	r24, 0x01	; 1
    31aa:	90 40       	sbci	r25, 0x00	; 0
    31ac:	a0 40       	sbci	r26, 0x00	; 0
    31ae:	e1 f7       	brne	.-8      	; 0x31a8 <__stack+0xfa9>
    31b0:	00 c0       	rjmp	.+0      	; 0x31b2 <__stack+0xfb3>
    31b2:	00 00       	nop
													right_wls();_delay_ms(500);
    31b4:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    31b8:	8f ef       	ldi	r24, 0xFF	; 255
    31ba:	9f e7       	ldi	r25, 0x7F	; 127
    31bc:	a6 e1       	ldi	r26, 0x16	; 22
    31be:	81 50       	subi	r24, 0x01	; 1
    31c0:	90 40       	sbci	r25, 0x00	; 0
    31c2:	a0 40       	sbci	r26, 0x00	; 0
    31c4:	e1 f7       	brne	.-8      	; 0x31be <__stack+0xfbf>
    31c6:	00 c0       	rjmp	.+0      	; 0x31c8 <__stack+0xfc9>
    31c8:	00 00       	nop
													arm(0);_delay_ms(500);
    31ca:	80 e0       	ldi	r24, 0x00	; 0
    31cc:	90 e0       	ldi	r25, 0x00	; 0
    31ce:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    31d2:	8f ef       	ldi	r24, 0xFF	; 255
    31d4:	9f e7       	ldi	r25, 0x7F	; 127
    31d6:	a6 e1       	ldi	r26, 0x16	; 22
    31d8:	81 50       	subi	r24, 0x01	; 1
    31da:	90 40       	sbci	r25, 0x00	; 0
    31dc:	a0 40       	sbci	r26, 0x00	; 0
    31de:	e1 f7       	brne	.-8      	; 0x31d8 <__stack+0xfd9>
    31e0:	00 c0       	rjmp	.+0      	; 0x31e2 <__stack+0xfe3>
    31e2:	00 00       	nop
													lf(1, 0);_delay_ms(500);
    31e4:	81 e0       	ldi	r24, 0x01	; 1
    31e6:	90 e0       	ldi	r25, 0x00	; 0
    31e8:	60 e0       	ldi	r22, 0x00	; 0
    31ea:	70 e0       	ldi	r23, 0x00	; 0
    31ec:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    31f0:	8f ef       	ldi	r24, 0xFF	; 255
    31f2:	9f e7       	ldi	r25, 0x7F	; 127
    31f4:	a6 e1       	ldi	r26, 0x16	; 22
    31f6:	81 50       	subi	r24, 0x01	; 1
    31f8:	90 40       	sbci	r25, 0x00	; 0
    31fa:	a0 40       	sbci	r26, 0x00	; 0
    31fc:	e1 f7       	brne	.-8      	; 0x31f6 <__stack+0xff7>
    31fe:	00 c0       	rjmp	.+0      	; 0x3200 <__stack+0x1001>
    3200:	00 00       	nop
													right_wls();_delay_ms(500);
    3202:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    3206:	8f ef       	ldi	r24, 0xFF	; 255
    3208:	9f e7       	ldi	r25, 0x7F	; 127
    320a:	a6 e1       	ldi	r26, 0x16	; 22
    320c:	81 50       	subi	r24, 0x01	; 1
    320e:	90 40       	sbci	r25, 0x00	; 0
    3210:	a0 40       	sbci	r26, 0x00	; 0
    3212:	e1 f7       	brne	.-8      	; 0x320c <__stack+0x100d>
    3214:	00 c0       	rjmp	.+0      	; 0x3216 <__stack+0x1017>
    3216:	00 00       	nop
													arm(0);_delay_ms(500);
    3218:	80 e0       	ldi	r24, 0x00	; 0
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    3220:	8f ef       	ldi	r24, 0xFF	; 255
    3222:	9f e7       	ldi	r25, 0x7F	; 127
    3224:	a6 e1       	ldi	r26, 0x16	; 22
    3226:	81 50       	subi	r24, 0x01	; 1
    3228:	90 40       	sbci	r25, 0x00	; 0
    322a:	a0 40       	sbci	r26, 0x00	; 0
    322c:	e1 f7       	brne	.-8      	; 0x3226 <__stack+0x1027>
    322e:	00 c0       	rjmp	.+0      	; 0x3230 <__stack+0x1031>
    3230:	00 00       	nop
													exit1(0);
    3232:	80 e0       	ldi	r24, 0x00	; 0
    3234:	90 e0       	ldi	r25, 0x00	; 0
    3236:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
    323a:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
												}
												else
												{
													rf(2, 1);_delay_ms(500);
    323e:	82 e0       	ldi	r24, 0x02	; 2
    3240:	90 e0       	ldi	r25, 0x00	; 0
    3242:	61 e0       	ldi	r22, 0x01	; 1
    3244:	70 e0       	ldi	r23, 0x00	; 0
    3246:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    324a:	8f ef       	ldi	r24, 0xFF	; 255
    324c:	9f e7       	ldi	r25, 0x7F	; 127
    324e:	a6 e1       	ldi	r26, 0x16	; 22
    3250:	81 50       	subi	r24, 0x01	; 1
    3252:	90 40       	sbci	r25, 0x00	; 0
    3254:	a0 40       	sbci	r26, 0x00	; 0
    3256:	e1 f7       	brne	.-8      	; 0x3250 <__stack+0x1051>
    3258:	00 c0       	rjmp	.+0      	; 0x325a <__stack+0x105b>
    325a:	00 00       	nop
													left_wls();_delay_ms(500);
    325c:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    3260:	8f ef       	ldi	r24, 0xFF	; 255
    3262:	9f e7       	ldi	r25, 0x7F	; 127
    3264:	a6 e1       	ldi	r26, 0x16	; 22
    3266:	81 50       	subi	r24, 0x01	; 1
    3268:	90 40       	sbci	r25, 0x00	; 0
    326a:	a0 40       	sbci	r26, 0x00	; 0
    326c:	e1 f7       	brne	.-8      	; 0x3266 <__stack+0x1067>
    326e:	00 c0       	rjmp	.+0      	; 0x3270 <__stack+0x1071>
    3270:	00 00       	nop
													arm(0);_delay_ms(500);
    3272:	80 e0       	ldi	r24, 0x00	; 0
    3274:	90 e0       	ldi	r25, 0x00	; 0
    3276:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    327a:	8f ef       	ldi	r24, 0xFF	; 255
    327c:	9f e7       	ldi	r25, 0x7F	; 127
    327e:	a6 e1       	ldi	r26, 0x16	; 22
    3280:	81 50       	subi	r24, 0x01	; 1
    3282:	90 40       	sbci	r25, 0x00	; 0
    3284:	a0 40       	sbci	r26, 0x00	; 0
    3286:	e1 f7       	brne	.-8      	; 0x3280 <__stack+0x1081>
    3288:	00 c0       	rjmp	.+0      	; 0x328a <__stack+0x108b>
    328a:	00 00       	nop
													lf(4,0);_delay_ms(500);
    328c:	84 e0       	ldi	r24, 0x04	; 4
    328e:	90 e0       	ldi	r25, 0x00	; 0
    3290:	60 e0       	ldi	r22, 0x00	; 0
    3292:	70 e0       	ldi	r23, 0x00	; 0
    3294:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <lf>
    3298:	8f ef       	ldi	r24, 0xFF	; 255
    329a:	9f e7       	ldi	r25, 0x7F	; 127
    329c:	a6 e1       	ldi	r26, 0x16	; 22
    329e:	81 50       	subi	r24, 0x01	; 1
    32a0:	90 40       	sbci	r25, 0x00	; 0
    32a2:	a0 40       	sbci	r26, 0x00	; 0
    32a4:	e1 f7       	brne	.-8      	; 0x329e <__stack+0x109f>
    32a6:	00 c0       	rjmp	.+0      	; 0x32a8 <__stack+0x10a9>
    32a8:	00 00       	nop
													right_wls();_delay_ms(500);
    32aa:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
    32ae:	8f ef       	ldi	r24, 0xFF	; 255
    32b0:	9f e7       	ldi	r25, 0x7F	; 127
    32b2:	a6 e1       	ldi	r26, 0x16	; 22
    32b4:	81 50       	subi	r24, 0x01	; 1
    32b6:	90 40       	sbci	r25, 0x00	; 0
    32b8:	a0 40       	sbci	r26, 0x00	; 0
    32ba:	e1 f7       	brne	.-8      	; 0x32b4 <__stack+0x10b5>
    32bc:	00 c0       	rjmp	.+0      	; 0x32be <__stack+0x10bf>
    32be:	00 00       	nop
													arm(0);_delay_ms(500);
    32c0:	80 e0       	ldi	r24, 0x00	; 0
    32c2:	90 e0       	ldi	r25, 0x00	; 0
    32c4:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    32c8:	8f ef       	ldi	r24, 0xFF	; 255
    32ca:	9f e7       	ldi	r25, 0x7F	; 127
    32cc:	a6 e1       	ldi	r26, 0x16	; 22
    32ce:	81 50       	subi	r24, 0x01	; 1
    32d0:	90 40       	sbci	r25, 0x00	; 0
    32d2:	a0 40       	sbci	r26, 0x00	; 0
    32d4:	e1 f7       	brne	.-8      	; 0x32ce <__stack+0x10cf>
    32d6:	00 c0       	rjmp	.+0      	; 0x32d8 <__stack+0x10d9>
    32d8:	00 00       	nop
													rf(2, 0);_delay_ms(500);
    32da:	82 e0       	ldi	r24, 0x02	; 2
    32dc:	90 e0       	ldi	r25, 0x00	; 0
    32de:	60 e0       	ldi	r22, 0x00	; 0
    32e0:	70 e0       	ldi	r23, 0x00	; 0
    32e2:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
    32e6:	8f ef       	ldi	r24, 0xFF	; 255
    32e8:	9f e7       	ldi	r25, 0x7F	; 127
    32ea:	a6 e1       	ldi	r26, 0x16	; 22
    32ec:	81 50       	subi	r24, 0x01	; 1
    32ee:	90 40       	sbci	r25, 0x00	; 0
    32f0:	a0 40       	sbci	r26, 0x00	; 0
    32f2:	e1 f7       	brne	.-8      	; 0x32ec <__stack+0x10ed>
    32f4:	00 c0       	rjmp	.+0      	; 0x32f6 <__stack+0x10f7>
    32f6:	00 00       	nop
													left_wls();_delay_ms(500);
    32f8:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    32fc:	8f ef       	ldi	r24, 0xFF	; 255
    32fe:	9f e7       	ldi	r25, 0x7F	; 127
    3300:	a6 e1       	ldi	r26, 0x16	; 22
    3302:	81 50       	subi	r24, 0x01	; 1
    3304:	90 40       	sbci	r25, 0x00	; 0
    3306:	a0 40       	sbci	r26, 0x00	; 0
    3308:	e1 f7       	brne	.-8      	; 0x3302 <__stack+0x1103>
    330a:	00 c0       	rjmp	.+0      	; 0x330c <__stack+0x110d>
    330c:	00 00       	nop
													forward_wls(1);_delay_ms(500);
    330e:	81 e0       	ldi	r24, 0x01	; 1
    3310:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    3314:	8f ef       	ldi	r24, 0xFF	; 255
    3316:	9f e7       	ldi	r25, 0x7F	; 127
    3318:	a6 e1       	ldi	r26, 0x16	; 22
    331a:	81 50       	subi	r24, 0x01	; 1
    331c:	90 40       	sbci	r25, 0x00	; 0
    331e:	a0 40       	sbci	r26, 0x00	; 0
    3320:	e1 f7       	brne	.-8      	; 0x331a <__stack+0x111b>
    3322:	00 c0       	rjmp	.+0      	; 0x3324 <__stack+0x1125>
    3324:	00 00       	nop
													left_wls();_delay_ms(500);
    3326:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
    332a:	8f ef       	ldi	r24, 0xFF	; 255
    332c:	9f e7       	ldi	r25, 0x7F	; 127
    332e:	a6 e1       	ldi	r26, 0x16	; 22
    3330:	81 50       	subi	r24, 0x01	; 1
    3332:	90 40       	sbci	r25, 0x00	; 0
    3334:	a0 40       	sbci	r26, 0x00	; 0
    3336:	e1 f7       	brne	.-8      	; 0x3330 <__stack+0x1131>
    3338:	00 c0       	rjmp	.+0      	; 0x333a <__stack+0x113b>
    333a:	00 00       	nop
													arm(0);_delay_ms(500);
    333c:	80 e0       	ldi	r24, 0x00	; 0
    333e:	90 e0       	ldi	r25, 0x00	; 0
    3340:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    3344:	8f ef       	ldi	r24, 0xFF	; 255
    3346:	9f e7       	ldi	r25, 0x7F	; 127
    3348:	a6 e1       	ldi	r26, 0x16	; 22
    334a:	81 50       	subi	r24, 0x01	; 1
    334c:	90 40       	sbci	r25, 0x00	; 0
    334e:	a0 40       	sbci	r26, 0x00	; 0
    3350:	e1 f7       	brne	.-8      	; 0x334a <__stack+0x114b>
    3352:	00 c0       	rjmp	.+0      	; 0x3354 <__stack+0x1155>
    3354:	00 00       	nop
													right_degrees(180);
    3356:	84 eb       	ldi	r24, 0xB4	; 180
    3358:	90 e0       	ldi	r25, 0x00	; 0
    335a:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
													arm(0);_delay_ms(500);
    335e:	80 e0       	ldi	r24, 0x00	; 0
    3360:	90 e0       	ldi	r25, 0x00	; 0
    3362:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
    3366:	8f ef       	ldi	r24, 0xFF	; 255
    3368:	9f e7       	ldi	r25, 0x7F	; 127
    336a:	a6 e1       	ldi	r26, 0x16	; 22
    336c:	81 50       	subi	r24, 0x01	; 1
    336e:	90 40       	sbci	r25, 0x00	; 0
    3370:	a0 40       	sbci	r26, 0x00	; 0
    3372:	e1 f7       	brne	.-8      	; 0x336c <__stack+0x116d>
    3374:	00 c0       	rjmp	.+0      	; 0x3376 <__stack+0x1177>
    3376:	00 00       	nop
													left_degrees(90);_delay_ms(500);
    3378:	8a e5       	ldi	r24, 0x5A	; 90
    337a:	90 e0       	ldi	r25, 0x00	; 0
    337c:	0e 94 17 05 	call	0xa2e	; 0xa2e <left_degrees>
    3380:	8f ef       	ldi	r24, 0xFF	; 255
    3382:	9f e7       	ldi	r25, 0x7F	; 127
    3384:	a6 e1       	ldi	r26, 0x16	; 22
    3386:	81 50       	subi	r24, 0x01	; 1
    3388:	90 40       	sbci	r25, 0x00	; 0
    338a:	a0 40       	sbci	r26, 0x00	; 0
    338c:	e1 f7       	brne	.-8      	; 0x3386 <__stack+0x1187>
    338e:	00 c0       	rjmp	.+0      	; 0x3390 <__stack+0x1191>
    3390:	00 00       	nop
													forward_wls(1);_delay_ms(500);
    3392:	81 e0       	ldi	r24, 0x01	; 1
    3394:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    3398:	8f ef       	ldi	r24, 0xFF	; 255
    339a:	9f e7       	ldi	r25, 0x7F	; 127
    339c:	a6 e1       	ldi	r26, 0x16	; 22
    339e:	81 50       	subi	r24, 0x01	; 1
    33a0:	90 40       	sbci	r25, 0x00	; 0
    33a2:	a0 40       	sbci	r26, 0x00	; 0
    33a4:	e1 f7       	brne	.-8      	; 0x339e <__stack+0x119f>
    33a6:	00 c0       	rjmp	.+0      	; 0x33a8 <__stack+0x11a9>
    33a8:	00 00       	nop
													Cur_Pos[1]+=1;
    33aa:	d8 01       	movw	r26, r16
    33ac:	8d 91       	ld	r24, X+
    33ae:	9c 91       	ld	r25, X
    33b0:	11 97       	sbiw	r26, 0x01	; 1
    33b2:	01 96       	adiw	r24, 0x01	; 1
    33b4:	11 96       	adiw	r26, 0x01	; 1
    33b6:	9c 93       	st	X, r25
    33b8:	8e 93       	st	-X, r24
													Sharp_Detection();_delay_ms(500);
    33ba:	0e 94 ac 05 	call	0xb58	; 0xb58 <Sharp_Detection>
    33be:	8f ef       	ldi	r24, 0xFF	; 255
    33c0:	9f e7       	ldi	r25, 0x7F	; 127
    33c2:	a6 e1       	ldi	r26, 0x16	; 22
    33c4:	81 50       	subi	r24, 0x01	; 1
    33c6:	90 40       	sbci	r25, 0x00	; 0
    33c8:	a0 40       	sbci	r26, 0x00	; 0
    33ca:	e1 f7       	brne	.-8      	; 0x33c4 <__stack+0x11c5>
    33cc:	00 c0       	rjmp	.+0      	; 0x33ce <__stack+0x11cf>
    33ce:	00 00       	nop
    33d0:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
							}					
						}					
					}
			else
			{
				/*Actual Buzzer sound*/buzzer_on();_delay_ms(1000);buzzer_off();
    33d4:	0e 94 cf 02 	call	0x59e	; 0x59e <buzzer_on>
    33d8:	8f ef       	ldi	r24, 0xFF	; 255
    33da:	9f ef       	ldi	r25, 0xFF	; 255
    33dc:	ac e2       	ldi	r26, 0x2C	; 44
    33de:	81 50       	subi	r24, 0x01	; 1
    33e0:	90 40       	sbci	r25, 0x00	; 0
    33e2:	a0 40       	sbci	r26, 0x00	; 0
    33e4:	e1 f7       	brne	.-8      	; 0x33de <__stack+0x11df>
    33e6:	00 c0       	rjmp	.+0      	; 0x33e8 <__stack+0x11e9>
    33e8:	00 00       	nop
    33ea:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <buzzer_off>
				forward_wls(5-Cur_Pos[0]);
    33ee:	88 81       	ld	r24, Y
    33f0:	99 81       	ldd	r25, Y+1	; 0x01
    33f2:	af 2d       	mov	r26, r15
    33f4:	a8 1b       	sub	r26, r24
    33f6:	8a 2f       	mov	r24, r26
    33f8:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
				exit1(1);
    33fc:	81 e0       	ldi	r24, 0x01	; 1
    33fe:	90 e0       	ldi	r25, 0x00	; 0
    3400:	0e 94 8d 0c 	call	0x191a	; 0x191a <exit1>
				Cur_Pos[0]=0;
    3404:	19 82       	std	Y+1, r1	; 0x01
    3406:	18 82       	st	Y, r1
    3408:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <D1+0x2a>
			}
			}
			else
				break;
			}
}
    340c:	df 91       	pop	r29
    340e:	cf 91       	pop	r28
    3410:	1f 91       	pop	r17
    3412:	0f 91       	pop	r16
    3414:	ff 90       	pop	r15
    3416:	df 90       	pop	r13
    3418:	cf 90       	pop	r12
    341a:	08 95       	ret

0000341c <D2>:
* Logic: Function for sorting blocks in D1
* Example Call: D2();
*	
*/							
void D2(void)
{
    341c:	af 92       	push	r10
    341e:	bf 92       	push	r11
    3420:	cf 92       	push	r12
    3422:	df 92       	push	r13
    3424:	ef 92       	push	r14
    3426:	ff 92       	push	r15
    3428:	0f 93       	push	r16
    342a:	1f 93       	push	r17
    342c:	cf 93       	push	r28
    342e:	df 93       	push	r29
					{
						//Go and check
						//Stop at every node and check
						forward_wlsD2(n-1);
						arm(1);
						if(Blk_Pos[Cur_Pos[1]+1][Cur_Pos[0]]==1)	//If block exists to the north of the current block, it sorts it and moves to position (CurrentRow+2)7 or else if it is on row 2 it sorts both blocks and exits.
    3430:	c2 e0       	ldi	r28, 0x02	; 2
    3432:	d2 e0       	ldi	r29, 0x02	; 2
    3434:	8e 01       	movw	r16, r28
    3436:	02 50       	subi	r16, 0x02	; 2
    3438:	10 40       	sbci	r17, 0x00	; 0
    343a:	0f 2e       	mov	r0, r31
    343c:	f8 e0       	ldi	r31, 0x08	; 8
    343e:	ef 2e       	mov	r14, r31
    3440:	f2 e0       	ldi	r31, 0x02	; 2
    3442:	ff 2e       	mov	r15, r31
    3444:	f0 2d       	mov	r31, r0
						{
							right_wls();
							forward_wls(1);
							left_wls();
							arm(1);
							Blk_Pos[Cur_Pos[1]][Cur_Pos[0]+1]=2;
    3446:	cc 24       	eor	r12, r12
    3448:	dd 24       	eor	r13, r13
    344a:	68 94       	set
    344c:	c1 f8       	bld	r12, 1
							{
								exit2();
							}
							else
							{
								rf(Cur_Pos[0]-1,1);
    344e:	0f 2e       	mov	r0, r31
    3450:	f0 e0       	ldi	r31, 0x00	; 0
    3452:	af 2e       	mov	r10, r31
    3454:	f2 e0       	ldi	r31, 0x02	; 2
    3456:	bf 2e       	mov	r11, r31
    3458:	f0 2d       	mov	r31, r0
*/							
void D2(void)
{
	while(1)
	{
			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    345a:	83 e0       	ldi	r24, 0x03	; 3
    345c:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    3460:	80 93 50 02 	sts	0x0250, r24
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    3464:	82 e0       	ldi	r24, 0x02	; 2
    3466:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    346a:	80 93 4f 02 	sts	0x024F, r24
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    346e:	81 e0       	ldi	r24, 0x01	; 1
    3470:	0e 94 24 03 	call	0x648	; 0x648 <ADC_Conversion>
    3474:	80 93 4e 02 	sts	0x024E, r24
			if(flag==2)								//Runs only of flag is 2
    3478:	80 91 51 02 	lds	r24, 0x0251
    347c:	82 30       	cpi	r24, 0x02	; 2
    347e:	09 f0       	breq	.+2      	; 0x3482 <D2+0x66>
    3480:	31 c1       	rjmp	.+610    	; 0x36e4 <D2+0x2c8>
			{
				if(count2<5)						//Exits if the the count exceeds 4
    3482:	80 91 04 02 	lds	r24, 0x0204
    3486:	90 91 05 02 	lds	r25, 0x0205
    348a:	85 30       	cpi	r24, 0x05	; 5
    348c:	91 05       	cpc	r25, r1
    348e:	08 f0       	brcs	.+2      	; 0x3492 <D2+0x76>
    3490:	26 c1       	rjmp	.+588    	; 0x36de <D2+0x2c2>
				{
					int n=SharpTwist();				//Calls SharpTwist in order to find the blocks in the current row.
    3492:	0e 94 7a 07 	call	0xef4	; 0xef4 <SharpTwist>
					if(n!=0)						//Enters condition, if incorrectly placed blocks are found
    3496:	88 23       	and	r24, r24
    3498:	09 f4       	brne	.+2      	; 0x349c <D2+0x80>
    349a:	1d c1       	rjmp	.+570    	; 0x36d6 <D2+0x2ba>
					{
						//Go and check
						//Stop at every node and check
						forward_wlsD2(n-1);
    349c:	81 50       	subi	r24, 0x01	; 1
    349e:	0e 94 97 06 	call	0xd2e	; 0xd2e <forward_wlsD2>
						arm(1);
    34a2:	81 e0       	ldi	r24, 0x01	; 1
    34a4:	90 e0       	ldi	r25, 0x00	; 0
    34a6:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
						if(Blk_Pos[Cur_Pos[1]+1][Cur_Pos[0]]==1)	//If block exists to the north of the current block, it sorts it and moves to position (CurrentRow+2)7 or else if it is on row 2 it sorts both blocks and exits.
    34aa:	88 81       	ld	r24, Y
    34ac:	99 81       	ldd	r25, Y+1	; 0x01
    34ae:	01 96       	adiw	r24, 0x01	; 1
    34b0:	f8 01       	movw	r30, r16
    34b2:	40 81       	ld	r20, Z
    34b4:	51 81       	ldd	r21, Z+1	; 0x01
    34b6:	9c 01       	movw	r18, r24
    34b8:	22 0f       	add	r18, r18
    34ba:	33 1f       	adc	r19, r19
    34bc:	22 0f       	add	r18, r18
    34be:	33 1f       	adc	r19, r19
    34c0:	82 0f       	add	r24, r18
    34c2:	93 1f       	adc	r25, r19
    34c4:	84 0f       	add	r24, r20
    34c6:	95 1f       	adc	r25, r21
    34c8:	88 0f       	add	r24, r24
    34ca:	99 1f       	adc	r25, r25
    34cc:	8e 0d       	add	r24, r14
    34ce:	9f 1d       	adc	r25, r15
    34d0:	fc 01       	movw	r30, r24
    34d2:	80 81       	ld	r24, Z
    34d4:	91 81       	ldd	r25, Z+1	; 0x01
    34d6:	81 30       	cpi	r24, 0x01	; 1
    34d8:	91 05       	cpc	r25, r1
    34da:	e9 f5       	brne	.+122    	; 0x3556 <D2+0x13a>
						{
									right_wls();
    34dc:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
									arm(1);
    34e0:	81 e0       	ldi	r24, 0x01	; 1
    34e2:	90 e0       	ldi	r25, 0x00	; 0
    34e4:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
									Blk_Pos[Cur_Pos[1]+1][Cur_Pos[0]]=2;
    34e8:	88 81       	ld	r24, Y
    34ea:	99 81       	ldd	r25, Y+1	; 0x01
    34ec:	01 96       	adiw	r24, 0x01	; 1
    34ee:	f8 01       	movw	r30, r16
    34f0:	40 81       	ld	r20, Z
    34f2:	51 81       	ldd	r21, Z+1	; 0x01
    34f4:	9c 01       	movw	r18, r24
    34f6:	22 0f       	add	r18, r18
    34f8:	33 1f       	adc	r19, r19
    34fa:	22 0f       	add	r18, r18
    34fc:	33 1f       	adc	r19, r19
    34fe:	82 0f       	add	r24, r18
    3500:	93 1f       	adc	r25, r19
    3502:	84 0f       	add	r24, r20
    3504:	95 1f       	adc	r25, r21
    3506:	88 0f       	add	r24, r24
    3508:	99 1f       	adc	r25, r25
    350a:	8e 0d       	add	r24, r14
    350c:	9f 1d       	adc	r25, r15
    350e:	fc 01       	movw	r30, r24
    3510:	d1 82       	std	Z+1, r13	; 0x01
    3512:	c0 82       	st	Z, r12
									if(Cur_Pos[1]==4)
    3514:	88 81       	ld	r24, Y
    3516:	99 81       	ldd	r25, Y+1	; 0x01
    3518:	84 30       	cpi	r24, 0x04	; 4
    351a:	91 05       	cpc	r25, r1
    351c:	71 f4       	brne	.+28     	; 0x353a <D2+0x11e>
									{
										rf(1, 0);
    351e:	81 e0       	ldi	r24, 0x01	; 1
    3520:	90 e0       	ldi	r25, 0x00	; 0
    3522:	60 e0       	ldi	r22, 0x00	; 0
    3524:	70 e0       	ldi	r23, 0x00	; 0
    3526:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
										left_wls();
    352a:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
										forward_wls(1);
    352e:	81 e0       	ldi	r24, 0x01	; 1
    3530:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
										exit2();
    3534:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <exit2>
    3538:	90 cf       	rjmp	.-224    	; 0x345a <D2+0x3e>
									}
									else
									{
										rf(Cur_Pos[0]-1, 0);
    353a:	f5 01       	movw	r30, r10
    353c:	80 81       	ld	r24, Z
    353e:	91 81       	ldd	r25, Z+1	; 0x01
    3540:	01 97       	sbiw	r24, 0x01	; 1
    3542:	60 e0       	ldi	r22, 0x00	; 0
    3544:	70 e0       	ldi	r23, 0x00	; 0
    3546:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
										left_wls();
    354a:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
										forward_wls(2);
    354e:	82 e0       	ldi	r24, 0x02	; 2
    3550:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    3554:	82 cf       	rjmp	.-252    	; 0x345a <D2+0x3e>
									}
									
						}
						else if(Blk_Pos[Cur_Pos[1]+1][Cur_Pos[0]-1]==1)	//If block exists to the north-east of the current block, it sorts it and moves to position (CurrentRow+2)7 or else if it is on row 2 it sorts both blocks and exits.
    3556:	88 81       	ld	r24, Y
    3558:	99 81       	ldd	r25, Y+1	; 0x01
    355a:	9c 01       	movw	r18, r24
    355c:	2f 5f       	subi	r18, 0xFF	; 255
    355e:	3f 4f       	sbci	r19, 0xFF	; 255
    3560:	f8 01       	movw	r30, r16
    3562:	80 81       	ld	r24, Z
    3564:	91 81       	ldd	r25, Z+1	; 0x01
    3566:	ac 01       	movw	r20, r24
    3568:	41 50       	subi	r20, 0x01	; 1
    356a:	50 40       	sbci	r21, 0x00	; 0
    356c:	c9 01       	movw	r24, r18
    356e:	88 0f       	add	r24, r24
    3570:	99 1f       	adc	r25, r25
    3572:	88 0f       	add	r24, r24
    3574:	99 1f       	adc	r25, r25
    3576:	82 0f       	add	r24, r18
    3578:	93 1f       	adc	r25, r19
    357a:	84 0f       	add	r24, r20
    357c:	95 1f       	adc	r25, r21
    357e:	88 0f       	add	r24, r24
    3580:	99 1f       	adc	r25, r25
    3582:	8e 0d       	add	r24, r14
    3584:	9f 1d       	adc	r25, r15
    3586:	fc 01       	movw	r30, r24
    3588:	80 81       	ld	r24, Z
    358a:	91 81       	ldd	r25, Z+1	; 0x01
    358c:	81 30       	cpi	r24, 0x01	; 1
    358e:	91 05       	cpc	r25, r1
    3590:	09 f0       	breq	.+2      	; 0x3594 <D2+0x178>
    3592:	45 c0       	rjmp	.+138    	; 0x361e <D2+0x202>
						{
							if(Cur_Pos[1]==4)
    3594:	88 81       	ld	r24, Y
    3596:	99 81       	ldd	r25, Y+1	; 0x01
    3598:	84 30       	cpi	r24, 0x04	; 4
    359a:	91 05       	cpc	r25, r1
    359c:	81 f4       	brne	.+32     	; 0x35be <D2+0x1a2>
									{
										right_wls();
    359e:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
										forward_wls(1);
    35a2:	81 e0       	ldi	r24, 0x01	; 1
    35a4:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
										right_wls();
    35a8:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
										arm(1);
    35ac:	81 e0       	ldi	r24, 0x01	; 1
    35ae:	90 e0       	ldi	r25, 0x00	; 0
    35b0:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
										left_wls();
    35b4:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
										exit2();
    35b8:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <exit2>
    35bc:	4e cf       	rjmp	.-356    	; 0x345a <D2+0x3e>
									}
							else
							{
										right_wls();																			
    35be:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
										rf(1,0);
    35c2:	81 e0       	ldi	r24, 0x01	; 1
    35c4:	90 e0       	ldi	r25, 0x00	; 0
    35c6:	60 e0       	ldi	r22, 0x00	; 0
    35c8:	70 e0       	ldi	r23, 0x00	; 0
    35ca:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
										left_wls();
    35ce:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
										arm(1);
    35d2:	81 e0       	ldi	r24, 0x01	; 1
    35d4:	90 e0       	ldi	r25, 0x00	; 0
    35d6:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
										Blk_Pos[Cur_Pos[1]+1][Cur_Pos[0]]=2;
    35da:	88 81       	ld	r24, Y
    35dc:	99 81       	ldd	r25, Y+1	; 0x01
    35de:	01 96       	adiw	r24, 0x01	; 1
    35e0:	f8 01       	movw	r30, r16
    35e2:	40 81       	ld	r20, Z
    35e4:	51 81       	ldd	r21, Z+1	; 0x01
    35e6:	9c 01       	movw	r18, r24
    35e8:	22 0f       	add	r18, r18
    35ea:	33 1f       	adc	r19, r19
    35ec:	22 0f       	add	r18, r18
    35ee:	33 1f       	adc	r19, r19
    35f0:	82 0f       	add	r24, r18
    35f2:	93 1f       	adc	r25, r19
    35f4:	84 0f       	add	r24, r20
    35f6:	95 1f       	adc	r25, r21
    35f8:	88 0f       	add	r24, r24
    35fa:	99 1f       	adc	r25, r25
    35fc:	8e 0d       	add	r24, r14
    35fe:	9f 1d       	adc	r25, r15
    3600:	fc 01       	movw	r30, r24
    3602:	d1 82       	std	Z+1, r13	; 0x01
    3604:	c0 82       	st	Z, r12
										rf(1, 0);
    3606:	81 e0       	ldi	r24, 0x01	; 1
    3608:	90 e0       	ldi	r25, 0x00	; 0
    360a:	60 e0       	ldi	r22, 0x00	; 0
    360c:	70 e0       	ldi	r23, 0x00	; 0
    360e:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
										left_wls();
    3612:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
										forward_wls(2);
    3616:	82 e0       	ldi	r24, 0x02	; 2
    3618:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    361c:	1e cf       	rjmp	.-452    	; 0x345a <D2+0x3e>
							}
							
						}
						else if(Blk_Pos[Cur_Pos[1]+1][Cur_Pos[0]+1]==1)	//If block exists to the north-west of the current block, it sorts it and moves to position (CurrentRow+2)7 or else if it is on row 2 it sorts both blocks and exits.
    361e:	88 81       	ld	r24, Y
    3620:	99 81       	ldd	r25, Y+1	; 0x01
    3622:	9c 01       	movw	r18, r24
    3624:	2f 5f       	subi	r18, 0xFF	; 255
    3626:	3f 4f       	sbci	r19, 0xFF	; 255
    3628:	f8 01       	movw	r30, r16
    362a:	80 81       	ld	r24, Z
    362c:	91 81       	ldd	r25, Z+1	; 0x01
    362e:	ac 01       	movw	r20, r24
    3630:	4f 5f       	subi	r20, 0xFF	; 255
    3632:	5f 4f       	sbci	r21, 0xFF	; 255
    3634:	c9 01       	movw	r24, r18
    3636:	88 0f       	add	r24, r24
    3638:	99 1f       	adc	r25, r25
    363a:	88 0f       	add	r24, r24
    363c:	99 1f       	adc	r25, r25
    363e:	82 0f       	add	r24, r18
    3640:	93 1f       	adc	r25, r19
    3642:	84 0f       	add	r24, r20
    3644:	95 1f       	adc	r25, r21
    3646:	88 0f       	add	r24, r24
    3648:	99 1f       	adc	r25, r25
    364a:	8e 0d       	add	r24, r14
    364c:	9f 1d       	adc	r25, r15
    364e:	fc 01       	movw	r30, r24
    3650:	80 81       	ld	r24, Z
    3652:	91 81       	ldd	r25, Z+1	; 0x01
    3654:	81 30       	cpi	r24, 0x01	; 1
    3656:	91 05       	cpc	r25, r1
    3658:	09 f0       	breq	.+2      	; 0x365c <D2+0x240>
    365a:	ff ce       	rjmp	.-514    	; 0x345a <D2+0x3e>
						{
							right_wls();
    365c:	0e 94 2c 07 	call	0xe58	; 0xe58 <right_wls>
							forward_wls(1);
    3660:	81 e0       	ldi	r24, 0x01	; 1
    3662:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
							left_wls();
    3666:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
							arm(1);
    366a:	81 e0       	ldi	r24, 0x01	; 1
    366c:	90 e0       	ldi	r25, 0x00	; 0
    366e:	0e 94 6f 09 	call	0x12de	; 0x12de <arm>
							Blk_Pos[Cur_Pos[1]][Cur_Pos[0]+1]=2;
    3672:	28 81       	ld	r18, Y
    3674:	39 81       	ldd	r19, Y+1	; 0x01
    3676:	f8 01       	movw	r30, r16
    3678:	80 81       	ld	r24, Z
    367a:	91 81       	ldd	r25, Z+1	; 0x01
    367c:	ac 01       	movw	r20, r24
    367e:	4f 5f       	subi	r20, 0xFF	; 255
    3680:	5f 4f       	sbci	r21, 0xFF	; 255
    3682:	c9 01       	movw	r24, r18
    3684:	88 0f       	add	r24, r24
    3686:	99 1f       	adc	r25, r25
    3688:	88 0f       	add	r24, r24
    368a:	99 1f       	adc	r25, r25
    368c:	82 0f       	add	r24, r18
    368e:	93 1f       	adc	r25, r19
    3690:	84 0f       	add	r24, r20
    3692:	95 1f       	adc	r25, r21
    3694:	88 0f       	add	r24, r24
    3696:	99 1f       	adc	r25, r25
    3698:	8e 0d       	add	r24, r14
    369a:	9f 1d       	adc	r25, r15
    369c:	fc 01       	movw	r30, r24
    369e:	d1 82       	std	Z+1, r13	; 0x01
    36a0:	c0 82       	st	Z, r12
							right_degrees(90);
    36a2:	8a e5       	ldi	r24, 0x5A	; 90
    36a4:	90 e0       	ldi	r25, 0x00	; 0
    36a6:	0e 94 26 05 	call	0xa4c	; 0xa4c <right_degrees>
							if(Cur_Pos[1]==5)
    36aa:	88 81       	ld	r24, Y
    36ac:	99 81       	ldd	r25, Y+1	; 0x01
    36ae:	85 30       	cpi	r24, 0x05	; 5
    36b0:	91 05       	cpc	r25, r1
    36b2:	19 f4       	brne	.+6      	; 0x36ba <D2+0x29e>
							{
								exit2();
    36b4:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <exit2>
    36b8:	d0 ce       	rjmp	.-608    	; 0x345a <D2+0x3e>
							}
							else
							{
								rf(Cur_Pos[0]-1,1);
    36ba:	f5 01       	movw	r30, r10
    36bc:	80 81       	ld	r24, Z
    36be:	91 81       	ldd	r25, Z+1	; 0x01
    36c0:	01 97       	sbiw	r24, 0x01	; 1
    36c2:	61 e0       	ldi	r22, 0x01	; 1
    36c4:	70 e0       	ldi	r23, 0x00	; 0
    36c6:	0e 94 c6 09 	call	0x138c	; 0x138c <rf>
								left_wls();
    36ca:	0e 94 53 07 	call	0xea6	; 0xea6 <left_wls>
								forward_wls(1);
    36ce:	81 e0       	ldi	r24, 0x01	; 1
    36d0:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    36d4:	c2 ce       	rjmp	.-636    	; 0x345a <D2+0x3e>
						}
												
					}
					else											//If no blocks exist in the current row, move forward by one node.
					{
						forward_wls(1);
    36d6:	81 e0       	ldi	r24, 0x01	; 1
    36d8:	0e 94 b3 05 	call	0xb66	; 0xb66 <forward_wls>
    36dc:	be ce       	rjmp	.-644    	; 0x345a <D2+0x3e>
					}
				}
				else												//If count exceeds four blocks then proceed towards I1.
				{
					exit2();
    36de:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <exit2>
    36e2:	bb ce       	rjmp	.-650    	; 0x345a <D2+0x3e>
			{
				break;
			}
			
	}
}
    36e4:	df 91       	pop	r29
    36e6:	cf 91       	pop	r28
    36e8:	1f 91       	pop	r17
    36ea:	0f 91       	pop	r16
    36ec:	ff 90       	pop	r15
    36ee:	ef 90       	pop	r14
    36f0:	df 90       	pop	r13
    36f2:	cf 90       	pop	r12
    36f4:	bf 90       	pop	r11
    36f6:	af 90       	pop	r10
    36f8:	08 95       	ret

000036fa <main>:
 */


int main(void)
{
	init_devices();										//initializes all devices
    36fa:	0e 94 e5 03 	call	0x7ca	; 0x7ca <init_devices>
	turn_on_sharp234_wl();								//turns on sharp 2,3,4 and white line sensors .
    36fe:	0e 94 f4 03 	call	0x7e8	; 0x7e8 <turn_on_sharp234_wl>
	turn_off_sharp15();									//turns off sharp 1,5 sensors for battery optimization.
    3702:	0e 94 fe 03 	call	0x7fc	; 0x7fc <turn_off_sharp15>
	turn_off_ir_proxi_sensors();						//turns off IR analog sensors for battery optimization.
    3706:	0e 94 0a 04 	call	0x814	; 0x814 <turn_off_ir_proxi_sensors>
	D1();												//calls D1, traverses D1
    370a:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <D1>
	IRCorridor();										//calls IRCorridor, traverses IRCorridor
    370e:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <IRCorridor>

00003712 <__subsf3>:
    3712:	50 58       	subi	r21, 0x80	; 128

00003714 <__addsf3>:
    3714:	bb 27       	eor	r27, r27
    3716:	aa 27       	eor	r26, r26
    3718:	0e d0       	rcall	.+28     	; 0x3736 <__addsf3x>
    371a:	4d c1       	rjmp	.+666    	; 0x39b6 <__fp_round>
    371c:	3e d1       	rcall	.+636    	; 0x399a <__fp_pscA>
    371e:	30 f0       	brcs	.+12     	; 0x372c <__addsf3+0x18>
    3720:	43 d1       	rcall	.+646    	; 0x39a8 <__fp_pscB>
    3722:	20 f0       	brcs	.+8      	; 0x372c <__addsf3+0x18>
    3724:	31 f4       	brne	.+12     	; 0x3732 <__addsf3+0x1e>
    3726:	9f 3f       	cpi	r25, 0xFF	; 255
    3728:	11 f4       	brne	.+4      	; 0x372e <__addsf3+0x1a>
    372a:	1e f4       	brtc	.+6      	; 0x3732 <__addsf3+0x1e>
    372c:	33 c1       	rjmp	.+614    	; 0x3994 <__fp_nan>
    372e:	0e f4       	brtc	.+2      	; 0x3732 <__addsf3+0x1e>
    3730:	e0 95       	com	r30
    3732:	e7 fb       	bst	r30, 7
    3734:	29 c1       	rjmp	.+594    	; 0x3988 <__fp_inf>

00003736 <__addsf3x>:
    3736:	e9 2f       	mov	r30, r25
    3738:	4f d1       	rcall	.+670    	; 0x39d8 <__fp_split3>
    373a:	80 f3       	brcs	.-32     	; 0x371c <__addsf3+0x8>
    373c:	ba 17       	cp	r27, r26
    373e:	62 07       	cpc	r22, r18
    3740:	73 07       	cpc	r23, r19
    3742:	84 07       	cpc	r24, r20
    3744:	95 07       	cpc	r25, r21
    3746:	18 f0       	brcs	.+6      	; 0x374e <__addsf3x+0x18>
    3748:	71 f4       	brne	.+28     	; 0x3766 <__addsf3x+0x30>
    374a:	9e f5       	brtc	.+102    	; 0x37b2 <__addsf3x+0x7c>
    374c:	67 c1       	rjmp	.+718    	; 0x3a1c <__fp_zero>
    374e:	0e f4       	brtc	.+2      	; 0x3752 <__addsf3x+0x1c>
    3750:	e0 95       	com	r30
    3752:	0b 2e       	mov	r0, r27
    3754:	ba 2f       	mov	r27, r26
    3756:	a0 2d       	mov	r26, r0
    3758:	0b 01       	movw	r0, r22
    375a:	b9 01       	movw	r22, r18
    375c:	90 01       	movw	r18, r0
    375e:	0c 01       	movw	r0, r24
    3760:	ca 01       	movw	r24, r20
    3762:	a0 01       	movw	r20, r0
    3764:	11 24       	eor	r1, r1
    3766:	ff 27       	eor	r31, r31
    3768:	59 1b       	sub	r21, r25
    376a:	99 f0       	breq	.+38     	; 0x3792 <__addsf3x+0x5c>
    376c:	59 3f       	cpi	r21, 0xF9	; 249
    376e:	50 f4       	brcc	.+20     	; 0x3784 <__addsf3x+0x4e>
    3770:	50 3e       	cpi	r21, 0xE0	; 224
    3772:	68 f1       	brcs	.+90     	; 0x37ce <__addsf3x+0x98>
    3774:	1a 16       	cp	r1, r26
    3776:	f0 40       	sbci	r31, 0x00	; 0
    3778:	a2 2f       	mov	r26, r18
    377a:	23 2f       	mov	r18, r19
    377c:	34 2f       	mov	r19, r20
    377e:	44 27       	eor	r20, r20
    3780:	58 5f       	subi	r21, 0xF8	; 248
    3782:	f3 cf       	rjmp	.-26     	; 0x376a <__addsf3x+0x34>
    3784:	46 95       	lsr	r20
    3786:	37 95       	ror	r19
    3788:	27 95       	ror	r18
    378a:	a7 95       	ror	r26
    378c:	f0 40       	sbci	r31, 0x00	; 0
    378e:	53 95       	inc	r21
    3790:	c9 f7       	brne	.-14     	; 0x3784 <__addsf3x+0x4e>
    3792:	7e f4       	brtc	.+30     	; 0x37b2 <__addsf3x+0x7c>
    3794:	1f 16       	cp	r1, r31
    3796:	ba 0b       	sbc	r27, r26
    3798:	62 0b       	sbc	r22, r18
    379a:	73 0b       	sbc	r23, r19
    379c:	84 0b       	sbc	r24, r20
    379e:	ba f0       	brmi	.+46     	; 0x37ce <__addsf3x+0x98>
    37a0:	91 50       	subi	r25, 0x01	; 1
    37a2:	a1 f0       	breq	.+40     	; 0x37cc <__addsf3x+0x96>
    37a4:	ff 0f       	add	r31, r31
    37a6:	bb 1f       	adc	r27, r27
    37a8:	66 1f       	adc	r22, r22
    37aa:	77 1f       	adc	r23, r23
    37ac:	88 1f       	adc	r24, r24
    37ae:	c2 f7       	brpl	.-16     	; 0x37a0 <__addsf3x+0x6a>
    37b0:	0e c0       	rjmp	.+28     	; 0x37ce <__addsf3x+0x98>
    37b2:	ba 0f       	add	r27, r26
    37b4:	62 1f       	adc	r22, r18
    37b6:	73 1f       	adc	r23, r19
    37b8:	84 1f       	adc	r24, r20
    37ba:	48 f4       	brcc	.+18     	; 0x37ce <__addsf3x+0x98>
    37bc:	87 95       	ror	r24
    37be:	77 95       	ror	r23
    37c0:	67 95       	ror	r22
    37c2:	b7 95       	ror	r27
    37c4:	f7 95       	ror	r31
    37c6:	9e 3f       	cpi	r25, 0xFE	; 254
    37c8:	08 f0       	brcs	.+2      	; 0x37cc <__addsf3x+0x96>
    37ca:	b3 cf       	rjmp	.-154    	; 0x3732 <__addsf3+0x1e>
    37cc:	93 95       	inc	r25
    37ce:	88 0f       	add	r24, r24
    37d0:	08 f0       	brcs	.+2      	; 0x37d4 <__addsf3x+0x9e>
    37d2:	99 27       	eor	r25, r25
    37d4:	ee 0f       	add	r30, r30
    37d6:	97 95       	ror	r25
    37d8:	87 95       	ror	r24
    37da:	08 95       	ret

000037dc <__divsf3>:
    37dc:	0c d0       	rcall	.+24     	; 0x37f6 <__divsf3x>
    37de:	eb c0       	rjmp	.+470    	; 0x39b6 <__fp_round>
    37e0:	e3 d0       	rcall	.+454    	; 0x39a8 <__fp_pscB>
    37e2:	40 f0       	brcs	.+16     	; 0x37f4 <__divsf3+0x18>
    37e4:	da d0       	rcall	.+436    	; 0x399a <__fp_pscA>
    37e6:	30 f0       	brcs	.+12     	; 0x37f4 <__divsf3+0x18>
    37e8:	21 f4       	brne	.+8      	; 0x37f2 <__divsf3+0x16>
    37ea:	5f 3f       	cpi	r21, 0xFF	; 255
    37ec:	19 f0       	breq	.+6      	; 0x37f4 <__divsf3+0x18>
    37ee:	cc c0       	rjmp	.+408    	; 0x3988 <__fp_inf>
    37f0:	51 11       	cpse	r21, r1
    37f2:	15 c1       	rjmp	.+554    	; 0x3a1e <__fp_szero>
    37f4:	cf c0       	rjmp	.+414    	; 0x3994 <__fp_nan>

000037f6 <__divsf3x>:
    37f6:	f0 d0       	rcall	.+480    	; 0x39d8 <__fp_split3>
    37f8:	98 f3       	brcs	.-26     	; 0x37e0 <__divsf3+0x4>

000037fa <__divsf3_pse>:
    37fa:	99 23       	and	r25, r25
    37fc:	c9 f3       	breq	.-14     	; 0x37f0 <__divsf3+0x14>
    37fe:	55 23       	and	r21, r21
    3800:	b1 f3       	breq	.-20     	; 0x37ee <__divsf3+0x12>
    3802:	95 1b       	sub	r25, r21
    3804:	55 0b       	sbc	r21, r21
    3806:	bb 27       	eor	r27, r27
    3808:	aa 27       	eor	r26, r26
    380a:	62 17       	cp	r22, r18
    380c:	73 07       	cpc	r23, r19
    380e:	84 07       	cpc	r24, r20
    3810:	38 f0       	brcs	.+14     	; 0x3820 <__divsf3_pse+0x26>
    3812:	9f 5f       	subi	r25, 0xFF	; 255
    3814:	5f 4f       	sbci	r21, 0xFF	; 255
    3816:	22 0f       	add	r18, r18
    3818:	33 1f       	adc	r19, r19
    381a:	44 1f       	adc	r20, r20
    381c:	aa 1f       	adc	r26, r26
    381e:	a9 f3       	breq	.-22     	; 0x380a <__divsf3_pse+0x10>
    3820:	33 d0       	rcall	.+102    	; 0x3888 <__divsf3_pse+0x8e>
    3822:	0e 2e       	mov	r0, r30
    3824:	3a f0       	brmi	.+14     	; 0x3834 <__divsf3_pse+0x3a>
    3826:	e0 e8       	ldi	r30, 0x80	; 128
    3828:	30 d0       	rcall	.+96     	; 0x388a <__divsf3_pse+0x90>
    382a:	91 50       	subi	r25, 0x01	; 1
    382c:	50 40       	sbci	r21, 0x00	; 0
    382e:	e6 95       	lsr	r30
    3830:	00 1c       	adc	r0, r0
    3832:	ca f7       	brpl	.-14     	; 0x3826 <__divsf3_pse+0x2c>
    3834:	29 d0       	rcall	.+82     	; 0x3888 <__divsf3_pse+0x8e>
    3836:	fe 2f       	mov	r31, r30
    3838:	27 d0       	rcall	.+78     	; 0x3888 <__divsf3_pse+0x8e>
    383a:	66 0f       	add	r22, r22
    383c:	77 1f       	adc	r23, r23
    383e:	88 1f       	adc	r24, r24
    3840:	bb 1f       	adc	r27, r27
    3842:	26 17       	cp	r18, r22
    3844:	37 07       	cpc	r19, r23
    3846:	48 07       	cpc	r20, r24
    3848:	ab 07       	cpc	r26, r27
    384a:	b0 e8       	ldi	r27, 0x80	; 128
    384c:	09 f0       	breq	.+2      	; 0x3850 <__divsf3_pse+0x56>
    384e:	bb 0b       	sbc	r27, r27
    3850:	80 2d       	mov	r24, r0
    3852:	bf 01       	movw	r22, r30
    3854:	ff 27       	eor	r31, r31
    3856:	93 58       	subi	r25, 0x83	; 131
    3858:	5f 4f       	sbci	r21, 0xFF	; 255
    385a:	2a f0       	brmi	.+10     	; 0x3866 <__divsf3_pse+0x6c>
    385c:	9e 3f       	cpi	r25, 0xFE	; 254
    385e:	51 05       	cpc	r21, r1
    3860:	68 f0       	brcs	.+26     	; 0x387c <__divsf3_pse+0x82>
    3862:	92 c0       	rjmp	.+292    	; 0x3988 <__fp_inf>
    3864:	dc c0       	rjmp	.+440    	; 0x3a1e <__fp_szero>
    3866:	5f 3f       	cpi	r21, 0xFF	; 255
    3868:	ec f3       	brlt	.-6      	; 0x3864 <__divsf3_pse+0x6a>
    386a:	98 3e       	cpi	r25, 0xE8	; 232
    386c:	dc f3       	brlt	.-10     	; 0x3864 <__divsf3_pse+0x6a>
    386e:	86 95       	lsr	r24
    3870:	77 95       	ror	r23
    3872:	67 95       	ror	r22
    3874:	b7 95       	ror	r27
    3876:	f7 95       	ror	r31
    3878:	9f 5f       	subi	r25, 0xFF	; 255
    387a:	c9 f7       	brne	.-14     	; 0x386e <__divsf3_pse+0x74>
    387c:	88 0f       	add	r24, r24
    387e:	91 1d       	adc	r25, r1
    3880:	96 95       	lsr	r25
    3882:	87 95       	ror	r24
    3884:	97 f9       	bld	r25, 7
    3886:	08 95       	ret
    3888:	e1 e0       	ldi	r30, 0x01	; 1
    388a:	66 0f       	add	r22, r22
    388c:	77 1f       	adc	r23, r23
    388e:	88 1f       	adc	r24, r24
    3890:	bb 1f       	adc	r27, r27
    3892:	62 17       	cp	r22, r18
    3894:	73 07       	cpc	r23, r19
    3896:	84 07       	cpc	r24, r20
    3898:	ba 07       	cpc	r27, r26
    389a:	20 f0       	brcs	.+8      	; 0x38a4 <__divsf3_pse+0xaa>
    389c:	62 1b       	sub	r22, r18
    389e:	73 0b       	sbc	r23, r19
    38a0:	84 0b       	sbc	r24, r20
    38a2:	ba 0b       	sbc	r27, r26
    38a4:	ee 1f       	adc	r30, r30
    38a6:	88 f7       	brcc	.-30     	; 0x388a <__divsf3_pse+0x90>
    38a8:	e0 95       	com	r30
    38aa:	08 95       	ret

000038ac <__fixsfsi>:
    38ac:	04 d0       	rcall	.+8      	; 0x38b6 <__fixunssfsi>
    38ae:	68 94       	set
    38b0:	b1 11       	cpse	r27, r1
    38b2:	b5 c0       	rjmp	.+362    	; 0x3a1e <__fp_szero>
    38b4:	08 95       	ret

000038b6 <__fixunssfsi>:
    38b6:	98 d0       	rcall	.+304    	; 0x39e8 <__fp_splitA>
    38b8:	88 f0       	brcs	.+34     	; 0x38dc <__fixunssfsi+0x26>
    38ba:	9f 57       	subi	r25, 0x7F	; 127
    38bc:	90 f0       	brcs	.+36     	; 0x38e2 <__fixunssfsi+0x2c>
    38be:	b9 2f       	mov	r27, r25
    38c0:	99 27       	eor	r25, r25
    38c2:	b7 51       	subi	r27, 0x17	; 23
    38c4:	a0 f0       	brcs	.+40     	; 0x38ee <__fixunssfsi+0x38>
    38c6:	d1 f0       	breq	.+52     	; 0x38fc <__fixunssfsi+0x46>
    38c8:	66 0f       	add	r22, r22
    38ca:	77 1f       	adc	r23, r23
    38cc:	88 1f       	adc	r24, r24
    38ce:	99 1f       	adc	r25, r25
    38d0:	1a f0       	brmi	.+6      	; 0x38d8 <__fixunssfsi+0x22>
    38d2:	ba 95       	dec	r27
    38d4:	c9 f7       	brne	.-14     	; 0x38c8 <__fixunssfsi+0x12>
    38d6:	12 c0       	rjmp	.+36     	; 0x38fc <__fixunssfsi+0x46>
    38d8:	b1 30       	cpi	r27, 0x01	; 1
    38da:	81 f0       	breq	.+32     	; 0x38fc <__fixunssfsi+0x46>
    38dc:	9f d0       	rcall	.+318    	; 0x3a1c <__fp_zero>
    38de:	b1 e0       	ldi	r27, 0x01	; 1
    38e0:	08 95       	ret
    38e2:	9c c0       	rjmp	.+312    	; 0x3a1c <__fp_zero>
    38e4:	67 2f       	mov	r22, r23
    38e6:	78 2f       	mov	r23, r24
    38e8:	88 27       	eor	r24, r24
    38ea:	b8 5f       	subi	r27, 0xF8	; 248
    38ec:	39 f0       	breq	.+14     	; 0x38fc <__fixunssfsi+0x46>
    38ee:	b9 3f       	cpi	r27, 0xF9	; 249
    38f0:	cc f3       	brlt	.-14     	; 0x38e4 <__fixunssfsi+0x2e>
    38f2:	86 95       	lsr	r24
    38f4:	77 95       	ror	r23
    38f6:	67 95       	ror	r22
    38f8:	b3 95       	inc	r27
    38fa:	d9 f7       	brne	.-10     	; 0x38f2 <__fixunssfsi+0x3c>
    38fc:	3e f4       	brtc	.+14     	; 0x390c <__fixunssfsi+0x56>
    38fe:	90 95       	com	r25
    3900:	80 95       	com	r24
    3902:	70 95       	com	r23
    3904:	61 95       	neg	r22
    3906:	7f 4f       	sbci	r23, 0xFF	; 255
    3908:	8f 4f       	sbci	r24, 0xFF	; 255
    390a:	9f 4f       	sbci	r25, 0xFF	; 255
    390c:	08 95       	ret

0000390e <__floatunsisf>:
    390e:	e8 94       	clt
    3910:	09 c0       	rjmp	.+18     	; 0x3924 <__floatsisf+0x12>

00003912 <__floatsisf>:
    3912:	97 fb       	bst	r25, 7
    3914:	3e f4       	brtc	.+14     	; 0x3924 <__floatsisf+0x12>
    3916:	90 95       	com	r25
    3918:	80 95       	com	r24
    391a:	70 95       	com	r23
    391c:	61 95       	neg	r22
    391e:	7f 4f       	sbci	r23, 0xFF	; 255
    3920:	8f 4f       	sbci	r24, 0xFF	; 255
    3922:	9f 4f       	sbci	r25, 0xFF	; 255
    3924:	99 23       	and	r25, r25
    3926:	a9 f0       	breq	.+42     	; 0x3952 <__floatsisf+0x40>
    3928:	f9 2f       	mov	r31, r25
    392a:	96 e9       	ldi	r25, 0x96	; 150
    392c:	bb 27       	eor	r27, r27
    392e:	93 95       	inc	r25
    3930:	f6 95       	lsr	r31
    3932:	87 95       	ror	r24
    3934:	77 95       	ror	r23
    3936:	67 95       	ror	r22
    3938:	b7 95       	ror	r27
    393a:	f1 11       	cpse	r31, r1
    393c:	f8 cf       	rjmp	.-16     	; 0x392e <__floatsisf+0x1c>
    393e:	fa f4       	brpl	.+62     	; 0x397e <__floatsisf+0x6c>
    3940:	bb 0f       	add	r27, r27
    3942:	11 f4       	brne	.+4      	; 0x3948 <__floatsisf+0x36>
    3944:	60 ff       	sbrs	r22, 0
    3946:	1b c0       	rjmp	.+54     	; 0x397e <__floatsisf+0x6c>
    3948:	6f 5f       	subi	r22, 0xFF	; 255
    394a:	7f 4f       	sbci	r23, 0xFF	; 255
    394c:	8f 4f       	sbci	r24, 0xFF	; 255
    394e:	9f 4f       	sbci	r25, 0xFF	; 255
    3950:	16 c0       	rjmp	.+44     	; 0x397e <__floatsisf+0x6c>
    3952:	88 23       	and	r24, r24
    3954:	11 f0       	breq	.+4      	; 0x395a <__floatsisf+0x48>
    3956:	96 e9       	ldi	r25, 0x96	; 150
    3958:	11 c0       	rjmp	.+34     	; 0x397c <__floatsisf+0x6a>
    395a:	77 23       	and	r23, r23
    395c:	21 f0       	breq	.+8      	; 0x3966 <__floatsisf+0x54>
    395e:	9e e8       	ldi	r25, 0x8E	; 142
    3960:	87 2f       	mov	r24, r23
    3962:	76 2f       	mov	r23, r22
    3964:	05 c0       	rjmp	.+10     	; 0x3970 <__floatsisf+0x5e>
    3966:	66 23       	and	r22, r22
    3968:	71 f0       	breq	.+28     	; 0x3986 <__floatsisf+0x74>
    396a:	96 e8       	ldi	r25, 0x86	; 134
    396c:	86 2f       	mov	r24, r22
    396e:	70 e0       	ldi	r23, 0x00	; 0
    3970:	60 e0       	ldi	r22, 0x00	; 0
    3972:	2a f0       	brmi	.+10     	; 0x397e <__floatsisf+0x6c>
    3974:	9a 95       	dec	r25
    3976:	66 0f       	add	r22, r22
    3978:	77 1f       	adc	r23, r23
    397a:	88 1f       	adc	r24, r24
    397c:	da f7       	brpl	.-10     	; 0x3974 <__floatsisf+0x62>
    397e:	88 0f       	add	r24, r24
    3980:	96 95       	lsr	r25
    3982:	87 95       	ror	r24
    3984:	97 f9       	bld	r25, 7
    3986:	08 95       	ret

00003988 <__fp_inf>:
    3988:	97 f9       	bld	r25, 7
    398a:	9f 67       	ori	r25, 0x7F	; 127
    398c:	80 e8       	ldi	r24, 0x80	; 128
    398e:	70 e0       	ldi	r23, 0x00	; 0
    3990:	60 e0       	ldi	r22, 0x00	; 0
    3992:	08 95       	ret

00003994 <__fp_nan>:
    3994:	9f ef       	ldi	r25, 0xFF	; 255
    3996:	80 ec       	ldi	r24, 0xC0	; 192
    3998:	08 95       	ret

0000399a <__fp_pscA>:
    399a:	00 24       	eor	r0, r0
    399c:	0a 94       	dec	r0
    399e:	16 16       	cp	r1, r22
    39a0:	17 06       	cpc	r1, r23
    39a2:	18 06       	cpc	r1, r24
    39a4:	09 06       	cpc	r0, r25
    39a6:	08 95       	ret

000039a8 <__fp_pscB>:
    39a8:	00 24       	eor	r0, r0
    39aa:	0a 94       	dec	r0
    39ac:	12 16       	cp	r1, r18
    39ae:	13 06       	cpc	r1, r19
    39b0:	14 06       	cpc	r1, r20
    39b2:	05 06       	cpc	r0, r21
    39b4:	08 95       	ret

000039b6 <__fp_round>:
    39b6:	09 2e       	mov	r0, r25
    39b8:	03 94       	inc	r0
    39ba:	00 0c       	add	r0, r0
    39bc:	11 f4       	brne	.+4      	; 0x39c2 <__fp_round+0xc>
    39be:	88 23       	and	r24, r24
    39c0:	52 f0       	brmi	.+20     	; 0x39d6 <__fp_round+0x20>
    39c2:	bb 0f       	add	r27, r27
    39c4:	40 f4       	brcc	.+16     	; 0x39d6 <__fp_round+0x20>
    39c6:	bf 2b       	or	r27, r31
    39c8:	11 f4       	brne	.+4      	; 0x39ce <__fp_round+0x18>
    39ca:	60 ff       	sbrs	r22, 0
    39cc:	04 c0       	rjmp	.+8      	; 0x39d6 <__fp_round+0x20>
    39ce:	6f 5f       	subi	r22, 0xFF	; 255
    39d0:	7f 4f       	sbci	r23, 0xFF	; 255
    39d2:	8f 4f       	sbci	r24, 0xFF	; 255
    39d4:	9f 4f       	sbci	r25, 0xFF	; 255
    39d6:	08 95       	ret

000039d8 <__fp_split3>:
    39d8:	57 fd       	sbrc	r21, 7
    39da:	90 58       	subi	r25, 0x80	; 128
    39dc:	44 0f       	add	r20, r20
    39de:	55 1f       	adc	r21, r21
    39e0:	59 f0       	breq	.+22     	; 0x39f8 <__fp_splitA+0x10>
    39e2:	5f 3f       	cpi	r21, 0xFF	; 255
    39e4:	71 f0       	breq	.+28     	; 0x3a02 <__fp_splitA+0x1a>
    39e6:	47 95       	ror	r20

000039e8 <__fp_splitA>:
    39e8:	88 0f       	add	r24, r24
    39ea:	97 fb       	bst	r25, 7
    39ec:	99 1f       	adc	r25, r25
    39ee:	61 f0       	breq	.+24     	; 0x3a08 <__fp_splitA+0x20>
    39f0:	9f 3f       	cpi	r25, 0xFF	; 255
    39f2:	79 f0       	breq	.+30     	; 0x3a12 <__fp_splitA+0x2a>
    39f4:	87 95       	ror	r24
    39f6:	08 95       	ret
    39f8:	12 16       	cp	r1, r18
    39fa:	13 06       	cpc	r1, r19
    39fc:	14 06       	cpc	r1, r20
    39fe:	55 1f       	adc	r21, r21
    3a00:	f2 cf       	rjmp	.-28     	; 0x39e6 <__fp_split3+0xe>
    3a02:	46 95       	lsr	r20
    3a04:	f1 df       	rcall	.-30     	; 0x39e8 <__fp_splitA>
    3a06:	08 c0       	rjmp	.+16     	; 0x3a18 <__fp_splitA+0x30>
    3a08:	16 16       	cp	r1, r22
    3a0a:	17 06       	cpc	r1, r23
    3a0c:	18 06       	cpc	r1, r24
    3a0e:	99 1f       	adc	r25, r25
    3a10:	f1 cf       	rjmp	.-30     	; 0x39f4 <__fp_splitA+0xc>
    3a12:	86 95       	lsr	r24
    3a14:	71 05       	cpc	r23, r1
    3a16:	61 05       	cpc	r22, r1
    3a18:	08 94       	sec
    3a1a:	08 95       	ret

00003a1c <__fp_zero>:
    3a1c:	e8 94       	clt

00003a1e <__fp_szero>:
    3a1e:	bb 27       	eor	r27, r27
    3a20:	66 27       	eor	r22, r22
    3a22:	77 27       	eor	r23, r23
    3a24:	cb 01       	movw	r24, r22
    3a26:	97 f9       	bld	r25, 7
    3a28:	08 95       	ret

00003a2a <__mulsf3>:
    3a2a:	0b d0       	rcall	.+22     	; 0x3a42 <__mulsf3x>
    3a2c:	c4 cf       	rjmp	.-120    	; 0x39b6 <__fp_round>
    3a2e:	b5 df       	rcall	.-150    	; 0x399a <__fp_pscA>
    3a30:	28 f0       	brcs	.+10     	; 0x3a3c <__mulsf3+0x12>
    3a32:	ba df       	rcall	.-140    	; 0x39a8 <__fp_pscB>
    3a34:	18 f0       	brcs	.+6      	; 0x3a3c <__mulsf3+0x12>
    3a36:	95 23       	and	r25, r21
    3a38:	09 f0       	breq	.+2      	; 0x3a3c <__mulsf3+0x12>
    3a3a:	a6 cf       	rjmp	.-180    	; 0x3988 <__fp_inf>
    3a3c:	ab cf       	rjmp	.-170    	; 0x3994 <__fp_nan>
    3a3e:	11 24       	eor	r1, r1
    3a40:	ee cf       	rjmp	.-36     	; 0x3a1e <__fp_szero>

00003a42 <__mulsf3x>:
    3a42:	ca df       	rcall	.-108    	; 0x39d8 <__fp_split3>
    3a44:	a0 f3       	brcs	.-24     	; 0x3a2e <__mulsf3+0x4>

00003a46 <__mulsf3_pse>:
    3a46:	95 9f       	mul	r25, r21
    3a48:	d1 f3       	breq	.-12     	; 0x3a3e <__mulsf3+0x14>
    3a4a:	95 0f       	add	r25, r21
    3a4c:	50 e0       	ldi	r21, 0x00	; 0
    3a4e:	55 1f       	adc	r21, r21
    3a50:	62 9f       	mul	r22, r18
    3a52:	f0 01       	movw	r30, r0
    3a54:	72 9f       	mul	r23, r18
    3a56:	bb 27       	eor	r27, r27
    3a58:	f0 0d       	add	r31, r0
    3a5a:	b1 1d       	adc	r27, r1
    3a5c:	63 9f       	mul	r22, r19
    3a5e:	aa 27       	eor	r26, r26
    3a60:	f0 0d       	add	r31, r0
    3a62:	b1 1d       	adc	r27, r1
    3a64:	aa 1f       	adc	r26, r26
    3a66:	64 9f       	mul	r22, r20
    3a68:	66 27       	eor	r22, r22
    3a6a:	b0 0d       	add	r27, r0
    3a6c:	a1 1d       	adc	r26, r1
    3a6e:	66 1f       	adc	r22, r22
    3a70:	82 9f       	mul	r24, r18
    3a72:	22 27       	eor	r18, r18
    3a74:	b0 0d       	add	r27, r0
    3a76:	a1 1d       	adc	r26, r1
    3a78:	62 1f       	adc	r22, r18
    3a7a:	73 9f       	mul	r23, r19
    3a7c:	b0 0d       	add	r27, r0
    3a7e:	a1 1d       	adc	r26, r1
    3a80:	62 1f       	adc	r22, r18
    3a82:	83 9f       	mul	r24, r19
    3a84:	a0 0d       	add	r26, r0
    3a86:	61 1d       	adc	r22, r1
    3a88:	22 1f       	adc	r18, r18
    3a8a:	74 9f       	mul	r23, r20
    3a8c:	33 27       	eor	r19, r19
    3a8e:	a0 0d       	add	r26, r0
    3a90:	61 1d       	adc	r22, r1
    3a92:	23 1f       	adc	r18, r19
    3a94:	84 9f       	mul	r24, r20
    3a96:	60 0d       	add	r22, r0
    3a98:	21 1d       	adc	r18, r1
    3a9a:	82 2f       	mov	r24, r18
    3a9c:	76 2f       	mov	r23, r22
    3a9e:	6a 2f       	mov	r22, r26
    3aa0:	11 24       	eor	r1, r1
    3aa2:	9f 57       	subi	r25, 0x7F	; 127
    3aa4:	50 40       	sbci	r21, 0x00	; 0
    3aa6:	8a f0       	brmi	.+34     	; 0x3aca <__mulsf3_pse+0x84>
    3aa8:	e1 f0       	breq	.+56     	; 0x3ae2 <__mulsf3_pse+0x9c>
    3aaa:	88 23       	and	r24, r24
    3aac:	4a f0       	brmi	.+18     	; 0x3ac0 <__mulsf3_pse+0x7a>
    3aae:	ee 0f       	add	r30, r30
    3ab0:	ff 1f       	adc	r31, r31
    3ab2:	bb 1f       	adc	r27, r27
    3ab4:	66 1f       	adc	r22, r22
    3ab6:	77 1f       	adc	r23, r23
    3ab8:	88 1f       	adc	r24, r24
    3aba:	91 50       	subi	r25, 0x01	; 1
    3abc:	50 40       	sbci	r21, 0x00	; 0
    3abe:	a9 f7       	brne	.-22     	; 0x3aaa <__mulsf3_pse+0x64>
    3ac0:	9e 3f       	cpi	r25, 0xFE	; 254
    3ac2:	51 05       	cpc	r21, r1
    3ac4:	70 f0       	brcs	.+28     	; 0x3ae2 <__mulsf3_pse+0x9c>
    3ac6:	60 cf       	rjmp	.-320    	; 0x3988 <__fp_inf>
    3ac8:	aa cf       	rjmp	.-172    	; 0x3a1e <__fp_szero>
    3aca:	5f 3f       	cpi	r21, 0xFF	; 255
    3acc:	ec f3       	brlt	.-6      	; 0x3ac8 <__mulsf3_pse+0x82>
    3ace:	98 3e       	cpi	r25, 0xE8	; 232
    3ad0:	dc f3       	brlt	.-10     	; 0x3ac8 <__mulsf3_pse+0x82>
    3ad2:	86 95       	lsr	r24
    3ad4:	77 95       	ror	r23
    3ad6:	67 95       	ror	r22
    3ad8:	b7 95       	ror	r27
    3ada:	f7 95       	ror	r31
    3adc:	e7 95       	ror	r30
    3ade:	9f 5f       	subi	r25, 0xFF	; 255
    3ae0:	c1 f7       	brne	.-16     	; 0x3ad2 <__mulsf3_pse+0x8c>
    3ae2:	fe 2b       	or	r31, r30
    3ae4:	88 0f       	add	r24, r24
    3ae6:	91 1d       	adc	r25, r1
    3ae8:	96 95       	lsr	r25
    3aea:	87 95       	ror	r24
    3aec:	97 f9       	bld	r25, 7
    3aee:	08 95       	ret

00003af0 <pow>:
    3af0:	fa 01       	movw	r30, r20
    3af2:	ee 0f       	add	r30, r30
    3af4:	ff 1f       	adc	r31, r31
    3af6:	30 96       	adiw	r30, 0x00	; 0
    3af8:	21 05       	cpc	r18, r1
    3afa:	31 05       	cpc	r19, r1
    3afc:	99 f1       	breq	.+102    	; 0x3b64 <pow+0x74>
    3afe:	61 15       	cp	r22, r1
    3b00:	71 05       	cpc	r23, r1
    3b02:	61 f4       	brne	.+24     	; 0x3b1c <pow+0x2c>
    3b04:	80 38       	cpi	r24, 0x80	; 128
    3b06:	bf e3       	ldi	r27, 0x3F	; 63
    3b08:	9b 07       	cpc	r25, r27
    3b0a:	49 f1       	breq	.+82     	; 0x3b5e <pow+0x6e>
    3b0c:	68 94       	set
    3b0e:	90 38       	cpi	r25, 0x80	; 128
    3b10:	81 05       	cpc	r24, r1
    3b12:	61 f0       	breq	.+24     	; 0x3b2c <pow+0x3c>
    3b14:	80 38       	cpi	r24, 0x80	; 128
    3b16:	bf ef       	ldi	r27, 0xFF	; 255
    3b18:	9b 07       	cpc	r25, r27
    3b1a:	41 f0       	breq	.+16     	; 0x3b2c <pow+0x3c>
    3b1c:	99 23       	and	r25, r25
    3b1e:	42 f5       	brpl	.+80     	; 0x3b70 <pow+0x80>
    3b20:	ff 3f       	cpi	r31, 0xFF	; 255
    3b22:	e1 05       	cpc	r30, r1
    3b24:	31 05       	cpc	r19, r1
    3b26:	21 05       	cpc	r18, r1
    3b28:	11 f1       	breq	.+68     	; 0x3b6e <pow+0x7e>
    3b2a:	e8 94       	clt
    3b2c:	08 94       	sec
    3b2e:	e7 95       	ror	r30
    3b30:	d9 01       	movw	r26, r18
    3b32:	aa 23       	and	r26, r26
    3b34:	29 f4       	brne	.+10     	; 0x3b40 <pow+0x50>
    3b36:	ab 2f       	mov	r26, r27
    3b38:	be 2f       	mov	r27, r30
    3b3a:	f8 5f       	subi	r31, 0xF8	; 248
    3b3c:	d0 f3       	brcs	.-12     	; 0x3b32 <pow+0x42>
    3b3e:	10 c0       	rjmp	.+32     	; 0x3b60 <pow+0x70>
    3b40:	ff 5f       	subi	r31, 0xFF	; 255
    3b42:	70 f4       	brcc	.+28     	; 0x3b60 <pow+0x70>
    3b44:	a6 95       	lsr	r26
    3b46:	e0 f7       	brcc	.-8      	; 0x3b40 <pow+0x50>
    3b48:	f7 39       	cpi	r31, 0x97	; 151
    3b4a:	50 f0       	brcs	.+20     	; 0x3b60 <pow+0x70>
    3b4c:	19 f0       	breq	.+6      	; 0x3b54 <pow+0x64>
    3b4e:	ff 3a       	cpi	r31, 0xAF	; 175
    3b50:	38 f4       	brcc	.+14     	; 0x3b60 <pow+0x70>
    3b52:	9f 77       	andi	r25, 0x7F	; 127
    3b54:	9f 93       	push	r25
    3b56:	0c d0       	rcall	.+24     	; 0x3b70 <pow+0x80>
    3b58:	0f 90       	pop	r0
    3b5a:	07 fc       	sbrc	r0, 7
    3b5c:	90 58       	subi	r25, 0x80	; 128
    3b5e:	08 95       	ret
    3b60:	3e f0       	brts	.+14     	; 0x3b70 <pow+0x80>
    3b62:	18 cf       	rjmp	.-464    	; 0x3994 <__fp_nan>
    3b64:	60 e0       	ldi	r22, 0x00	; 0
    3b66:	70 e0       	ldi	r23, 0x00	; 0
    3b68:	80 e8       	ldi	r24, 0x80	; 128
    3b6a:	9f e3       	ldi	r25, 0x3F	; 63
    3b6c:	08 95       	ret
    3b6e:	4f e7       	ldi	r20, 0x7F	; 127
    3b70:	9f 77       	andi	r25, 0x7F	; 127
    3b72:	5f 93       	push	r21
    3b74:	4f 93       	push	r20
    3b76:	3f 93       	push	r19
    3b78:	2f 93       	push	r18
    3b7a:	9e d0       	rcall	.+316    	; 0x3cb8 <log>
    3b7c:	2f 91       	pop	r18
    3b7e:	3f 91       	pop	r19
    3b80:	4f 91       	pop	r20
    3b82:	5f 91       	pop	r21
    3b84:	52 df       	rcall	.-348    	; 0x3a2a <__mulsf3>
    3b86:	05 c0       	rjmp	.+10     	; 0x3b92 <exp>
    3b88:	19 f4       	brne	.+6      	; 0x3b90 <pow+0xa0>
    3b8a:	0e f0       	brts	.+2      	; 0x3b8e <pow+0x9e>
    3b8c:	fd ce       	rjmp	.-518    	; 0x3988 <__fp_inf>
    3b8e:	46 cf       	rjmp	.-372    	; 0x3a1c <__fp_zero>
    3b90:	01 cf       	rjmp	.-510    	; 0x3994 <__fp_nan>

00003b92 <exp>:
    3b92:	2a df       	rcall	.-428    	; 0x39e8 <__fp_splitA>
    3b94:	c8 f3       	brcs	.-14     	; 0x3b88 <pow+0x98>
    3b96:	96 38       	cpi	r25, 0x86	; 134
    3b98:	c0 f7       	brcc	.-16     	; 0x3b8a <pow+0x9a>
    3b9a:	07 f8       	bld	r0, 7
    3b9c:	0f 92       	push	r0
    3b9e:	e8 94       	clt
    3ba0:	2b e3       	ldi	r18, 0x3B	; 59
    3ba2:	3a ea       	ldi	r19, 0xAA	; 170
    3ba4:	48 eb       	ldi	r20, 0xB8	; 184
    3ba6:	5f e7       	ldi	r21, 0x7F	; 127
    3ba8:	4e df       	rcall	.-356    	; 0x3a46 <__mulsf3_pse>
    3baa:	0f 92       	push	r0
    3bac:	0f 92       	push	r0
    3bae:	0f 92       	push	r0
    3bb0:	4d b7       	in	r20, 0x3d	; 61
    3bb2:	5e b7       	in	r21, 0x3e	; 62
    3bb4:	0f 92       	push	r0
    3bb6:	c0 d0       	rcall	.+384    	; 0x3d38 <modf>
    3bb8:	e4 ee       	ldi	r30, 0xE4	; 228
    3bba:	f0 e0       	ldi	r31, 0x00	; 0
    3bbc:	16 d0       	rcall	.+44     	; 0x3bea <__fp_powser>
    3bbe:	4f 91       	pop	r20
    3bc0:	5f 91       	pop	r21
    3bc2:	ef 91       	pop	r30
    3bc4:	ff 91       	pop	r31
    3bc6:	e5 95       	asr	r30
    3bc8:	ee 1f       	adc	r30, r30
    3bca:	ff 1f       	adc	r31, r31
    3bcc:	49 f0       	breq	.+18     	; 0x3be0 <exp+0x4e>
    3bce:	fe 57       	subi	r31, 0x7E	; 126
    3bd0:	e0 68       	ori	r30, 0x80	; 128
    3bd2:	44 27       	eor	r20, r20
    3bd4:	ee 0f       	add	r30, r30
    3bd6:	44 1f       	adc	r20, r20
    3bd8:	fa 95       	dec	r31
    3bda:	e1 f7       	brne	.-8      	; 0x3bd4 <exp+0x42>
    3bdc:	41 95       	neg	r20
    3bde:	55 0b       	sbc	r21, r21
    3be0:	32 d0       	rcall	.+100    	; 0x3c46 <ldexp>
    3be2:	0f 90       	pop	r0
    3be4:	07 fe       	sbrs	r0, 7
    3be6:	26 c0       	rjmp	.+76     	; 0x3c34 <inverse>
    3be8:	08 95       	ret

00003bea <__fp_powser>:
    3bea:	df 93       	push	r29
    3bec:	cf 93       	push	r28
    3bee:	1f 93       	push	r17
    3bf0:	0f 93       	push	r16
    3bf2:	ff 92       	push	r15
    3bf4:	ef 92       	push	r14
    3bf6:	df 92       	push	r13
    3bf8:	7b 01       	movw	r14, r22
    3bfa:	8c 01       	movw	r16, r24
    3bfc:	68 94       	set
    3bfe:	05 c0       	rjmp	.+10     	; 0x3c0a <__fp_powser+0x20>
    3c00:	da 2e       	mov	r13, r26
    3c02:	ef 01       	movw	r28, r30
    3c04:	1e df       	rcall	.-452    	; 0x3a42 <__mulsf3x>
    3c06:	fe 01       	movw	r30, r28
    3c08:	e8 94       	clt
    3c0a:	a5 91       	lpm	r26, Z+
    3c0c:	25 91       	lpm	r18, Z+
    3c0e:	35 91       	lpm	r19, Z+
    3c10:	45 91       	lpm	r20, Z+
    3c12:	55 91       	lpm	r21, Z+
    3c14:	ae f3       	brts	.-22     	; 0x3c00 <__fp_powser+0x16>
    3c16:	ef 01       	movw	r28, r30
    3c18:	8e dd       	rcall	.-1252   	; 0x3736 <__addsf3x>
    3c1a:	fe 01       	movw	r30, r28
    3c1c:	97 01       	movw	r18, r14
    3c1e:	a8 01       	movw	r20, r16
    3c20:	da 94       	dec	r13
    3c22:	79 f7       	brne	.-34     	; 0x3c02 <__fp_powser+0x18>
    3c24:	df 90       	pop	r13
    3c26:	ef 90       	pop	r14
    3c28:	ff 90       	pop	r15
    3c2a:	0f 91       	pop	r16
    3c2c:	1f 91       	pop	r17
    3c2e:	cf 91       	pop	r28
    3c30:	df 91       	pop	r29
    3c32:	08 95       	ret

00003c34 <inverse>:
    3c34:	9b 01       	movw	r18, r22
    3c36:	ac 01       	movw	r20, r24
    3c38:	60 e0       	ldi	r22, 0x00	; 0
    3c3a:	70 e0       	ldi	r23, 0x00	; 0
    3c3c:	80 e8       	ldi	r24, 0x80	; 128
    3c3e:	9f e3       	ldi	r25, 0x3F	; 63
    3c40:	cd cd       	rjmp	.-1126   	; 0x37dc <__divsf3>
    3c42:	a2 ce       	rjmp	.-700    	; 0x3988 <__fp_inf>
    3c44:	ac c0       	rjmp	.+344    	; 0x3d9e <__fp_mpack>

00003c46 <ldexp>:
    3c46:	d0 de       	rcall	.-608    	; 0x39e8 <__fp_splitA>
    3c48:	e8 f3       	brcs	.-6      	; 0x3c44 <inverse+0x10>
    3c4a:	99 23       	and	r25, r25
    3c4c:	d9 f3       	breq	.-10     	; 0x3c44 <inverse+0x10>
    3c4e:	94 0f       	add	r25, r20
    3c50:	51 1d       	adc	r21, r1
    3c52:	bb f3       	brvs	.-18     	; 0x3c42 <inverse+0xe>
    3c54:	91 50       	subi	r25, 0x01	; 1
    3c56:	50 40       	sbci	r21, 0x00	; 0
    3c58:	94 f0       	brlt	.+36     	; 0x3c7e <ldexp+0x38>
    3c5a:	59 f0       	breq	.+22     	; 0x3c72 <ldexp+0x2c>
    3c5c:	88 23       	and	r24, r24
    3c5e:	32 f0       	brmi	.+12     	; 0x3c6c <ldexp+0x26>
    3c60:	66 0f       	add	r22, r22
    3c62:	77 1f       	adc	r23, r23
    3c64:	88 1f       	adc	r24, r24
    3c66:	91 50       	subi	r25, 0x01	; 1
    3c68:	50 40       	sbci	r21, 0x00	; 0
    3c6a:	c1 f7       	brne	.-16     	; 0x3c5c <ldexp+0x16>
    3c6c:	9e 3f       	cpi	r25, 0xFE	; 254
    3c6e:	51 05       	cpc	r21, r1
    3c70:	44 f7       	brge	.-48     	; 0x3c42 <inverse+0xe>
    3c72:	88 0f       	add	r24, r24
    3c74:	91 1d       	adc	r25, r1
    3c76:	96 95       	lsr	r25
    3c78:	87 95       	ror	r24
    3c7a:	97 f9       	bld	r25, 7
    3c7c:	08 95       	ret
    3c7e:	5f 3f       	cpi	r21, 0xFF	; 255
    3c80:	ac f0       	brlt	.+42     	; 0x3cac <ldexp+0x66>
    3c82:	98 3e       	cpi	r25, 0xE8	; 232
    3c84:	9c f0       	brlt	.+38     	; 0x3cac <ldexp+0x66>
    3c86:	bb 27       	eor	r27, r27
    3c88:	86 95       	lsr	r24
    3c8a:	77 95       	ror	r23
    3c8c:	67 95       	ror	r22
    3c8e:	b7 95       	ror	r27
    3c90:	08 f4       	brcc	.+2      	; 0x3c94 <ldexp+0x4e>
    3c92:	b1 60       	ori	r27, 0x01	; 1
    3c94:	93 95       	inc	r25
    3c96:	c1 f7       	brne	.-16     	; 0x3c88 <ldexp+0x42>
    3c98:	bb 0f       	add	r27, r27
    3c9a:	58 f7       	brcc	.-42     	; 0x3c72 <ldexp+0x2c>
    3c9c:	11 f4       	brne	.+4      	; 0x3ca2 <ldexp+0x5c>
    3c9e:	60 ff       	sbrs	r22, 0
    3ca0:	e8 cf       	rjmp	.-48     	; 0x3c72 <ldexp+0x2c>
    3ca2:	6f 5f       	subi	r22, 0xFF	; 255
    3ca4:	7f 4f       	sbci	r23, 0xFF	; 255
    3ca6:	8f 4f       	sbci	r24, 0xFF	; 255
    3ca8:	9f 4f       	sbci	r25, 0xFF	; 255
    3caa:	e3 cf       	rjmp	.-58     	; 0x3c72 <ldexp+0x2c>
    3cac:	b8 ce       	rjmp	.-656    	; 0x3a1e <__fp_szero>
    3cae:	0e f0       	brts	.+2      	; 0x3cb2 <ldexp+0x6c>
    3cb0:	76 c0       	rjmp	.+236    	; 0x3d9e <__fp_mpack>
    3cb2:	70 ce       	rjmp	.-800    	; 0x3994 <__fp_nan>
    3cb4:	68 94       	set
    3cb6:	68 ce       	rjmp	.-816    	; 0x3988 <__fp_inf>

00003cb8 <log>:
    3cb8:	97 de       	rcall	.-722    	; 0x39e8 <__fp_splitA>
    3cba:	c8 f3       	brcs	.-14     	; 0x3cae <ldexp+0x68>
    3cbc:	99 23       	and	r25, r25
    3cbe:	d1 f3       	breq	.-12     	; 0x3cb4 <ldexp+0x6e>
    3cc0:	c6 f3       	brts	.-16     	; 0x3cb2 <ldexp+0x6c>
    3cc2:	df 93       	push	r29
    3cc4:	cf 93       	push	r28
    3cc6:	1f 93       	push	r17
    3cc8:	0f 93       	push	r16
    3cca:	ff 92       	push	r15
    3ccc:	c9 2f       	mov	r28, r25
    3cce:	dd 27       	eor	r29, r29
    3cd0:	88 23       	and	r24, r24
    3cd2:	2a f0       	brmi	.+10     	; 0x3cde <log+0x26>
    3cd4:	21 97       	sbiw	r28, 0x01	; 1
    3cd6:	66 0f       	add	r22, r22
    3cd8:	77 1f       	adc	r23, r23
    3cda:	88 1f       	adc	r24, r24
    3cdc:	da f7       	brpl	.-10     	; 0x3cd4 <log+0x1c>
    3cde:	20 e0       	ldi	r18, 0x00	; 0
    3ce0:	30 e0       	ldi	r19, 0x00	; 0
    3ce2:	40 e8       	ldi	r20, 0x80	; 128
    3ce4:	5f eb       	ldi	r21, 0xBF	; 191
    3ce6:	9f e3       	ldi	r25, 0x3F	; 63
    3ce8:	88 39       	cpi	r24, 0x98	; 152
    3cea:	20 f0       	brcs	.+8      	; 0x3cf4 <log+0x3c>
    3cec:	80 3e       	cpi	r24, 0xE0	; 224
    3cee:	30 f0       	brcs	.+12     	; 0x3cfc <log+0x44>
    3cf0:	21 96       	adiw	r28, 0x01	; 1
    3cf2:	8f 77       	andi	r24, 0x7F	; 127
    3cf4:	0f dd       	rcall	.-1506   	; 0x3714 <__addsf3>
    3cf6:	ec e0       	ldi	r30, 0x0C	; 12
    3cf8:	f1 e0       	ldi	r31, 0x01	; 1
    3cfa:	03 c0       	rjmp	.+6      	; 0x3d02 <log+0x4a>
    3cfc:	0b dd       	rcall	.-1514   	; 0x3714 <__addsf3>
    3cfe:	e9 e3       	ldi	r30, 0x39	; 57
    3d00:	f1 e0       	ldi	r31, 0x01	; 1
    3d02:	73 df       	rcall	.-282    	; 0x3bea <__fp_powser>
    3d04:	8b 01       	movw	r16, r22
    3d06:	be 01       	movw	r22, r28
    3d08:	ec 01       	movw	r28, r24
    3d0a:	fb 2e       	mov	r15, r27
    3d0c:	6f 57       	subi	r22, 0x7F	; 127
    3d0e:	71 09       	sbc	r23, r1
    3d10:	75 95       	asr	r23
    3d12:	77 1f       	adc	r23, r23
    3d14:	88 0b       	sbc	r24, r24
    3d16:	99 0b       	sbc	r25, r25
    3d18:	fc dd       	rcall	.-1032   	; 0x3912 <__floatsisf>
    3d1a:	28 e1       	ldi	r18, 0x18	; 24
    3d1c:	32 e7       	ldi	r19, 0x72	; 114
    3d1e:	41 e3       	ldi	r20, 0x31	; 49
    3d20:	5f e3       	ldi	r21, 0x3F	; 63
    3d22:	8f de       	rcall	.-738    	; 0x3a42 <__mulsf3x>
    3d24:	af 2d       	mov	r26, r15
    3d26:	98 01       	movw	r18, r16
    3d28:	ae 01       	movw	r20, r28
    3d2a:	ff 90       	pop	r15
    3d2c:	0f 91       	pop	r16
    3d2e:	1f 91       	pop	r17
    3d30:	cf 91       	pop	r28
    3d32:	df 91       	pop	r29
    3d34:	00 dd       	rcall	.-1536   	; 0x3736 <__addsf3x>
    3d36:	3f ce       	rjmp	.-898    	; 0x39b6 <__fp_round>

00003d38 <modf>:
    3d38:	fa 01       	movw	r30, r20
    3d3a:	dc 01       	movw	r26, r24
    3d3c:	aa 0f       	add	r26, r26
    3d3e:	bb 1f       	adc	r27, r27
    3d40:	9b 01       	movw	r18, r22
    3d42:	ac 01       	movw	r20, r24
    3d44:	bf 57       	subi	r27, 0x7F	; 127
    3d46:	28 f4       	brcc	.+10     	; 0x3d52 <modf+0x1a>
    3d48:	22 27       	eor	r18, r18
    3d4a:	33 27       	eor	r19, r19
    3d4c:	44 27       	eor	r20, r20
    3d4e:	50 78       	andi	r21, 0x80	; 128
    3d50:	1f c0       	rjmp	.+62     	; 0x3d90 <modf+0x58>
    3d52:	b7 51       	subi	r27, 0x17	; 23
    3d54:	88 f4       	brcc	.+34     	; 0x3d78 <modf+0x40>
    3d56:	ab 2f       	mov	r26, r27
    3d58:	00 24       	eor	r0, r0
    3d5a:	46 95       	lsr	r20
    3d5c:	37 95       	ror	r19
    3d5e:	27 95       	ror	r18
    3d60:	01 1c       	adc	r0, r1
    3d62:	a3 95       	inc	r26
    3d64:	d2 f3       	brmi	.-12     	; 0x3d5a <modf+0x22>
    3d66:	00 20       	and	r0, r0
    3d68:	69 f0       	breq	.+26     	; 0x3d84 <modf+0x4c>
    3d6a:	22 0f       	add	r18, r18
    3d6c:	33 1f       	adc	r19, r19
    3d6e:	44 1f       	adc	r20, r20
    3d70:	b3 95       	inc	r27
    3d72:	da f3       	brmi	.-10     	; 0x3d6a <modf+0x32>
    3d74:	0d d0       	rcall	.+26     	; 0x3d90 <modf+0x58>
    3d76:	cd cc       	rjmp	.-1638   	; 0x3712 <__subsf3>
    3d78:	61 30       	cpi	r22, 0x01	; 1
    3d7a:	71 05       	cpc	r23, r1
    3d7c:	a0 e8       	ldi	r26, 0x80	; 128
    3d7e:	8a 07       	cpc	r24, r26
    3d80:	b9 46       	sbci	r27, 0x69	; 105
    3d82:	30 f4       	brcc	.+12     	; 0x3d90 <modf+0x58>
    3d84:	9b 01       	movw	r18, r22
    3d86:	ac 01       	movw	r20, r24
    3d88:	66 27       	eor	r22, r22
    3d8a:	77 27       	eor	r23, r23
    3d8c:	88 27       	eor	r24, r24
    3d8e:	90 78       	andi	r25, 0x80	; 128
    3d90:	30 96       	adiw	r30, 0x00	; 0
    3d92:	21 f0       	breq	.+8      	; 0x3d9c <modf+0x64>
    3d94:	20 83       	st	Z, r18
    3d96:	31 83       	std	Z+1, r19	; 0x01
    3d98:	42 83       	std	Z+2, r20	; 0x02
    3d9a:	53 83       	std	Z+3, r21	; 0x03
    3d9c:	08 95       	ret

00003d9e <__fp_mpack>:
    3d9e:	9f 3f       	cpi	r25, 0xFF	; 255
    3da0:	31 f0       	breq	.+12     	; 0x3dae <__fp_mpack_finite+0xc>

00003da2 <__fp_mpack_finite>:
    3da2:	91 50       	subi	r25, 0x01	; 1
    3da4:	20 f4       	brcc	.+8      	; 0x3dae <__fp_mpack_finite+0xc>
    3da6:	87 95       	ror	r24
    3da8:	77 95       	ror	r23
    3daa:	67 95       	ror	r22
    3dac:	b7 95       	ror	r27
    3dae:	88 0f       	add	r24, r24
    3db0:	91 1d       	adc	r25, r1
    3db2:	96 95       	lsr	r25
    3db4:	87 95       	ror	r24
    3db6:	97 f9       	bld	r25, 7
    3db8:	08 95       	ret

00003dba <__udivmodhi4>:
    3dba:	aa 1b       	sub	r26, r26
    3dbc:	bb 1b       	sub	r27, r27
    3dbe:	51 e1       	ldi	r21, 0x11	; 17
    3dc0:	07 c0       	rjmp	.+14     	; 0x3dd0 <__udivmodhi4_ep>

00003dc2 <__udivmodhi4_loop>:
    3dc2:	aa 1f       	adc	r26, r26
    3dc4:	bb 1f       	adc	r27, r27
    3dc6:	a6 17       	cp	r26, r22
    3dc8:	b7 07       	cpc	r27, r23
    3dca:	10 f0       	brcs	.+4      	; 0x3dd0 <__udivmodhi4_ep>
    3dcc:	a6 1b       	sub	r26, r22
    3dce:	b7 0b       	sbc	r27, r23

00003dd0 <__udivmodhi4_ep>:
    3dd0:	88 1f       	adc	r24, r24
    3dd2:	99 1f       	adc	r25, r25
    3dd4:	5a 95       	dec	r21
    3dd6:	a9 f7       	brne	.-22     	; 0x3dc2 <__udivmodhi4_loop>
    3dd8:	80 95       	com	r24
    3dda:	90 95       	com	r25
    3ddc:	bc 01       	movw	r22, r24
    3dde:	cd 01       	movw	r24, r26
    3de0:	08 95       	ret

00003de2 <_exit>:
    3de2:	f8 94       	cli

00003de4 <__stop_program>:
    3de4:	ff cf       	rjmp	.-2      	; 0x3de4 <__stop_program>
